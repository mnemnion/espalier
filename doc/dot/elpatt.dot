digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 157"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-57"]


section_1 -> { header_2 prose_3 prose_4 codeblock_5 section_6 section_7}
{rank=same; header_2 prose_3 prose_4 codeblock_5 section_6 section_7}

header_2 [label="1 : Extended Lpeg module"]

prose_3 [label="prose"]

prose_4 [label="prose"]

codeblock_5 [label="code block 10-20"]

section_6 [label="section: 22-30"]

section_7 [label="section: 58-132"]


header_2 -> leaf_8
leaf_8  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Extended Lpeg module"]
prose_3 -> { raw_9 prespace_10 literal_11 raw_12}
{rank=same; raw_9 prespace_10 literal_11 raw_12}

raw_9 [label="raw"]

prespace_10 [label="prespace"]

literal_11 [label="literal"]

raw_12 [label="raw"]


raw_9 -> leaf_13
leaf_13  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


  This is where we add extended captures a la the old"]
prespace_10 -> leaf_14
leaf_14  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_11 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label="epeg"]
raw_12 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" 
module.
"]
prose_4 -> { raw_17}
{rank=same; raw_17}

raw_17 [label="raw"]


raw_17 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The difference here is that we include lpeg as a metatable __index
and can therefore use elpeg as L everywhere we currently use lpeg.
"]
codeblock_5 -> leaf_19
leaf_19  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local L = require \"lpeg\"
local s = require \"status\" ()
s.verbose = false
local Node = require \"node\"
local elpatt = {}
elpatt.P, elpatt.B, elpatt.V, elpatt.R = L.P, L.B, L.V, L.R

local P, C, Cc, Cp, Ct, Carg = L.P, L.C, L.Cc, L.Cp, L.Ct, L.Carg
"]
section_6 -> { header_20 prose_21 prose_22 prose_23 section_24}
{rank=same; header_20 prose_21 prose_22 prose_23 section_24}

header_20 [label="2 : Ppt : Codepoint pattern"]

prose_21 [label="prose"]

prose_22 [label="prose"]

prose_23 [label="prose"]

section_24 [label="section: 31-57"]


header_20 -> leaf_25
leaf_25  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Ppt : Codepoint pattern"]
prose_21 -> { raw_26}
{rank=same; raw_26}

raw_26 [label="raw"]


raw_26 -> leaf_27
leaf_27  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Captures one Unicode point
"]
prose_22 -> { raw_28}
{rank=same; raw_28}

raw_28 [label="raw"]


raw_28 -> leaf_29
leaf_29  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I actually have no idea how to do this yet...
"]
prose_23 -> { raw_30 prespace_31 literal_32 raw_33}
{rank=same; raw_30 prespace_31 literal_32 raw_33}

raw_30 [label="raw"]

prespace_31 [label="prespace"]

literal_32 [label="literal"]

raw_33 [label="raw"]


raw_30 -> leaf_34
leaf_34  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Looks like byte 97 is just"]
prespace_31 -> leaf_35
leaf_35  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_32 -> leaf_36
leaf_36  [color=Gray,shape=rectangle,fontname=Inconsolata,label="\\97"]
raw_33 -> leaf_37
leaf_37  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" in Lua. That's easy enough.

"]
section_24 -> { header_38 prose_39 prose_40 codeblock_41}
{rank=same; header_38 prose_39 prose_40 codeblock_41}

header_38 [label="3 : num_bytes(str)"]

prose_39 [label="prose"]

prose_40 [label="prose"]

codeblock_41 [label="code block 39-55"]


header_38 -> leaf_42
leaf_42  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** num_bytes(str)"]
prose_39 -> { raw_43}
{rank=same; raw_43}

raw_43 [label="raw"]


raw_43 -> leaf_44
leaf_44  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Captures the number of bytes in the next codepoint of a string.
"]
prose_40 -> { raw_45 prespace_46 literal_47 raw_48}
{rank=same; raw_45 prespace_46 literal_47 raw_48}

raw_45 [label="raw"]

prespace_46 [label="prespace"]

literal_47 [label="literal"]

raw_48 [label="raw"]


raw_45 -> leaf_49
leaf_49  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The string must be well-formed utf-8, more precisely, a malformed
string will return"]
prespace_46 -> leaf_50
leaf_50  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_47 -> leaf_51
leaf_51  [color=Gray,shape=rectangle,fontname=Inconsolata,label="nil"]
raw_48 -> leaf_52
leaf_52  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".  A zero byte is correctly allowed by the
standard and will match here. 
"]
codeblock_41 -> leaf_53
leaf_53  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function num_bytes(str)
--returns the number of bytes in the next character in str
   local c = str:byte(1)
   if type(c) == 'number' then
      if c >= 0x00 and c <= 0x7F then
         return 1
      elseif c >= 0xC2 and c <= 0xDF then
         return 2
      elseif c >= 0xE0 and c <= 0xEF then
         return 3
      elseif c >= 0xF0 and c <= 0xF4 then
         return 4
      end
   end
end"]
section_7 -> { header_54 prose_55 prose_56 prose_57 prose_58 prose_59 prose_60 codeblock_61 section_62 section_63}
{rank=same; header_54 prose_55 prose_56 prose_57 prose_58 prose_59 prose_60 codeblock_61 section_62 section_63}

header_54 [label="2 : D : Drop a capture"]

prose_55 [label="prose"]

prose_56 [label="prose"]

prose_57 [label="prose"]

prose_58 [label="prose"]

prose_59 [label="prose"]

prose_60 [label="prose"]

codeblock_61 [label="code block 81-99"]

section_62 [label="section: 102-132"]

section_63 [label="section: 133-157"]


header_54 -> leaf_64
leaf_64  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** D : Drop a capture"]
prose_55 -> { raw_65 prespace_66 literal_67 raw_68}
{rank=same; raw_65 prespace_66 literal_67 raw_68}

raw_65 [label="raw"]

prespace_66 [label="prespace"]

literal_67 [label="literal"]

raw_68 [label="raw"]


raw_65 -> leaf_69
leaf_69  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  We discourage the use of captures in the Node class.  The architecture
requires that all array values of a Node table be themselves Nodes. This is
frequently checked for, in that we use"]
prespace_66 -> leaf_70
leaf_70  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_67 -> leaf_71
leaf_71  [color=Gray,shape=rectangle,fontname=Inconsolata,label="isNode"]
raw_68 -> leaf_72
leaf_72  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" to filter in iterators etc,
but this is defensive. 
"]
prose_56 -> { raw_73}
{rank=same; raw_73}

raw_73 [label="raw"]


raw_73 -> leaf_74
leaf_74  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The use of SUPPRESS lets us drop rules that we don't want to see in the
final AST.  A normal approach to parsing has explicit captures, but this is
inelegant compared to treating any Node without children as a leaf.
"]
prose_57 -> { raw_75 prespace_76 literal_77 raw_78}
{rank=same; raw_75 prespace_76 literal_77 raw_78}

raw_75 [label="raw"]

prespace_76 [label="prespace"]

literal_77 [label="literal"]

raw_78 [label="raw"]


raw_75 -> leaf_79
leaf_79  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
What about regions of text that don't interest us?  Canonically this
includes whitespace.  For those occasions, we have"]
prespace_76 -> leaf_80
leaf_80  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_77 -> leaf_81
leaf_81  [color=Gray,shape=rectangle,fontname=Inconsolata,label="elpatt.D"]
raw_78 -> leaf_82
leaf_82  [color=Gray,shape=rectangle,fontname=Inconsolata,label=". 
"]
prose_58 -> { prespace_83 literal_84 raw_85 prespace_86 literal_87 raw_88}
{rank=same; prespace_83 literal_84 raw_85 prespace_86 literal_87 raw_88}

prespace_83 [label="prespace"]

literal_84 [label="literal"]

raw_85 [label="raw"]

prespace_86 [label="prespace"]

literal_87 [label="literal"]

raw_88 [label="raw"]


prespace_83 -> leaf_89
leaf_89  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
literal_84 -> leaf_90
leaf_90  [color=Gray,shape=rectangle,fontname=Inconsolata,label="D"]
raw_85 -> leaf_91
leaf_91  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" needs to take a pattern, and if it succeeds in matching it, return a
special table, while discarding the captures if any. In"]
prespace_86 -> leaf_92
leaf_92  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_87 -> leaf_93
leaf_93  [color=Gray,shape=rectangle,fontname=Inconsolata,label="define"]
raw_88 -> leaf_94
leaf_94  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", we will
check for this table, and drop it whenever encountered.

"]
prose_59 -> { raw_95}
{rank=same; raw_95}

raw_95 [label="raw"]


raw_95 -> leaf_96
leaf_96  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  - patt :  The pattern to match and drop
"]
prose_60 -> { raw_97}
{rank=same; raw_97}

raw_97 [label="raw"]


raw_97 -> leaf_98
leaf_98  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  - #return : Special table DROP
"]
codeblock_61 -> leaf_99
leaf_99  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
local DROP = {}

elpatt.DROP = DROP

local function make_drop(caps)
   local dropped = setmetatable({}, DROP)
   dropped.DROP = true
   dropped.first = caps[1]
   dropped.last = caps[3]
   return dropped
end

function elpatt.D(patt)  
   return Ct(Cp() * Ct(patt) * Cp()) / make_drop
end
"]
section_62 -> { header_100 prose_101 prose_102 codeblock_103}
{rank=same; header_100 prose_101 prose_102 codeblock_103}

header_100 [label="3 : E : Capture an Error"]

prose_101 [label="prose"]

prose_102 [label="prose"]

codeblock_103 [label="code block 110-131"]


header_100 -> leaf_104
leaf_104  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** E : Capture an Error"]
prose_101 -> { raw_105}
{rank=same; raw_105}

raw_105 [label="raw"]


raw_105 -> leaf_106
leaf_106  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Rather than throwing errors, we prefer to add them to the parse tree in some
cases.
"]
prose_102 -> { raw_107 prespace_108 literal_109 raw_110}
{rank=same; raw_107 prespace_108 literal_109 raw_110}

raw_107 [label="raw"]

prespace_108 [label="prespace"]

literal_109 [label="literal"]

raw_110 [label="raw"]


raw_107 -> leaf_111
leaf_111  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
optionally, we can include a pattern which, if the parse were to be correct,
would succeed. So a"]
prespace_108 -> leaf_112
leaf_112  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_109 -> leaf_113
leaf_113  [color=Gray,shape=rectangle,fontname=Inconsolata,label="( ])"]
raw_110 -> leaf_114
leaf_114  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" type error could be \"fail to close (\" and =P\")\".
"]
codeblock_103 -> leaf_115
leaf_115  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local Err = Node:inherit()
Err.id = \"ERROR\"

local function parse_error(pos, msg, patt, str )
   local errorNode = setmetatable({}, Err)
   errorNode.first = pos
   errorNode.last  = pos
   errorNode.msg   = msg
   errorNode.str   = str
   errorNode.patt  = patt
   return errorNode
end

function elpatt.E( msg, patt)
  return Cp() * Cc(msg) * Cc(patt) * Carg(1) / parse_error
end

function elpatt.EOF( msg )
  return -P( 1 ) + elpatt.E( msg )
end"]
section_63 -> { header_116 prose_117 prose_118 prose_119 codeblock_120 codeblock_121}
{rank=same; header_116 prose_117 prose_118 prose_119 codeblock_120 codeblock_121}

header_116 [label="3 : S : Capture set"]

prose_117 [label="prose"]

prose_118 [label="prose"]

prose_119 [label="prose"]

codeblock_120 [label="code block 143-153"]

codeblock_121 [label="code block 155-157"]


header_116 -> leaf_122
leaf_122  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** S : Capture set"]
prose_117 -> { raw_123}
{rank=same; raw_123}

raw_123 [label="raw"]


raw_123 -> leaf_124
leaf_124  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Uses ordered choice to create a pattern which will match any provided
pattern. 
"]
prose_118 -> { raw_125}
{rank=same; raw_125}

raw_125 [label="raw"]


raw_125 -> leaf_126
leaf_126  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This will patternize anything you feed it, which is convenient for strings.
"]
prose_119 -> { raw_127}
{rank=same; raw_127}

raw_127 [label="raw"]


raw_127 -> leaf_128
leaf_128  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Despite being called \"Set\", it makes no attempt at uniqueness and will
match against patterns in the order provided. 
"]
codeblock_120 -> leaf_129
leaf_129  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function elpatt.S(a, ...)
   if not a then return nil end
   local arg = {...}
   local set = P(a)
   for _, patt in ipairs(arg) do
      set = set + P(patt)
   end
   return set
end"]
codeblock_121 -> leaf_130
leaf_130  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return elpatt"]

}
