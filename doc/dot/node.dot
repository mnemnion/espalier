digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 465"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-435"]


section_1 -> { header_2 prose_3 section_4 section_5 section_6 section_7 section_8}
{rank=same; header_2 prose_3 section_4 section_5 section_6 section_7 section_8}

header_2 [label="1 : Node"]

prose_3 [label="prose"]

section_4 [label="section: 8-16"]

section_5 [label="section: 17-28"]

section_6 [label="section: 29-40"]

section_7 [label="section: 41-413"]

section_8 [label="section: 436-455"]


header_2 -> leaf_9
leaf_9  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Node"]
prose_3 -> { raw_10}
{rank=same; raw_10}

raw_10 [label="raw"]


raw_10 -> leaf_11
leaf_11  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


  The Node class implements an abstract syntax tree, in collaboration with
the [[Grammar class][/grammar] and lpeg more generally.  

"]
section_4 -> { header_12 prose_13 codeblock_14}
{rank=same; header_12 prose_13 codeblock_14}

header_12 [label="3 : includes"]

prose_13 [label="prose"]

codeblock_14 [label="code block 10-14"]


header_12 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** includes"]
prose_13 -> { raw_16}
{rank=same; raw_16}

raw_16 [label="raw"]


raw_16 -> leaf_17
leaf_17  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_14 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local s = require \"status\" ()
local a = require \"ansi\"
local dot = require \"node/dot\""]
section_5 -> { header_19 prose_20 codeblock_21}
{rank=same; header_19 prose_20 codeblock_21}

header_19 [label="2 : Node metatable"]

prose_20 [label="prose"]

codeblock_21 [label="code block 22-26"]


header_19 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Node metatable"]
prose_20 -> { raw_23}
{rank=same; raw_23}

raw_23 [label="raw"]


raw_23 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  The Node metatable is the root table for any Node, all of which should
subclass through [[Node:inherit()][httk://]].
"]
codeblock_21 -> leaf_25
leaf_25  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local Node = {}
Node.__index = Node
Node.isNode = true"]
section_6 -> { header_26 prose_27 prose_28 prose_29}
{rank=same; header_26 prose_27 prose_28 prose_29}

header_26 [label="2 : Fields"]

prose_27 [label="prose"]

prose_28 [label="prose"]

prose_29 [label="prose"]


header_26 -> leaf_30
leaf_30  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Fields"]
prose_27 -> { raw_31}
{rank=same; raw_31}

raw_31 [label="raw"]


raw_31 -> leaf_32
leaf_32  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

   - id :  A string naming the Node. 
           This is identical to the name of the pattern that recognizes
           or captures it.
"]
prose_28 -> { raw_33}
{rank=same; raw_33}

raw_33 [label="raw"]


raw_33 -> leaf_34
leaf_34  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
           This is never set on Node itself, and Grammar will fail to
           produce a Node which lacks this flag. 
"]
prose_29 -> { raw_35 prespace_36 literal_37 raw_38}
{rank=same; raw_35 prespace_36 literal_37 raw_38}

raw_35 [label="raw"]

prespace_36 [label="prespace"]

literal_37 [label="literal"]

raw_38 [label="raw"]


raw_35 -> leaf_39
leaf_39  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
   - isNode :  A boolean, always"]
prespace_36 -> leaf_40
leaf_40  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_37 -> leaf_41
leaf_41  [color=Gray,shape=rectangle,fontname=Inconsolata,label="true"]
raw_38 -> leaf_42
leaf_42  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".

"]
section_7 -> { header_43 prose_44 section_45 section_46 section_47 section_48 section_49}
{rank=same; header_43 prose_44 section_45 section_46 section_47 section_48 section_49}

header_43 [label="2 : Methods"]

prose_44 [label="prose"]

section_45 [label="section: 44-57"]

section_46 [label="section: 58-97"]

section_47 [label="section: 98-378"]

section_48 [label="section: 396-413"]

section_49 [label="section: 414-416"]


header_43 -> leaf_50
leaf_50  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Methods"]
prose_44 -> { raw_51}
{rank=same; raw_51}

raw_51 [label="raw"]


raw_51 -> leaf_52
leaf_52  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

"]
section_45 -> { header_53 prose_54 prose_55 codeblock_56}
{rank=same; header_53 prose_54 prose_55 codeblock_56}

header_53 [label="4 : toLua"]

prose_54 [label="prose"]

prose_55 [label="prose"]

codeblock_56 [label="code block 51-55"]


header_53 -> leaf_57
leaf_57  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** toLua"]
prose_54 -> { raw_58}
{rank=same; raw_58}

raw_58 [label="raw"]


raw_58 -> leaf_59
leaf_59  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This is not a general method in any sense, it's here as a backstop
while I build out Clu. 
"]
prose_55 -> { raw_60}
{rank=same; raw_60}

raw_60 [label="raw"]


raw_60 -> leaf_61
leaf_61  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  - [ ] #todo remove
"]
codeblock_56 -> leaf_62
leaf_62  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.toLua(node)
  s:halt(\"No toLua method for \" .. node.id)
end"]
section_46 -> { header_63 prose_64 prose_65 codeblock_66}
{rank=same; header_63 prose_64 prose_65 codeblock_66}

header_63 [label="3 : Visualizer"]

prose_64 [label="prose"]

prose_65 [label="prose"]

codeblock_66 [label="code block 65-96"]


header_63 -> leaf_67
leaf_67  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Visualizer"]
prose_64 -> { raw_68}
{rank=same; raw_68}

raw_68 [label="raw"]


raw_68 -> leaf_69
leaf_69  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This gives us a nice, tree-shaped printout of an entire Node.
"]
prose_65 -> { raw_70}
{rank=same; raw_70}

raw_70 [label="raw"]


raw_70 -> leaf_71
leaf_71  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
We're less disciplined than we should be about up-assigning this to
inherited Node classes. 
"]
codeblock_66 -> leaf_72
leaf_72  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.toString(node, depth)
   local depth = depth or 0
   local phrase = \"\"
   phrase = (\"  \"):rep(depth) .. a.bright(node.id) .. \"    \"
      .. a.cyan(node.first) .. \"-\" .. a.cyan(node.last)
   if node[1] then
      local extra = \"    \"
      if Node.len(node) > 56 then
         --  Truncate in the middle
         local span = Node.span(node)
         local pre, post = string.sub(span, 1, 26), string.sub(span, -26, -1)
         extra = extra .. a.dim(pre) .. a.bright(\"………\") .. a.dim(post)
         extra = extra:gsub(\"\\n\", \"◼︎\")
      else
         extra = extra .. a.dim(Node.span(node):gsub(\"\\n\", \"◼︎\"))
      end
      phrase = phrase .. extra .. \"\\n\"
      for _,v in ipairs(node) do
         if (v.isNode) then
            phrase = phrase .. Node.toString(v, depth + 1)
         end
      end
   else
      local val = node.str:sub(node.first, node.last)
                          :gsub(\" \", a.clear() .. a.dim(\"_\") .. a.green())
      val = a.green(val)
      phrase = phrase .. \"    \" .. val  .. \"\\n\"
   end
   return phrase
end"]
section_47 -> { header_73 prose_74 section_75 section_76 section_77 section_78 section_79 section_80 section_81 section_82 section_83 section_84}
{rank=same; header_73 prose_74 section_75 section_76 section_77 section_78 section_79 section_80 section_81 section_82 section_83 section_84}

header_73 [label="3 : Metrics"]

prose_74 [label="prose"]

section_75 [label="section: 101-109"]

section_76 [label="section: 110-120"]

section_77 [label="section: 121-192"]

section_78 [label="section: 193-213"]

section_79 [label="section: 214-236"]

section_80 [label="section: 237-276"]

section_81 [label="section: 277-295"]

section_82 [label="section: 296-344"]

section_83 [label="section: 345-378"]

section_84 [label="section: 379-395"]


header_73 -> leaf_85
leaf_85  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Metrics"]
prose_74 -> { raw_86}
{rank=same; raw_86}

raw_86 [label="raw"]


raw_86 -> leaf_87
leaf_87  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

"]
section_75 -> { header_88 prose_89 codeblock_90}
{rank=same; header_88 prose_89 codeblock_90}

header_88 [label="4 : span"]

prose_89 [label="prose"]

codeblock_90 [label="code block 103-107"]


header_88 -> leaf_91
leaf_91  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** span"]
prose_89 -> { raw_92}
{rank=same; raw_92}

raw_92 [label="raw"]


raw_92 -> leaf_93
leaf_93  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_90 -> leaf_94
leaf_94  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.span(node)
   return string.sub(node.str, node.first, node.last)
end"]
section_76 -> { header_95 prose_96 codeblock_97}
{rank=same; header_95 prose_96 codeblock_97}

header_95 [label="4 : len"]

prose_96 [label="prose"]

codeblock_97 [label="code block 114-118"]


header_95 -> leaf_98
leaf_98  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** len"]
prose_96 -> { raw_99}
{rank=same; raw_99}

raw_99 [label="raw"]


raw_99 -> leaf_100
leaf_100  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

ahh, the pleasure of indexing by one. 
"]
codeblock_97 -> leaf_101
leaf_101  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.len(node)
    return 1 + node.last - node.first
end"]
section_77 -> { header_102 prose_103 prose_104 prose_105 prose_106 prose_107 codeblock_108 codeblock_109}
{rank=same; header_102 prose_103 prose_104 prose_105 prose_106 prose_107 codeblock_108 codeblock_109}

header_102 [label="4 : Node:gap(node)"]

prose_103 [label="prose"]

prose_104 [label="prose"]

prose_105 [label="prose"]

prose_106 [label="prose"]

prose_107 [label="prose"]

codeblock_108 [label="code block 140-160"]

codeblock_109 [label="code block 163-191"]


header_102 -> leaf_110
leaf_110  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node:gap(node)"]
prose_103 -> { raw_111 prespace_112 literal_113 raw_114 prespace_115 literal_116 raw_117 prespace_118 literal_119 raw_120 prespace_121 literal_122 raw_123 prespace_124 literal_125 raw_126 prespace_127 bold_128 raw_129}
{rank=same; raw_111 prespace_112 literal_113 raw_114 prespace_115 literal_116 raw_117 prespace_118 literal_119 raw_120 prespace_121 literal_122 raw_123 prespace_124 literal_125 raw_126 prespace_127 bold_128 raw_129}

raw_111 [label="raw"]

prespace_112 [label="prespace"]

literal_113 [label="literal"]

raw_114 [label="raw"]

prespace_115 [label="prespace"]

literal_116 [label="literal"]

raw_117 [label="raw"]

prespace_118 [label="prespace"]

literal_119 [label="literal"]

raw_120 [label="raw"]

prespace_121 [label="prespace"]

literal_122 [label="literal"]

raw_123 [label="raw"]

prespace_124 [label="prespace"]

literal_125 [label="literal"]

raw_126 [label="raw"]

prespace_127 [label="prespace"]

bold_128 [label="bold"]

raw_129 [label="raw"]


raw_111 -> leaf_130
leaf_130  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
prespace_112 -> leaf_131
leaf_131  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
literal_113 -> leaf_132
leaf_132  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Node.gap(left, right)"]
raw_114 -> leaf_133
leaf_133  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" compares the"]
prespace_115 -> leaf_134
leaf_134  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_116 -> leaf_135
leaf_135  [color=Gray,shape=rectangle,fontname=Inconsolata,label="last"]
raw_117 -> leaf_136
leaf_136  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" field of the"]
prespace_118 -> leaf_137
leaf_137  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_119 -> leaf_138
leaf_138  [color=Gray,shape=rectangle,fontname=Inconsolata,label="left"]
raw_120 -> leaf_139
leaf_139  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" parameter
with the"]
prespace_121 -> leaf_140
leaf_140  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_122 -> leaf_141
leaf_141  [color=Gray,shape=rectangle,fontname=Inconsolata,label="first"]
raw_123 -> leaf_142
leaf_142  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" field of the"]
prespace_124 -> leaf_143
leaf_143  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_125 -> leaf_144
leaf_144  [color=Gray,shape=rectangle,fontname=Inconsolata,label="right"]
raw_126 -> leaf_145
leaf_145  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" parameter,"]
prespace_127 -> leaf_146
leaf_146  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
bold_128 -> leaf_147
leaf_147  [color=Gray,shape=rectangle,fontname=Inconsolata,label="if"]
raw_129 -> leaf_148
leaf_148  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" this is greater than
0. 
"]
prose_104 -> { raw_149 prespace_150 literal_151 raw_152 prespace_153 literal_154 raw_155 prespace_156 literal_157 raw_158 prespace_159 literal_160 raw_161 prespace_162 literal_163 raw_164}
{rank=same; raw_149 prespace_150 literal_151 raw_152 prespace_153 literal_154 raw_155 prespace_156 literal_157 raw_158 prespace_159 literal_160 raw_161 prespace_162 literal_163 raw_164}

raw_149 [label="raw"]

prespace_150 [label="prespace"]

literal_151 [label="literal"]

raw_152 [label="raw"]

prespace_153 [label="prespace"]

literal_154 [label="literal"]

raw_155 [label="raw"]

prespace_156 [label="prespace"]

literal_157 [label="literal"]

raw_158 [label="raw"]

prespace_159 [label="prespace"]

literal_160 [label="literal"]

raw_161 [label="raw"]

prespace_162 [label="prespace"]

literal_163 [label="literal"]

raw_164 [label="raw"]


raw_149 -> leaf_165
leaf_165  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If it is negative,"]
prespace_150 -> leaf_166
leaf_166  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_151 -> leaf_167
leaf_167  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Node.gap"]
raw_152 -> leaf_168
leaf_168  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" attempts to measure the"]
prespace_153 -> leaf_169
leaf_169  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_154 -> leaf_170
leaf_170  [color=Gray,shape=rectangle,fontname=Inconsolata,label="first"]
raw_155 -> leaf_171
leaf_171  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" field of the"]
prespace_156 -> leaf_172
leaf_172  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
literal_157 -> leaf_173
leaf_173  [color=Gray,shape=rectangle,fontname=Inconsolata,label="right"]
raw_158 -> leaf_174
leaf_174  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" parameter against the"]
prespace_159 -> leaf_175
leaf_175  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_160 -> leaf_176
leaf_176  [color=Gray,shape=rectangle,fontname=Inconsolata,label="last"]
raw_161 -> leaf_177
leaf_177  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" field of the"]
prespace_162 -> leaf_178
leaf_178  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_163 -> leaf_179
leaf_179  [color=Gray,shape=rectangle,fontname=Inconsolata,label="left"]
raw_164 -> leaf_180
leaf_180  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" parameter.
"]
prose_105 -> { raw_181 prespace_182 bold_183 raw_184}
{rank=same; raw_181 prespace_182 bold_183 raw_184}

raw_181 [label="raw"]

prespace_182 [label="prespace"]

bold_183 [label="bold"]

raw_184 [label="raw"]


raw_181 -> leaf_185
leaf_185  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If this is a natural number we return the"]
prespace_182 -> leaf_186
leaf_186  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
bold_183 -> leaf_187
leaf_187  [color=Gray,shape=rectangle,fontname=Inconsolata,label="negation"]
raw_184 -> leaf_188
leaf_188  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" of this value.  If both
should prove to be positive, we halt. 
"]
prose_106 -> { raw_189 prespace_190 literal_191 raw_192}
{rank=same; raw_189 prespace_190 literal_191 raw_192}

raw_189 [label="raw"]

prespace_190 [label="prespace"]

literal_191 [label="literal"]

raw_192 [label="raw"]


raw_189 -> leaf_193
leaf_193  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
No effort is made to check that the"]
prespace_190 -> leaf_194
leaf_194  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_191 -> leaf_195
leaf_195  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str"]
raw_192 -> leaf_196
leaf_196  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" field matches between nodes unless
we have an error, in which case it could prove helpful for diagnosis.  
"]
prose_107 -> { raw_197}
{rank=same; raw_197}

raw_197 [label="raw"]


raw_197 -> leaf_198
leaf_198  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Indeed such a check would be a disaster in streams or other sort of
piecewise parse.  Which will require implementation in and of itself, but
in the meantime...
"]
codeblock_108 -> leaf_199
leaf_199  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.gap(left, right)
  assert(left.last, \"no left.last\")
  assert(right.first, \"no right.first\")
  assert(right.last, \"no right.last\")
  assert(left.first, \"no left.first\")
  if left.first >= right.last then
    local left, right = right, left
  elseif left.last > right.first then
    s:halt(\"overlapping regions or str issue\")
  end
  local gap = left
  if gap >= 0 then
    return gap
  else
    s:halt(\"some kind of situation where gap is \" .. tostring(gap))
  end

  return nil 
end"]
codeblock_109 -> leaf_200
leaf_200  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.dotLabel(node)
  return node.id
end

function Node.toMarkdown(node)
  if not node[1] then
    return string.sub(node.str, node.first, node.last)
  else
    s:halt(\"no toMarkdown for \" .. node.id)
  end
end

function Node.dot(node)
  return dot.dot(node)
end

function Node.toValue(node)
  if node.__VALUE then
    return node.__VALUE
  end
  if node.str then
    return node.str:sub(node.first,node.last)
  else
    s:halt(\"no str on node \" .. node.id)
  end
end
"]
section_78 -> { header_201 prose_202 codeblock_203}
{rank=same; header_201 prose_202 codeblock_203}

header_201 [label="4 : Node.walkPost"]

prose_202 [label="prose"]

codeblock_203 [label="code block 197-212"]


header_201 -> leaf_204
leaf_204  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.walkPost"]
prose_202 -> { raw_205}
{rank=same; raw_205}

raw_205 [label="raw"]


raw_205 -> leaf_206
leaf_206  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Depth-first iterator, postfix 
"]
codeblock_203 -> leaf_207
leaf_207  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.walkPost(node)
    local function traverse(ast)
        if not ast.isNode then return nil end

        for _, v in ipairs(ast) do
            if type(v) == 'table' and v.isNode then
              traverse(v)
            end
        end
        coroutine.yield(ast)
    end

    return coroutine.wrap(function() traverse(node) end)
end"]
section_79 -> { header_208 prose_209 codeblock_210}
{rank=same; header_208 prose_209 codeblock_210}

header_208 [label="4 : Node.walk"]

prose_209 [label="prose"]

codeblock_210 [label="code block 218-234"]


header_208 -> leaf_211
leaf_211  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.walk"]
prose_209 -> { raw_212}
{rank=same; raw_212}

raw_212 [label="raw"]


raw_212 -> leaf_213
leaf_213  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Presearch iterator.  This is the default. 
"]
codeblock_210 -> leaf_214
leaf_214  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.walk(node)
  local function traverse(ast)
    if not ast.isNode then return nil end

    coroutine.yield(ast)
    for _, v in ipairs(ast) do
      if type(v) == 'table' and v.isNode then
        traverse(v)
      end
    end
  end

  return coroutine.wrap(function() traverse(node) end)
end
"]
section_80 -> { header_215 prose_216 codeblock_217}
{rank=same; header_215 prose_216 codeblock_217}

header_215 [label="4 : Node.select(node, pred)"]

prose_216 [label="prose"]

codeblock_217 [label="code block 243-274"]


header_215 -> leaf_218
leaf_218  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.select(node, pred)"]
prose_216 -> { raw_219 prespace_220 literal_221 raw_222 prespace_223 literal_224 raw_225}
{rank=same; raw_219 prespace_220 literal_221 raw_222 prespace_223 literal_224 raw_225}

raw_219 [label="raw"]

prespace_220 [label="prespace"]

literal_221 [label="literal"]

raw_222 [label="raw"]

prespace_223 [label="prespace"]

literal_224 [label="literal"]

raw_225 [label="raw"]


raw_219 -> leaf_226
leaf_226  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Takes the Node and walks it, yielding the Nodes which match the predicate."]
prespace_220 -> leaf_227
leaf_227  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
literal_221 -> leaf_228
leaf_228  [color=Gray,shape=rectangle,fontname=Inconsolata,label="pred"]
raw_222 -> leaf_229
leaf_229  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is either a string, which matches to"]
prespace_223 -> leaf_230
leaf_230  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_224 -> leaf_231
leaf_231  [color=Gray,shape=rectangle,fontname=Inconsolata,label="id"]
raw_225 -> leaf_232
leaf_232  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", or a function, which takes
a Node and returns true or false on some premise. 
"]
codeblock_217 -> leaf_233
leaf_233  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.select(node, pred)
   local function qualifies(node, pred)
      if type(pred) == 'string' then
         if type(node) == 'table' 
          and node.id and node.id == pred then
            return true
         else
            return false
         end
      elseif type(pred) == 'function' then
         return pred(node)
      else
         s:halt(\"cannot select on predicate of type \" .. type(pred))
      end
   end

   local function traverse(ast)
      -- breadth first
      if qualifies(ast, pred) then
         coroutine.yield(ast)
      end
      if ast.isNode then
         for _, v in ipairs(ast) do
            traverse(v)
         end
      end
   end

   return coroutine.wrap(function() traverse(node) end)
end"]
section_81 -> { header_234 prose_235 codeblock_236}
{rank=same; header_234 prose_235 codeblock_236}

header_234 [label="4 : Node.tokens(node)"]

prose_235 [label="prose"]

codeblock_236 [label="code block 281-293"]


header_234 -> leaf_237
leaf_237  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.tokens(node)"]
prose_235 -> { raw_238}
{rank=same; raw_238}

raw_238 [label="raw"]


raw_238 -> leaf_239
leaf_239  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Iterator returning all captured values as strings.
"]
codeblock_236 -> leaf_240
leaf_240  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.tokens(node)
  local function traverse(ast)
    for node in Node.walk(ast) do
      if not node[1] then
        coroutine.yield(node:toValue())
      end
    end
  end

  return coroutine.wrap(function() traverse(node) end)
end  "]
section_82 -> { header_241 prose_242 prose_243 prose_244 codeblock_245}
{rank=same; header_241 prose_242 prose_243 prose_244 codeblock_245}

header_241 [label="4 : Node.lines(node)"]

prose_242 [label="prose"]

prose_243 [label="prose"]

prose_244 [label="prose"]

codeblock_245 [label="code block 306-343"]


header_241 -> leaf_246
leaf_246  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.lines(node)"]
prose_242 -> { raw_247 prespace_248 literal_249 raw_250}
{rank=same; raw_247 prespace_248 literal_249 raw_250}

raw_247 [label="raw"]

prespace_248 [label="prespace"]

literal_249 [label="literal"]

raw_250 [label="raw"]


raw_247 -> leaf_251
leaf_251  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

A memoized iterator returning"]
prespace_248 -> leaf_252
leaf_252  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_249 -> leaf_253
leaf_253  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str"]
raw_250 -> leaf_254
leaf_254  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" one line at a time. 
"]
prose_243 -> { raw_255}
{rank=same; raw_255}

raw_255 [label="raw"]


raw_255 -> leaf_256
leaf_256  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Newlines are not included.
"]
prose_244 -> { raw_257 prespace_258 literal_259 raw_260}
{rank=same; raw_257 prespace_258 literal_259 raw_260}

raw_257 [label="raw"]

prespace_258 [label="prespace"]

literal_259 [label="literal"]

raw_260 [label="raw"]


raw_257 -> leaf_261
leaf_261  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
In addition, the first"]
prespace_258 -> leaf_262
leaf_262  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_259 -> leaf_263
leaf_263  [color=Gray,shape=rectangle,fontname=Inconsolata,label="node:lines() traversal builds up
a sourcemap subsequently used by "]
raw_260 -> leaf_264
leaf_264  [color=Gray,shape=rectangle,fontname=Inconsolata,label="node:atLine(pos)= to
return the line and column of a given position.
"]
codeblock_245 -> leaf_265
leaf_265  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.lines(node)
  local function yieldLines(node, linum)
     for _, str in ipairs(node.__lines) do
        coroutine.yield(str)
      end
  end

  if node.__lines then
     return coroutine.wrap(function ()
                              yieldLines(node) 
                           end)
  else 
     node.__lines = {}
  end

  local function buildLines(str)
      if str == nil then
        return nil
      end
      local rest = \"\"
      local first, last = string.find(str, \"\\n\")
      if first == nil then 
        return nil
      else
        local line = string.sub(str, 1, first - 1) -- no newline
        rest       = string.sub(str, last + 1)    -- skip newline
        node.__lines[#node.__lines + 1] = line
        coroutine.yield(line)
      end
      buildLines(rest)
  end

  return coroutine.wrap(function () 
                           buildLines(node.str) 
                        end)
end"]
section_83 -> { header_266 prose_267 prose_268 codeblock_269}
{rank=same; header_266 prose_267 prose_268 codeblock_269}

header_266 [label="4 : Node.linePos(node, position)"]

prose_267 [label="prose"]

prose_268 [label="prose"]

codeblock_269 [label="code block 352-376"]


header_266 -> leaf_270
leaf_270  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.linePos(node, position)"]
prose_267 -> { raw_271}
{rank=same; raw_271}

raw_271 [label="raw"]


raw_271 -> leaf_272
leaf_272  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Returns the line and column given a position.
"]
prose_268 -> { raw_273}
{rank=same; raw_273}

raw_273 [label="raw"]


raw_273 -> leaf_274
leaf_274  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This is implemented as a classic loop made slightly harder to get
right by Lua's indexing and the missing newline.  
"]
codeblock_269 -> leaf_275
leaf_275  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.linePos(node, position)
   if not node.__lines then
      for _ in node:lines() do
        -- nothing, this generates the line map
      end
   end
   local offset = 0
   local position = position
   local linum = nil
   for i, v in ipairs(node.__lines) do
       linum = i
       local len = #v + 1 -- for nl
       local offset = offset + len
       if offset > position then
          return linum, position
       elseif offset == position then
          return linum, len
       else
          position = position - #v - 1
       end
   end
   return nil -- this position is off the end of the string
end"]
section_84 -> { header_276 prose_277 prose_278 codeblock_279}
{rank=same; header_276 prose_277 prose_278 codeblock_279}

header_276 [label="4 : Node.lastLeaf(node)"]

prose_277 [label="prose"]

prose_278 [label="prose"]

codeblock_279 [label="code block 385-393"]


header_276 -> leaf_280
leaf_280  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.lastLeaf(node)"]
prose_277 -> { raw_281}
{rank=same; raw_281}

raw_281 [label="raw"]


raw_281 -> leaf_282
leaf_282  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Returns the last leaf of the node.
"]
prose_278 -> { raw_283}
{rank=same; raw_283}

raw_283 [label="raw"]


raw_283 -> leaf_284
leaf_284  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Useful to check for terminal errors, for stop-on-error parsing. 
"]
codeblock_279 -> leaf_285
leaf_285  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.lastLeaf(node)
  if #node == 0 then 
    return node
  else
    return Node.lastLeaf(node[#node])
  end
end"]
section_48 -> { header_286 prose_287 prose_288 codeblock_289}
{rank=same; header_286 prose_287 prose_288 codeblock_289}

header_286 [label="3 : Collectors"]

prose_287 [label="prose"]

prose_288 [label="prose"]

codeblock_289 [label="code block 403-412"]


header_286 -> leaf_290
leaf_290  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Collectors"]
prose_287 -> { raw_291}
{rank=same; raw_291}

raw_291 [label="raw"]


raw_291 -> leaf_292
leaf_292  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

These return an array of all results. 
"]
prose_288 -> { raw_293}
{rank=same; raw_293}

raw_293 [label="raw"]


raw_293 -> leaf_294
leaf_294  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- [ ] #todo  Add a Forest class to provide the iterator interface for
             the return arrays of this class.
"]
codeblock_289 -> leaf_295
leaf_295  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.gather(node, pred)
  local gathered = {}
  for ast in node:select(pred) do
    gathered[#gathered + 1] = ast
  end
  
  return gathered
end"]
section_49 -> { header_296 prose_297 section_298}
{rank=same; header_296 prose_297 section_298}

header_296 [label="3 : Subclassing and construction"]

prose_297 [label="prose"]

section_298 [label="section: 417-435"]


header_296 -> leaf_299
leaf_299  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Subclassing and construction"]
prose_297 -> { raw_300}
{rank=same; raw_300}

raw_300 [label="raw"]


raw_300 -> leaf_301
leaf_301  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

"]
section_298 -> { header_302 prose_303 codeblock_304}
{rank=same; header_302 prose_303 codeblock_304}

header_302 [label="4 : N.inherit(node)"]

prose_303 [label="prose"]

codeblock_304 [label="code block 419-433"]


header_302 -> leaf_305
leaf_305  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** N.inherit(node)"]
prose_303 -> { raw_306}
{rank=same; raw_306}

raw_306 [label="raw"]


raw_306 -> leaf_307
leaf_307  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_304 -> leaf_308
leaf_308  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.inherit(node)
  local Meta = setmetatable({}, node)
  Meta.__index = Meta
  local meta = setmetatable({}, Meta)
  meta.__index = meta
  return Meta, meta
end

function Node.export(_, mod, constructor)
  mod.__call = constructor
  return setmetatable({}, mod)
end
"]
section_8 -> { header_309 prose_310 prose_311 prose_312 section_313 section_314}
{rank=same; header_309 prose_310 prose_311 prose_312 section_313 section_314}

header_309 [label="2 : Node Instances"]

prose_310 [label="prose"]

prose_311 [label="prose"]

prose_312 [label="prose"]

section_313 [label="section: 447-455"]

section_314 [label="section: 456-465"]


header_309 -> leaf_315
leaf_315  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Node Instances"]
prose_310 -> { raw_316}
{rank=same; raw_316}

raw_316 [label="raw"]


raw_316 -> leaf_317
leaf_317  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  To be a Node, indexed elements of the Array portion must also be 
Nodes. 
"]
prose_311 -> { raw_318}
{rank=same; raw_318}

raw_318 [label="raw"]


raw_318 -> leaf_319
leaf_319  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If there are no children of the Node, it is considered to be a leaf node.
"]
prose_312 -> { raw_320}
{rank=same; raw_320}

raw_320 [label="raw"]


raw_320 -> leaf_321
leaf_321  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Most of the Node library will fail to halt, and probably blow stack, if
cyclic Node graphs are made.  The Grammar class will not do this to you. 

"]
section_313 -> { header_322 prose_323}
{rank=same; header_322 prose_323}

header_322 [label="3 : Fields"]

prose_323 [label="prose"]


header_322 -> leaf_324
leaf_324  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Fields"]
prose_323 -> { raw_325 prespace_326 literal_327 raw_328 prespace_329 literal_330 raw_331}
{rank=same; raw_325 prespace_326 literal_327 raw_328 prespace_329 literal_330 raw_331}

raw_325 [label="raw"]

prespace_326 [label="prespace"]

literal_327 [label="literal"]

raw_328 [label="raw"]

prespace_329 [label="prespace"]

literal_330 [label="literal"]

raw_331 [label="raw"]


raw_325 -> leaf_332
leaf_332  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  There are invariant fields a Node is also expected to have, they are:
 
  - first :  Index into"]
prespace_326 -> leaf_333
leaf_333  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_327 -> leaf_334
leaf_334  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str"]
raw_328 -> leaf_335
leaf_335  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" which begins the span.
  - last  :  Index into"]
prespace_329 -> leaf_336
leaf_336  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_330 -> leaf_337
leaf_337  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str"]
raw_331 -> leaf_338
leaf_338  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" which ends the span.
  - str   :  The string of which the Node spans part or the whole.

"]
section_314 -> { header_339 prose_340 codeblock_341}
{rank=same; header_339 prose_340 codeblock_341}

header_339 [label="3 : Other fields"]

prose_340 [label="prose"]

codeblock_341 [label="code block 460-462"]


header_339 -> leaf_342
leaf_342  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Other fields"]
prose_340 -> { raw_343}
{rank=same; raw_343}

raw_343 [label="raw"]


raw_343 -> leaf_344
leaf_344  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  In principle, anything at all. 
"]
codeblock_341 -> leaf_345
leaf_345  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return Node"]

}
