digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 387"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-292"]


section_1 -> { header_2 prose_3 section_4 section_5 section_6 section_7 section_8}
{rank=same; header_2 prose_3 section_4 section_5 section_6 section_7 section_8}

header_2 [label="1 : Node"]

prose_3 [label="prose"]

section_4 [label="section: 6-13"]

section_5 [label="section: 14-28"]

section_6 [label="section: 29-45"]

section_7 [label="section: 46-271"]

section_8 [label="section: 293-352"]


header_2 -> leaf_9
leaf_9  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Node"]
prose_3 -> { raw_10}
{rank=same; raw_10}

raw_10 [label="raw"]


raw_10 -> leaf_11
leaf_11  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


  Time to stabilize this class once and for all. 
"]
section_4 -> { header_12 prose_13 codeblock_14}
{rank=same; header_12 prose_13 codeblock_14}

header_12 [label="3 : includes"]

prose_13 [label="prose"]

codeblock_14 [label="code block 8-12"]


header_12 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** includes"]
prose_13 -> { raw_16}
{rank=same; raw_16}

raw_16 [label="raw"]


raw_16 -> leaf_17
leaf_17  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_14 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local s = require \"status\"
local ansi = require \"ansi\"
local dot = require \"node/dot\""]
section_5 -> { header_19 prose_20 codeblock_21}
{rank=same; header_19 prose_20 codeblock_21}

header_19 [label="2 : Node metatable"]

prose_20 [label="prose"]

codeblock_21 [label="code block 20-25"]


header_19 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Node metatable"]
prose_20 -> { raw_23 literal_24 raw_25}
{rank=same; raw_23 literal_24 raw_25}

raw_23 [label="raw"]

literal_24 [label="literal"]

raw_25 [label="raw"]


raw_23 -> leaf_26
leaf_26  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  The Node metatable is the root table for any Node.  I'm planning to make
an intermediate class/table called Root that is in common for any instance
Node.  All Root absolutely has to contain is "]
literal_24 -> leaf_27
leaf_27  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str"]
raw_25 -> leaf_28
leaf_28  [color=Gray,shape=rectangle,fontname=Inconsolata,label=". 
"]
codeblock_21 -> leaf_29
leaf_29  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
local Node = {}
Node.__index = Node
Node.isNode = true"]
section_6 -> { header_30 prose_31 prose_32 codeblock_33 prose_34}
{rank=same; header_30 prose_31 prose_32 codeblock_33 prose_34}

header_30 [label="2 : Fields"]

prose_31 [label="prose"]

prose_32 [label="prose"]

codeblock_33 [label="code block 38-41"]

prose_34 [label="prose"]


header_30 -> leaf_35
leaf_35  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Fields"]
prose_31 -> { raw_36}
{rank=same; raw_36}

raw_36 [label="raw"]


raw_36 -> leaf_37
leaf_37  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

   - id :  A string naming the Node. 
           This is identical to the name of the pattern that recognizes
           or captures it.
"]
prose_32 -> { raw_38}
{rank=same; raw_38}

raw_38 [label="raw"]


raw_38 -> leaf_39
leaf_39  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
   - line_first :  Always -1. #deprecated
   - line_last  :  Always -1. #deprecated
"]
codeblock_33 -> leaf_40
leaf_40  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Node.line_first = -1
Node.line_last  = -1"]
prose_34 -> { raw_41 link_42 raw_43}
{rank=same; raw_41 link_42 raw_43}

raw_41 [label="raw"]

link_42 [label="link"]

raw_43 [label="raw"]


raw_41 -> leaf_44
leaf_44  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
It occurs to me we could lazily calculate these using the "]
link_42 -> { anchortext_45 url_46}
{rank=same; anchortext_45 url_46}

anchortext_45 [label="anchortext"]

url_46 [label="url"]


anchortext_45 -> leaf_47
leaf_47  [color=Gray,shape=rectangle,fontname=Inconsolata,label="line iterator"]
url_46 -> leaf_48
leaf_48  [color=Gray,shape=rectangle,fontname=Inconsolata,label="httk://"]
raw_43 -> leaf_49
leaf_49  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".

"]
section_7 -> { header_50 prose_51 section_52 section_53 section_54 section_55}
{rank=same; header_50 prose_51 section_52 section_53 section_54 section_55}

header_50 [label="2 : Methods"]

prose_51 [label="prose"]

section_52 [label="section: 48-56"]

section_53 [label="section: 57-229"]

section_54 [label="section: 254-271"]

section_55 [label="section: 272-274"]


header_50 -> leaf_56
leaf_56  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Methods"]
prose_51 -> { raw_57}
{rank=same; raw_57}

raw_57 [label="raw"]


raw_57 -> leaf_58
leaf_58  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
section_52 -> { header_59 prose_60 codeblock_61}
{rank=same; header_59 prose_60 codeblock_61}

header_59 [label="3 : Scaffolding "]

prose_60 [label="prose"]

codeblock_61 [label="code block 50-54"]


header_59 -> leaf_62
leaf_62  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Scaffolding "]
prose_60 -> { raw_63}
{rank=same; raw_63}

raw_63 [label="raw"]


raw_63 -> leaf_64
leaf_64  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_61 -> leaf_65
leaf_65  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.toLua(node)
  s:halt(\"No toLua method for \" .. node.id)
end"]
section_53 -> { header_66 prose_67 prose_68 codeblock_69 codeblock_70 codeblock_71 codeblock_72 section_73 section_74 section_75 section_76 section_77}
{rank=same; header_66 prose_67 prose_68 codeblock_69 codeblock_70 codeblock_71 codeblock_72 section_73 section_74 section_75 section_76 section_77}

header_66 [label="3 : Visualizers"]

prose_67 [label="prose"]

prose_68 [label="prose"]

codeblock_69 [label="code block 64-83"]

codeblock_70 [label="code block 85-89"]

codeblock_71 [label="code block 91-95"]

codeblock_72 [label="code block 97-125"]

section_73 [label="section: 127-147"]

section_74 [label="section: 148-170"]

section_75 [label="section: 171-210"]

section_76 [label="section: 211-229"]

section_77 [label="section: 230-253"]


header_66 -> leaf_78
leaf_78  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Visualizers"]
prose_67 -> { raw_79}
{rank=same; raw_79}

raw_79 [label="raw"]


raw_79 -> leaf_80
leaf_80  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This gives us a nice, tree-shaped printout of an entire Node.
"]
prose_68 -> { raw_81}
{rank=same; raw_81}

raw_81 [label="raw"]


raw_81 -> leaf_82
leaf_82  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
We're less disciplined than we should be about up-assigning this to
inherited Node classes. 
"]
codeblock_69 -> leaf_83
leaf_83  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.toString(node, depth)
   local depth = depth or 0
   local phrase = \"\"
   phrase = (\"  \"):rep(depth) .. \"id: \" .. node.id .. \",  \"
      .. \"first: \" .. node.first .. \", last: \" .. node.last
   if node[1] then
      phrase = phrase .. \"\\n\"
      for _,v in ipairs(node) do
         if (v.isNode) then
            phrase = phrase .. Node.toString(v, depth + 1)
         end
      end
   else
      phrase = phrase .. \",  val: \" 
             .. ansi.green(node.str:sub(node.first, node.last)) .. \"\\n\"
   end
   return phrase
end"]
codeblock_70 -> leaf_84
leaf_84  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.span(node)
   return string.sub(node.str, node.first, node.last)
end"]
codeblock_71 -> leaf_85
leaf_85  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.len(node)
    return #Node.span(node)
end"]
codeblock_72 -> leaf_86
leaf_86  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.dotLabel(node)
  return node.id
end

function Node.toMarkdown(node)
  if not node[1] then
    return string.sub(node.str, node.first, node.last)
  else
    s:halt(\"no toMarkdown for \" .. node.id)
  end
end

function Node.dot(node)
  return dot.dot(node)
end

function Node.toValue(node)
  if node.__VALUE then
    return node.__VALUE
  end
  if node.str then
    return node.str:sub(node.first,node.last)
  else
    s:halt(\"no str on node \" .. node.id)
  end
end
"]
section_73 -> { header_87 prose_88 codeblock_89}
{rank=same; header_87 prose_88 codeblock_89}

header_87 [label="4 : Node.walkPost"]

prose_88 [label="prose"]

codeblock_89 [label="code block 131-146"]


header_87 -> leaf_90
leaf_90  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.walkPost"]
prose_88 -> { raw_91}
{rank=same; raw_91}

raw_91 [label="raw"]


raw_91 -> leaf_92
leaf_92  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Depth-first iterator, postfix 
"]
codeblock_89 -> leaf_93
leaf_93  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.walkPost(node)
    local function traverse(ast)
        if not ast.isNode then return nil end

        for _, v in ipairs(ast) do
            if type(v) == 'table' and v.isNode then
              traverse(v)
            end
        end
        coroutine.yield(ast)
    end

    return coroutine.wrap(function() traverse(node) end)
end"]
section_74 -> { header_94 prose_95 codeblock_96}
{rank=same; header_94 prose_95 codeblock_96}

header_94 [label="4 : Node.walk"]

prose_95 [label="prose"]

codeblock_96 [label="code block 152-168"]


header_94 -> leaf_97
leaf_97  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.walk"]
prose_95 -> { raw_98}
{rank=same; raw_98}

raw_98 [label="raw"]


raw_98 -> leaf_99
leaf_99  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Presearch iterator.  This is the default. 
"]
codeblock_96 -> leaf_100
leaf_100  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.walk(node)
  local function traverse(ast)
    if not ast.isNode then return nil end

    coroutine.yield(ast)
    for _, v in ipairs(ast) do
      if type(v) == 'table' and v.isNode then
        traverse(v)
      end
    end
  end

  return coroutine.wrap(function() traverse(node) end)
end
"]
section_75 -> { header_101 prose_102 codeblock_103}
{rank=same; header_101 prose_102 codeblock_103}

header_101 [label="4 : Node.select(node, pred)"]

prose_102 [label="prose"]

codeblock_103 [label="code block 177-208"]


header_101 -> leaf_104
leaf_104  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.select(node, pred)"]
prose_102 -> { raw_105 literal_106 raw_107 literal_108 raw_109}
{rank=same; raw_105 literal_106 raw_107 literal_108 raw_109}

raw_105 [label="raw"]

literal_106 [label="literal"]

raw_107 [label="raw"]

literal_108 [label="literal"]

raw_109 [label="raw"]


raw_105 -> leaf_110
leaf_110  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Takes the Node and walks it, yielding the Nodes which match the predicate."]
literal_106 -> leaf_111
leaf_111  [color=Gray,shape=rectangle,fontname=Inconsolata,label="pred"]
raw_107 -> leaf_112
leaf_112  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is either a string, which matches to "]
literal_108 -> leaf_113
leaf_113  [color=Gray,shape=rectangle,fontname=Inconsolata,label="id"]
raw_109 -> leaf_114
leaf_114  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", or a function, which takes
a Node and returns true or false on some premise. 
"]
codeblock_103 -> leaf_115
leaf_115  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.select(node, pred)
   local function qualifies(node, pred)
      if type(pred) == 'string' then
         if type(node) == 'table' 
          and node.id and node.id == pred then
            return true
         else
            return false
         end
      elseif type(pred) == 'function' then
         return pred(node)
      else
         s:halt(\"cannot select on predicate of type \" .. type(pred))
      end
   end

   local function traverse(ast)
      -- breadth first
      if qualifies(ast, pred) then
         coroutine.yield(ast)
      end
      if ast.isNode then
         for _, v in ipairs(ast) do
            traverse(v)
         end
      end
   end

   return coroutine.wrap(function() traverse(node) end)
end"]
section_76 -> { header_116 prose_117 codeblock_118}
{rank=same; header_116 prose_117 codeblock_118}

header_116 [label="4 : Node.tokens(node)"]

prose_117 [label="prose"]

codeblock_118 [label="code block 215-227"]


header_116 -> leaf_119
leaf_119  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.tokens(node)"]
prose_117 -> { raw_120}
{rank=same; raw_120}

raw_120 [label="raw"]


raw_120 -> leaf_121
leaf_121  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Iterator returning all captured values as strings.
"]
codeblock_118 -> leaf_122
leaf_122  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.tokens(node)
  local function traverse(ast)
    for node in Node.walk(ast) do
      if not node[1] then
        coroutine.yield(node:toValue())
      end
    end
  end

  return coroutine.wrap(function() traverse(node) end)
end  "]
section_77 -> { header_123 prose_124 prose_125 prose_126 codeblock_127}
{rank=same; header_123 prose_124 prose_125 prose_126 codeblock_127}

header_123 [label="4 : Node.unroll(node)"]

prose_124 [label="prose"]

prose_125 [label="prose"]

prose_126 [label="prose"]

codeblock_127 [label="code block 244-251"]


header_123 -> leaf_128
leaf_128  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.unroll(node)"]
prose_124 -> { raw_129 literal_130 raw_131 literal_132 raw_133}
{rank=same; raw_129 literal_130 raw_131 literal_132 raw_133}

raw_129 [label="raw"]

literal_130 [label="literal"]

raw_131 [label="raw"]

literal_132 [label="literal"]

raw_133 [label="raw"]


raw_129 -> leaf_134
leaf_134  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  This iterator returns all Nodes, in prefix order, while interpolating
strings.  Specifically: When a Node has a "]
literal_130 -> leaf_135
leaf_135  [color=Gray,shape=rectangle,fontname=Inconsolata,label="first"]
raw_131 -> leaf_136
leaf_136  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" that is less than the"]
literal_132 -> leaf_137
leaf_137  [color=Gray,shape=rectangle,fontname=Inconsolata,label="first"]
raw_133 -> leaf_138
leaf_138  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" if its first child, it makes a slice of the string corresponding to
that gap, and so on between each child, and once more at the end.
"]
prose_125 -> { raw_139}
{rank=same; raw_139}

raw_139 [label="raw"]


raw_139 -> leaf_140
leaf_140  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The effect is that any sections of the string which were dropped are now
interpolated into the unrolled Node.
"]
prose_126 -> { raw_141 literal_142 raw_143 literal_144 raw_145 literal_146 raw_147}
{rank=same; raw_141 literal_142 raw_143 literal_144 raw_145 literal_146 raw_147}

raw_141 [label="raw"]

literal_142 [label="literal"]

raw_143 [label="raw"]

literal_144 [label="literal"]

raw_145 [label="raw"]

literal_146 [label="literal"]

raw_147 [label="raw"]


raw_141 -> leaf_148
leaf_148  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The premise is that by calling "]
literal_142 -> leaf_149
leaf_149  [color=Gray,shape=rectangle,fontname=Inconsolata,label="toValue()"]
raw_143 -> leaf_150
leaf_150  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" or "]
literal_144 -> leaf_151
leaf_151  [color=Gray,shape=rectangle,fontname=Inconsolata,label="span()"]
raw_145 -> leaf_152
leaf_152  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" on leaf nodes, and
grafting these to the interpolated strings in order, you will produce the
original "]
literal_146 -> leaf_153
leaf_153  [color=Gray,shape=rectangle,fontname=Inconsolata,label="node.str"]
raw_147 -> leaf_154
leaf_154  [color=Gray,shape=rectangle,fontname=Inconsolata,label=". 
"]
codeblock_127 -> leaf_155
leaf_155  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.unroll(node)
  local function traverse(ast)
  end

  return coroutine.wrap(function() traverse(node) end)
end"]
section_54 -> { header_156 prose_157 prose_158 codeblock_159}
{rank=same; header_156 prose_157 prose_158 codeblock_159}

header_156 [label="3 : Collectors"]

prose_157 [label="prose"]

prose_158 [label="prose"]

codeblock_159 [label="code block 261-270"]


header_156 -> leaf_160
leaf_160  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Collectors"]
prose_157 -> { raw_161}
{rank=same; raw_161}

raw_161 [label="raw"]


raw_161 -> leaf_162
leaf_162  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

These return an array of all results. 
"]
prose_158 -> { raw_163}
{rank=same; raw_163}

raw_163 [label="raw"]


raw_163 -> leaf_164
leaf_164  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- [ ] #todo  Add a Forest class to provide the iterator interface for
             the return arrays of this class.
"]
codeblock_159 -> leaf_165
leaf_165  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.gather(node, pred)
  local gathered = {}
  for ast in node:select(pred) do
    gathered[#gathered + 1] = ast
  end
  
  return gathered
end"]
section_55 -> { header_166 prose_167 section_168}
{rank=same; header_166 prose_167 section_168}

header_166 [label="3 : Subclassing and construction"]

prose_167 [label="prose"]

section_168 [label="section: 275-292"]


header_166 -> leaf_169
leaf_169  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Subclassing and construction"]
prose_167 -> { raw_170}
{rank=same; raw_170}

raw_170 [label="raw"]


raw_170 -> leaf_171
leaf_171  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

"]
section_168 -> { header_172 prose_173 codeblock_174}
{rank=same; header_172 prose_173 codeblock_174}

header_172 [label="4 : N.inherit(node)"]

prose_173 [label="prose"]

codeblock_174 [label="code block 277-291"]


header_172 -> leaf_175
leaf_175  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** N.inherit(node)"]
prose_173 -> { raw_176}
{rank=same; raw_176}

raw_176 [label="raw"]


raw_176 -> leaf_177
leaf_177  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_174 -> leaf_178
leaf_178  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.inherit(node)
  Meta = setmetatable({}, node)
  Meta.__index = Meta
  local meta = setmetatable({}, Meta)
  meta.__index = meta
  return Meta, meta
end

function Node.export(_, mod, constructor)
  mod.__call = constructor
  return setmetatable({}, mod)
end
"]
section_8 -> { header_179 prose_180 prose_181 prose_182 prose_183 prose_184 section_185 section_186}
{rank=same; header_179 prose_180 prose_181 prose_182 prose_183 prose_184 section_185 section_186}

header_179 [label="2 : Node Instances"]

prose_180 [label="prose"]

prose_181 [label="prose"]

prose_182 [label="prose"]

prose_183 [label="prose"]

prose_184 [label="prose"]

section_185 [label="section: 317-339"]

section_186 [label="section: 353-387"]


header_179 -> leaf_187
leaf_187  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Node Instances"]
prose_180 -> { raw_188}
{rank=same; raw_188}

raw_188 [label="raw"]


raw_188 -> leaf_189
leaf_189  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  To be a Node, currently, indexed elements of the Array portion must also be 
Nodes. 
"]
prose_181 -> { raw_190}
{rank=same; raw_190}

raw_190 [label="raw"]


raw_190 -> leaf_191
leaf_191  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I'm mostly convinced that indexed elements can also be strings, and that 
this is the form leaf nodes should take.  Currently, they have a 'val' field
and no children, which we should replace with a child string at [1].
"]
prose_182 -> { raw_192 literal_193 raw_194 literal_195 raw_196}
{rank=same; raw_192 literal_193 raw_194 literal_195 raw_196}

raw_192 [label="raw"]

literal_193 [label="literal"]

raw_194 [label="raw"]

literal_195 [label="literal"]

raw_196 [label="raw"]


raw_192 -> leaf_197
leaf_197  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This gives us a lighter way to handle the circumstance where we have, say,
a list, "]
literal_193 -> leaf_198
leaf_198  [color=Gray,shape=rectangle,fontname=Inconsolata,label="(foo bar baz)"]
raw_194 -> leaf_199
leaf_199  [color=Gray,shape=rectangle,fontname=Inconsolata,label=". We currently either need a \"left-per\" or \"pal\"
Node class to hold the "]
literal_195 -> leaf_200
leaf_200  [color=Gray,shape=rectangle,fontname=Inconsolata,label="("]
raw_196 -> leaf_201
leaf_201  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", or we would have to skip it entirely.
"]
prose_183 -> { raw_202 italic_203 raw_204}
{rank=same; raw_202 italic_203 raw_204}

raw_202 [label="raw"]

italic_203 [label="italic"]

raw_204 [label="raw"]


raw_202 -> leaf_205
leaf_205  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Quipu can't lose any information from the string, so they have to include
whitespace.  We're not limited in the same way and can reconstruct less 
semantically crucial parts of a document using the span and the original 
string, since we're not "]
italic_203 -> leaf_206
leaf_206  [color=Gray,shape=rectangle,fontname=Inconsolata,label="currently"]
raw_204 -> leaf_207
leaf_207  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" editing our strings once they're
entered in.
"]
prose_184 -> { raw_208}
{rank=same; raw_208}

raw_208 [label="raw"]


raw_208 -> leaf_209
leaf_209  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Nodes are meant to be broadly compatible with everything we intend to
do with abstract syntax trees.  The more I think about this the better
it strikes me as an approach. 

"]
section_185 -> { header_210 prose_211 prose_212 prose_213 prose_214 prose_215 section_216}
{rank=same; header_210 prose_211 prose_212 prose_213 prose_214 prose_215 section_216}

header_210 [label="3 : Fields"]

prose_211 [label="prose"]

prose_212 [label="prose"]

prose_213 [label="prose"]

prose_214 [label="prose"]

prose_215 [label="prose"]

section_216 [label="section: 340-352"]


header_210 -> leaf_217
leaf_217  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Fields"]
prose_211 -> { raw_218 literal_219 raw_220 literal_221 raw_222}
{rank=same; raw_218 literal_219 raw_220 literal_221 raw_222}

raw_218 [label="raw"]

literal_219 [label="literal"]

raw_220 [label="raw"]

literal_221 [label="literal"]

raw_222 [label="raw"]


raw_218 -> leaf_223
leaf_223  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  There are invariant fields a Node is also expected to have, they are:
 
  - first :  Index into "]
literal_219 -> leaf_224
leaf_224  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str"]
raw_220 -> leaf_225
leaf_225  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" which begins the span.
  - last  :  Index into "]
literal_221 -> leaf_226
leaf_226  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str"]
raw_222 -> leaf_227
leaf_227  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" which ends the span.
"]
prose_212 -> { raw_228 literal_229 raw_230}
{rank=same; raw_228 literal_229 raw_230}

raw_228 [label="raw"]

literal_229 [label="literal"]

raw_230 [label="raw"]


raw_228 -> leaf_231
leaf_231  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
In principle, we want the Node to be localized. We could include a 
reference to the whole "]
literal_229 -> leaf_232
leaf_232  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str"]
raw_230 -> leaf_233
leaf_233  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" and derive substrings lazily.
"]
prose_213 -> { raw_234}
{rank=same; raw_234}

raw_234 [label="raw"]


raw_234 -> leaf_235
leaf_235  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If we included the full span as a substring on each Node, we'd end up
with a lot of spans, and wouldn't use most of them. Even slicing a piece
out is costly if we're not going to use it. 
"]
prose_214 -> { raw_236}
{rank=same; raw_236}

raw_236 [label="raw"]


raw_236 -> leaf_237
leaf_237  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
So our constructor for a Node class takes (Constructor, node, str) as 
the standard interface.  If a module needs a non-standard constructor,
as our Section and Block modules currently take an array of lines, that
will need to be provided as the second return from the module. 
"]
prose_215 -> { raw_238}
{rank=same; raw_238}

raw_238 [label="raw"]


raw_238 -> leaf_239
leaf_239  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This will allow for the kind of multi-pass recursive-descent that I'm
aiming for. 

"]
section_216 -> { header_240 prose_241 prose_242 prose_243 prose_244}
{rank=same; header_240 prose_241 prose_242 prose_243 prose_244}

header_240 [label="4 : line tracking (optional)"]

prose_241 [label="prose"]

prose_242 [label="prose"]

prose_243 [label="prose"]

prose_244 [label="prose"]


header_240 -> leaf_245
leaf_245  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** line tracking (optional)"]
prose_241 -> { raw_246}
{rank=same; raw_246}

raw_246 [label="raw"]


raw_246 -> leaf_247
leaf_247  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

It may be wise to always track lines, in which case we will include:
"]
prose_242 -> { raw_248}
{rank=same; raw_248}

raw_248 [label="raw"]


raw_248 -> leaf_249
leaf_249  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  - line_first :  The line at which the match begins
  - line_last  :  The line at which the match ends
"]
prose_243 -> { raw_250}
{rank=same; raw_250}

raw_250 [label="raw"]


raw_250 -> leaf_251
leaf_251  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This is, at least, a frequent enough pattern that the metatable should return
a negative number if these aren't assigned. 
"]
prose_244 -> { raw_252}
{rank=same; raw_252}

raw_252 [label="raw"]


raw_252 -> leaf_253
leaf_253  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- [ ] #todo decide if line tracking is in fact optional

"]
section_186 -> { header_254 prose_255 prose_256 prose_257 prose_258 prose_259 prose_260 prose_261 prose_262 codeblock_263}
{rank=same; header_254 prose_255 prose_256 prose_257 prose_258 prose_259 prose_260 prose_261 prose_262 codeblock_263}

header_254 [label="3 : Other fields"]

prose_255 [label="prose"]

prose_256 [label="prose"]

prose_257 [label="prose"]

prose_258 [label="prose"]

prose_259 [label="prose"]

prose_260 [label="prose"]

prose_261 [label="prose"]

prose_262 [label="prose"]

codeblock_263 [label="code block 382-384"]


header_254 -> leaf_264
leaf_264  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Other fields"]
prose_255 -> { raw_265 literal_266 raw_267}
{rank=same; raw_265 literal_266 raw_267}

raw_265 [label="raw"]

literal_266 [label="literal"]

raw_267 [label="raw"]


raw_265 -> leaf_268
leaf_268  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  The way the Grammar class will work: each "]
literal_266 -> leaf_269
leaf_269  [color=Gray,shape=rectangle,fontname=Inconsolata,label="V\"patt\""]
raw_267 -> leaf_270
leaf_270  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" can have a metatable.
These are passed in as the second parameter during construction, with the key
the same name as the rule. 
"]
prose_256 -> { raw_271}
{rank=same; raw_271}

raw_271 [label="raw"]


raw_271 -> leaf_272
leaf_272  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If a pattern doesn't have a metatable, it's given a Node class and consists of
only the above fields, plus an array representing any subrules. 
"]
prose_257 -> { raw_273 literal_274 raw_275}
{rank=same; raw_273 literal_274 raw_275}

raw_273 [label="raw"]

literal_274 [label="literal"]

raw_275 [label="raw"]


raw_273 -> leaf_276
leaf_276  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If it does, the metatable will have a "]
literal_274 -> leaf_277
leaf_277  [color=Gray,shape=rectangle,fontname=Inconsolata,label="__call"]
raw_275 -> leaf_278
leaf_278  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" method, which expects two
parameters, itself, and the node, which will include the span. 
"]
prose_258 -> { raw_279 literal_280 raw_281}
{rank=same; raw_279 literal_280 raw_281}

raw_279 [label="raw"]

literal_280 [label="literal"]

raw_281 [label="raw"]


raw_279 -> leaf_282
leaf_282  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This will require reattunement of basically every class in the "]
literal_280 -> leaf_283
leaf_283  [color=Gray,shape=rectangle,fontname=Inconsolata,label="/grym"]
raw_281 -> leaf_284
leaf_284  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" folder,
but let's build the Prose parse first.  I do want the whole shebang in a single
grammar eventually.
"]
prose_259 -> { raw_285}
{rank=same; raw_285}

raw_285 [label="raw"]


raw_285 -> leaf_286
leaf_286  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The intention is to allow multiple grammars to coexist peacefully. Currently
the parser is handrolled and we have special case values for everything.
The idea is to stabilize this, so that multi-pass parsing works but in a
standard way where the Node constructor is a consistent interface. 
"]
prose_260 -> { raw_287}
{rank=same; raw_287}

raw_287 [label="raw"]


raw_287 -> leaf_288
leaf_288  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
In the meantime we have things like
"]
prose_261 -> { raw_289 literal_290 raw_291}
{rank=same; raw_289 literal_290 raw_291}

raw_289 [label="raw"]

literal_290 [label="literal"]

raw_291 [label="raw"]


raw_289 -> leaf_292
leaf_292  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- lines :  If this exists, there's a collection of lines which need to be
           joined with "]
literal_290 -> leaf_293
leaf_293  [color=Gray,shape=rectangle,fontname=Inconsolata,label="\\n"]
raw_291 -> leaf_294
leaf_294  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" to reconstruct the actual span.
"]
prose_262 -> { raw_295}
{rank=same; raw_295}

raw_295 [label="raw"]


raw_295 -> leaf_296
leaf_296  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
           We want to do this the other way, and use the span itself for the
           inner parse. 
"]
codeblock_263 -> leaf_297
leaf_297  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return Node"]

}
