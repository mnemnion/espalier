digraph lpegNode {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 501"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-471"]


// END RANK doc_0

section_1 -> { header_2 prose_3 section_4 section_5 section_6 section_7 section_8}
{rank=same; header_2 prose_3 section_4 section_5 section_6 section_7 section_8}

header_2 [label="1 : Node"]

prose_3 [label="prose"]

section_4 [label="section: 8-16"]

section_5 [label="section: 17-28"]

section_6 [label="section: 29-40"]

section_7 [label="section: 41-449"]

section_8 [label="section: 472-491"]


// END RANK section_1

header_2 -> leaf_9
leaf_9  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Node"]
// END RANK header_2

prose_3 -> { raw_10}
{rank=same; raw_10}

raw_10 [label="raw"]


// END RANK prose_3

raw_10 -> leaf_11
leaf_11  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


  The Node class implements an abstract syntax tree, in collaboration with
the [[Grammar class][/grammar] and lpeg more generally.

"]
// END RANK raw_10

section_4 -> { header_12 prose_13 codeblock_14}
{rank=same; header_12 prose_13 codeblock_14}

header_12 [label="3 : includes"]

prose_13 [label="prose"]

codeblock_14 [label="code block 10-14"]


// END RANK section_4

header_12 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** includes"]
// END RANK header_12

prose_13 -> { raw_16}
{rank=same; raw_16}

raw_16 [label="raw"]


// END RANK prose_13

raw_16 -> leaf_17
leaf_17  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_16

codeblock_14 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local s = require \"status\" ()
local a = require \"ansi\"
local dot = require \"node/dot\""]
// END RANK codeblock_14

section_5 -> { header_19 prose_20 codeblock_21}
{rank=same; header_19 prose_20 codeblock_21}

header_19 [label="2 : Node metatable"]

prose_20 [label="prose"]

codeblock_21 [label="code block 22-26"]


// END RANK section_5

header_19 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Node metatable"]
// END RANK header_19

prose_20 -> { raw_23}
{rank=same; raw_23}

raw_23 [label="raw"]


// END RANK prose_20

raw_23 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  The Node metatable is the root table for any Node, all of which should
subclass through [[Node:inherit()][httk://]].
"]
// END RANK raw_23

codeblock_21 -> leaf_25
leaf_25  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local Node = {}
Node.__index = Node
Node.isNode = Node"]
// END RANK codeblock_21

section_6 -> { header_26 prose_27 prose_28 prose_29}
{rank=same; header_26 prose_27 prose_28 prose_29}

header_26 [label="2 : Fields"]

prose_27 [label="prose"]

prose_28 [label="prose"]

prose_29 [label="prose"]


// END RANK section_6

header_26 -> leaf_30
leaf_30  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Fields"]
// END RANK header_26

prose_27 -> { raw_31}
{rank=same; raw_31}

raw_31 [label="raw"]


// END RANK prose_27

raw_31 -> leaf_32
leaf_32  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

   - id :  A string naming the Node.
           This is identical to the name of the pattern that recognizes
           or captures it.
"]
// END RANK raw_31

prose_28 -> { raw_33}
{rank=same; raw_33}

raw_33 [label="raw"]


// END RANK prose_28

raw_33 -> leaf_34
leaf_34  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
           This is never set on Node itself, and Grammar will fail to
           produce a Node which lacks this flag.
"]
// END RANK raw_33

prose_29 -> { raw_35 prespace_36 literal_37 raw_38}
{rank=same; raw_35 prespace_36 literal_37 raw_38}

raw_35 [label="raw"]

prespace_36 [label="prespace"]

literal_37 [label="literal"]

raw_38 [label="raw"]


// END RANK prose_29

raw_35 -> leaf_39
leaf_39  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
   - isNode :  A boolean, always"]
// END RANK raw_35

prespace_36 -> leaf_40
leaf_40  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_36

literal_37 -> leaf_41
leaf_41  [color=Gray,shape=rectangle,fontname=Inconsolata,label="true"]
// END RANK literal_37

raw_38 -> leaf_42
leaf_42  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".

"]
// END RANK raw_38

section_7 -> { header_43 prose_44 section_45 section_46 section_47 section_48 section_49 section_50}
{rank=same; header_43 prose_44 section_45 section_46 section_47 section_48 section_49 section_50}

header_43 [label="2 : Methods"]

prose_44 [label="prose"]

section_45 [label="section: 44-57"]

section_46 [label="section: 58-97"]

section_47 [label="section: 98-382"]

section_48 [label="section: 400-419"]

section_49 [label="section: 420-449"]

section_50 [label="section: 450-452"]


// END RANK section_7

header_43 -> leaf_51
leaf_51  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Methods"]
// END RANK header_43

prose_44 -> { raw_52}
{rank=same; raw_52}

raw_52 [label="raw"]


// END RANK prose_44

raw_52 -> leaf_53
leaf_53  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

"]
// END RANK raw_52

section_45 -> { header_54 prose_55 prose_56 codeblock_57}
{rank=same; header_54 prose_55 prose_56 codeblock_57}

header_54 [label="4 : toLua"]

prose_55 [label="prose"]

prose_56 [label="prose"]

codeblock_57 [label="code block 51-55"]


// END RANK section_45

header_54 -> leaf_58
leaf_58  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** toLua"]
// END RANK header_54

prose_55 -> { raw_59}
{rank=same; raw_59}

raw_59 [label="raw"]


// END RANK prose_55

raw_59 -> leaf_60
leaf_60  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This is not a general method in any sense, it's here as a backstop
while I build out Clu.
"]
// END RANK raw_59

prose_56 -> { raw_61}
{rank=same; raw_61}

raw_61 [label="raw"]


// END RANK prose_56

raw_61 -> leaf_62
leaf_62  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  - [ ] #todo remove
"]
// END RANK raw_61

codeblock_57 -> leaf_63
leaf_63  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.toLua(node)
  s:halt(\"No toLua method for \" .. node.id)
end"]
// END RANK codeblock_57

section_46 -> { header_64 prose_65 prose_66 codeblock_67}
{rank=same; header_64 prose_65 prose_66 codeblock_67}

header_64 [label="3 : Visualizer"]

prose_65 [label="prose"]

prose_66 [label="prose"]

codeblock_67 [label="code block 65-96"]


// END RANK section_46

header_64 -> leaf_68
leaf_68  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Visualizer"]
// END RANK header_64

prose_65 -> { raw_69}
{rank=same; raw_69}

raw_69 [label="raw"]


// END RANK prose_65

raw_69 -> leaf_70
leaf_70  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This gives us a nice, tree-shaped printout of an entire Node.
"]
// END RANK raw_69

prose_66 -> { raw_71}
{rank=same; raw_71}

raw_71 [label="raw"]


// END RANK prose_66

raw_71 -> leaf_72
leaf_72  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
We're less disciplined than we should be about up-assigning this to
inherited Node classes.
"]
// END RANK raw_71

codeblock_67 -> leaf_73
leaf_73  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.toString(node, depth)
   local depth = depth or 0
   local phrase = \"\"
   phrase = (\"  \"):rep(depth) .. a.bright(node.id) .. \"    \"
      .. a.cyan(node.first) .. \"-\" .. a.cyan(node.last)
   if node[1] then
      local extra = \"    \"
      if Node.len(node) > 56 then
         --  Truncate in the middle
         local span = Node.span(node)
         local pre, post = string.sub(span, 1, 26), string.sub(span, -26, -1)
         extra = extra .. a.dim(pre) .. a.bright(\"………\") .. a.dim(post)
         extra = extra:gsub(\"\\n\", \"◼︎\")
      else
         extra = extra .. a.dim(Node.span(node):gsub(\"\\n\", \"◼︎\"))
      end
      phrase = phrase .. extra .. \"\\n\"
      for _,v in ipairs(node) do
         if (v.isNode) then
            phrase = phrase .. Node.toString(v, depth + 1)
         end
      end
   else
      local val = node.str:sub(node.first, node.last)
                          :gsub(\" \", a.clear() .. a.dim(\"_\") .. a.green())
      val = a.green(val)
      phrase = phrase .. \"    \" .. val  .. \"\\n\"
   end
   return phrase
end"]
// END RANK codeblock_67

section_47 -> { header_74 prose_75 section_76 section_77 section_78 section_79 section_80 section_81 section_82 section_83 section_84 section_85}
{rank=same; header_74 prose_75 section_76 section_77 section_78 section_79 section_80 section_81 section_82 section_83 section_84 section_85}

header_74 [label="3 : Metrics"]

prose_75 [label="prose"]

section_76 [label="section: 101-109"]

section_77 [label="section: 110-120"]

section_78 [label="section: 121-196"]

section_79 [label="section: 197-217"]

section_80 [label="section: 218-240"]

section_81 [label="section: 241-280"]

section_82 [label="section: 281-299"]

section_83 [label="section: 300-348"]

section_84 [label="section: 349-382"]

section_85 [label="section: 383-399"]


// END RANK section_47

header_74 -> leaf_86
leaf_86  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Metrics"]
// END RANK header_74

prose_75 -> { raw_87}
{rank=same; raw_87}

raw_87 [label="raw"]


// END RANK prose_75

raw_87 -> leaf_88
leaf_88  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

"]
// END RANK raw_87

section_76 -> { header_89 prose_90 codeblock_91}
{rank=same; header_89 prose_90 codeblock_91}

header_89 [label="4 : span"]

prose_90 [label="prose"]

codeblock_91 [label="code block 103-107"]


// END RANK section_76

header_89 -> leaf_92
leaf_92  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** span"]
// END RANK header_89

prose_90 -> { raw_93}
{rank=same; raw_93}

raw_93 [label="raw"]


// END RANK prose_90

raw_93 -> leaf_94
leaf_94  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_93

codeblock_91 -> leaf_95
leaf_95  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.span(node)
   return string.sub(node.str, node.first, node.last)
end"]
// END RANK codeblock_91

section_77 -> { header_96 prose_97 codeblock_98}
{rank=same; header_96 prose_97 codeblock_98}

header_96 [label="4 : len"]

prose_97 [label="prose"]

codeblock_98 [label="code block 114-118"]


// END RANK section_77

header_96 -> leaf_99
leaf_99  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** len"]
// END RANK header_96

prose_97 -> { raw_100}
{rank=same; raw_100}

raw_100 [label="raw"]


// END RANK prose_97

raw_100 -> leaf_101
leaf_101  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

ahh, the pleasure of indexing by one.
"]
// END RANK raw_100

codeblock_98 -> leaf_102
leaf_102  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.len(node)
    return 1 + node.last - node.first
end"]
// END RANK codeblock_98

section_78 -> { header_103 prose_104 prose_105 prose_106 prose_107 prose_108 prose_109 prose_110 codeblock_111 codeblock_112}
{rank=same; header_103 prose_104 prose_105 prose_106 prose_107 prose_108 prose_109 prose_110 codeblock_111 codeblock_112}

header_103 [label="4 : Node:gap(node)"]

prose_104 [label="prose"]

prose_105 [label="prose"]

prose_106 [label="prose"]

prose_107 [label="prose"]

prose_108 [label="prose"]

prose_109 [label="prose"]

prose_110 [label="prose"]

codeblock_111 [label="code block 144-164"]

codeblock_112 [label="code block 167-195"]


// END RANK section_78

header_103 -> leaf_113
leaf_113  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node:gap(node)"]
// END RANK header_103

prose_104 -> { raw_114}
{rank=same; raw_114}

raw_114 [label="raw"]


// END RANK prose_104

raw_114 -> leaf_115
leaf_115  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

NOTE this is unused and hence untested
"]
// END RANK raw_114

prose_105 -> { raw_116}
{rank=same; raw_116}

raw_116 [label="raw"]


// END RANK prose_105

raw_116 -> leaf_117
leaf_117  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- [ ] #todo either use this, validate it, or get rid of it
"]
// END RANK raw_116

prose_106 -> { prespace_118 literal_119 raw_120 prespace_121 literal_122 raw_123 prespace_124 literal_125 raw_126 prespace_127 literal_128 raw_129 prespace_130 literal_131 raw_132 prespace_133 bold_134 raw_135}
{rank=same; prespace_118 literal_119 raw_120 prespace_121 literal_122 raw_123 prespace_124 literal_125 raw_126 prespace_127 literal_128 raw_129 prespace_130 literal_131 raw_132 prespace_133 bold_134 raw_135}

prespace_118 [label="prespace"]

literal_119 [label="literal"]

raw_120 [label="raw"]

prespace_121 [label="prespace"]

literal_122 [label="literal"]

raw_123 [label="raw"]

prespace_124 [label="prespace"]

literal_125 [label="literal"]

raw_126 [label="raw"]

prespace_127 [label="prespace"]

literal_128 [label="literal"]

raw_129 [label="raw"]

prespace_130 [label="prespace"]

literal_131 [label="literal"]

raw_132 [label="raw"]

prespace_133 [label="prespace"]

bold_134 [label="bold"]

raw_135 [label="raw"]


// END RANK prose_106

prespace_118 -> leaf_136
leaf_136  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
// END RANK prespace_118

literal_119 -> leaf_137
leaf_137  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Node.gap(left, right)"]
// END RANK literal_119

raw_120 -> leaf_138
leaf_138  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" compares the"]
// END RANK raw_120

prespace_121 -> leaf_139
leaf_139  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_121

literal_122 -> leaf_140
leaf_140  [color=Gray,shape=rectangle,fontname=Inconsolata,label="last"]
// END RANK literal_122

raw_123 -> leaf_141
leaf_141  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" field of the"]
// END RANK raw_123

prespace_124 -> leaf_142
leaf_142  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_124

literal_125 -> leaf_143
leaf_143  [color=Gray,shape=rectangle,fontname=Inconsolata,label="left"]
// END RANK literal_125

raw_126 -> leaf_144
leaf_144  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" parameter
with the"]
// END RANK raw_126

prespace_127 -> leaf_145
leaf_145  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_127

literal_128 -> leaf_146
leaf_146  [color=Gray,shape=rectangle,fontname=Inconsolata,label="first"]
// END RANK literal_128

raw_129 -> leaf_147
leaf_147  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" field of the"]
// END RANK raw_129

prespace_130 -> leaf_148
leaf_148  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_130

literal_131 -> leaf_149
leaf_149  [color=Gray,shape=rectangle,fontname=Inconsolata,label="right"]
// END RANK literal_131

raw_132 -> leaf_150
leaf_150  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" parameter,"]
// END RANK raw_132

prespace_133 -> leaf_151
leaf_151  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_133

bold_134 -> leaf_152
leaf_152  [color=Gray,shape=rectangle,fontname=Inconsolata,label="if"]
// END RANK bold_134

raw_135 -> leaf_153
leaf_153  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" this is greater than
0.
"]
// END RANK raw_135

prose_107 -> { raw_154 prespace_155 literal_156 raw_157 prespace_158 literal_159 raw_160 prespace_161 literal_162 raw_163 prespace_164 literal_165 raw_166 prespace_167 literal_168 raw_169}
{rank=same; raw_154 prespace_155 literal_156 raw_157 prespace_158 literal_159 raw_160 prespace_161 literal_162 raw_163 prespace_164 literal_165 raw_166 prespace_167 literal_168 raw_169}

raw_154 [label="raw"]

prespace_155 [label="prespace"]

literal_156 [label="literal"]

raw_157 [label="raw"]

prespace_158 [label="prespace"]

literal_159 [label="literal"]

raw_160 [label="raw"]

prespace_161 [label="prespace"]

literal_162 [label="literal"]

raw_163 [label="raw"]

prespace_164 [label="prespace"]

literal_165 [label="literal"]

raw_166 [label="raw"]

prespace_167 [label="prespace"]

literal_168 [label="literal"]

raw_169 [label="raw"]


// END RANK prose_107

raw_154 -> leaf_170
leaf_170  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If it is negative,"]
// END RANK raw_154

prespace_155 -> leaf_171
leaf_171  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_155

literal_156 -> leaf_172
leaf_172  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Node.gap"]
// END RANK literal_156

raw_157 -> leaf_173
leaf_173  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" attempts to measure the"]
// END RANK raw_157

prespace_158 -> leaf_174
leaf_174  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_158

literal_159 -> leaf_175
leaf_175  [color=Gray,shape=rectangle,fontname=Inconsolata,label="first"]
// END RANK literal_159

raw_160 -> leaf_176
leaf_176  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" field of the"]
// END RANK raw_160

prespace_161 -> leaf_177
leaf_177  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
// END RANK prespace_161

literal_162 -> leaf_178
leaf_178  [color=Gray,shape=rectangle,fontname=Inconsolata,label="right"]
// END RANK literal_162

raw_163 -> leaf_179
leaf_179  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" parameter against the"]
// END RANK raw_163

prespace_164 -> leaf_180
leaf_180  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_164

literal_165 -> leaf_181
leaf_181  [color=Gray,shape=rectangle,fontname=Inconsolata,label="last"]
// END RANK literal_165

raw_166 -> leaf_182
leaf_182  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" field of the"]
// END RANK raw_166

prespace_167 -> leaf_183
leaf_183  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_167

literal_168 -> leaf_184
leaf_184  [color=Gray,shape=rectangle,fontname=Inconsolata,label="left"]
// END RANK literal_168

raw_169 -> leaf_185
leaf_185  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" parameter.
"]
// END RANK raw_169

prose_108 -> { raw_186 prespace_187 bold_188 raw_189}
{rank=same; raw_186 prespace_187 bold_188 raw_189}

raw_186 [label="raw"]

prespace_187 [label="prespace"]

bold_188 [label="bold"]

raw_189 [label="raw"]


// END RANK prose_108

raw_186 -> leaf_190
leaf_190  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If this is a natural number we return the"]
// END RANK raw_186

prespace_187 -> leaf_191
leaf_191  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_187

bold_188 -> leaf_192
leaf_192  [color=Gray,shape=rectangle,fontname=Inconsolata,label="negation"]
// END RANK bold_188

raw_189 -> leaf_193
leaf_193  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" of this value.  If both
should prove to be positive, we halt.
"]
// END RANK raw_189

prose_109 -> { raw_194 prespace_195 literal_196 raw_197}
{rank=same; raw_194 prespace_195 literal_196 raw_197}

raw_194 [label="raw"]

prespace_195 [label="prespace"]

literal_196 [label="literal"]

raw_197 [label="raw"]


// END RANK prose_109

raw_194 -> leaf_198
leaf_198  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
No effort is made to check that the"]
// END RANK raw_194

prespace_195 -> leaf_199
leaf_199  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_195

literal_196 -> leaf_200
leaf_200  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str"]
// END RANK literal_196

raw_197 -> leaf_201
leaf_201  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" field matches between nodes unless
we have an error, in which case it could prove helpful for diagnosis.
"]
// END RANK raw_197

prose_110 -> { raw_202}
{rank=same; raw_202}

raw_202 [label="raw"]


// END RANK prose_110

raw_202 -> leaf_203
leaf_203  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Indeed such a check would be a disaster in streams or other sort of
piecewise parse.  Which will require implementation in and of itself, but
in the meantime...
"]
// END RANK raw_202

codeblock_111 -> leaf_204
leaf_204  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.gap(left, right)
  assert(left.last, \"no left.last\")
  assert(right.first, \"no right.first\")
  assert(right.last, \"no right.last\")
  assert(left.first, \"no left.first\")
  if left.first >= right.last then
    local left, right = right, left
  elseif left.last > right.first then
    s:halt(\"overlapping regions or str issue\")
  end
  local gap = left
  if gap >= 0 then
    return gap
  else
    s:halt(\"some kind of situation where gap is \" .. tostring(gap))
  end

  return nil
end"]
// END RANK codeblock_111

codeblock_112 -> leaf_205
leaf_205  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.dotLabel(node)
  return node.id
end

function Node.toMarkdown(node)
  if not node[1] then
    return string.sub(node.str, node.first, node.last)
  else
    s:halt(\"no toMarkdown for \" .. node.id)
  end
end

function Node.dot(node)
  return dot.dot(node)
end

function Node.toValue(node)
  if node.__VALUE then
    return node.__VALUE
  end
  if node.str then
    return node.str:sub(node.first,node.last)
  else
    s:halt(\"no str on node \" .. node.id)
  end
end
"]
// END RANK codeblock_112

section_79 -> { header_206 prose_207 codeblock_208}
{rank=same; header_206 prose_207 codeblock_208}

header_206 [label="4 : Node.walkPost"]

prose_207 [label="prose"]

codeblock_208 [label="code block 201-216"]


// END RANK section_79

header_206 -> leaf_209
leaf_209  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.walkPost"]
// END RANK header_206

prose_207 -> { raw_210}
{rank=same; raw_210}

raw_210 [label="raw"]


// END RANK prose_207

raw_210 -> leaf_211
leaf_211  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Depth-first iterator, postfix
"]
// END RANK raw_210

codeblock_208 -> leaf_212
leaf_212  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.walkPost(node)
    local function traverse(ast)
        if not ast.isNode then return nil end

        for _, v in ipairs(ast) do
            if type(v) == 'table' and v.isNode then
              traverse(v)
            end
        end
        coroutine.yield(ast)
    end

    return coroutine.wrap(function() traverse(node) end)
end"]
// END RANK codeblock_208

section_80 -> { header_213 prose_214 codeblock_215}
{rank=same; header_213 prose_214 codeblock_215}

header_213 [label="4 : Node.walk"]

prose_214 [label="prose"]

codeblock_215 [label="code block 222-238"]


// END RANK section_80

header_213 -> leaf_216
leaf_216  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.walk"]
// END RANK header_213

prose_214 -> { raw_217}
{rank=same; raw_217}

raw_217 [label="raw"]


// END RANK prose_214

raw_217 -> leaf_218
leaf_218  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Presearch iterator.  This is the default.
"]
// END RANK raw_217

codeblock_215 -> leaf_219
leaf_219  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.walk(node)
  local function traverse(ast)
    if not ast.isNode then return nil end

    coroutine.yield(ast)
    for _, v in ipairs(ast) do
      if type(v) == 'table' and v.isNode then
        traverse(v)
      end
    end
  end

  return coroutine.wrap(function() traverse(node) end)
end
"]
// END RANK codeblock_215

section_81 -> { header_220 prose_221 codeblock_222}
{rank=same; header_220 prose_221 codeblock_222}

header_220 [label="4 : Node.select(node, pred)"]

prose_221 [label="prose"]

codeblock_222 [label="code block 247-278"]


// END RANK section_81

header_220 -> leaf_223
leaf_223  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.select(node, pred)"]
// END RANK header_220

prose_221 -> { raw_224 prespace_225 literal_226 raw_227 prespace_228 literal_229 raw_230}
{rank=same; raw_224 prespace_225 literal_226 raw_227 prespace_228 literal_229 raw_230}

raw_224 [label="raw"]

prespace_225 [label="prespace"]

literal_226 [label="literal"]

raw_227 [label="raw"]

prespace_228 [label="prespace"]

literal_229 [label="literal"]

raw_230 [label="raw"]


// END RANK prose_221

raw_224 -> leaf_231
leaf_231  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Takes the Node and walks it, yielding the Nodes which match the predicate."]
// END RANK raw_224

prespace_225 -> leaf_232
leaf_232  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
// END RANK prespace_225

literal_226 -> leaf_233
leaf_233  [color=Gray,shape=rectangle,fontname=Inconsolata,label="pred"]
// END RANK literal_226

raw_227 -> leaf_234
leaf_234  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is either a string, which matches to"]
// END RANK raw_227

prespace_228 -> leaf_235
leaf_235  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_228

literal_229 -> leaf_236
leaf_236  [color=Gray,shape=rectangle,fontname=Inconsolata,label="id"]
// END RANK literal_229

raw_230 -> leaf_237
leaf_237  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", or a function, which takes
a Node and returns true or false on some premise.
"]
// END RANK raw_230

codeblock_222 -> leaf_238
leaf_238  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.select(node, pred)
   local function qualifies(node, pred)
      if type(pred) == 'string' then
         if type(node) == 'table'
          and node.id and node.id == pred then
            return true
         else
            return false
         end
      elseif type(pred) == 'function' then
         return pred(node)
      else
         s:halt(\"cannot select on predicate of type \" .. type(pred))
      end
   end

   local function traverse(ast)
      -- breadth first
      if qualifies(ast, pred) then
         coroutine.yield(ast)
      end
      if ast.isNode then
         for _, v in ipairs(ast) do
            traverse(v)
         end
      end
   end

   return coroutine.wrap(function() traverse(node) end)
end"]
// END RANK codeblock_222

section_82 -> { header_239 prose_240 codeblock_241}
{rank=same; header_239 prose_240 codeblock_241}

header_239 [label="4 : Node.tokens(node)"]

prose_240 [label="prose"]

codeblock_241 [label="code block 285-297"]


// END RANK section_82

header_239 -> leaf_242
leaf_242  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.tokens(node)"]
// END RANK header_239

prose_240 -> { raw_243}
{rank=same; raw_243}

raw_243 [label="raw"]


// END RANK prose_240

raw_243 -> leaf_244
leaf_244  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Iterator returning all captured values as strings.
"]
// END RANK raw_243

codeblock_241 -> leaf_245
leaf_245  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.tokens(node)
  local function traverse(ast)
    for node in Node.walk(ast) do
      if not node[1] then
        coroutine.yield(node:toValue())
      end
    end
  end

  return coroutine.wrap(function() traverse(node) end)
end"]
// END RANK codeblock_241

section_83 -> { header_246 prose_247 prose_248 prose_249 codeblock_250}
{rank=same; header_246 prose_247 prose_248 prose_249 codeblock_250}

header_246 [label="4 : Node.lines(node)"]

prose_247 [label="prose"]

prose_248 [label="prose"]

prose_249 [label="prose"]

codeblock_250 [label="code block 310-347"]


// END RANK section_83

header_246 -> leaf_251
leaf_251  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.lines(node)"]
// END RANK header_246

prose_247 -> { raw_252 prespace_253 literal_254 raw_255}
{rank=same; raw_252 prespace_253 literal_254 raw_255}

raw_252 [label="raw"]

prespace_253 [label="prespace"]

literal_254 [label="literal"]

raw_255 [label="raw"]


// END RANK prose_247

raw_252 -> leaf_256
leaf_256  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

A memoized iterator returning"]
// END RANK raw_252

prespace_253 -> leaf_257
leaf_257  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_253

literal_254 -> leaf_258
leaf_258  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str"]
// END RANK literal_254

raw_255 -> leaf_259
leaf_259  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" one line at a time.
"]
// END RANK raw_255

prose_248 -> { raw_260}
{rank=same; raw_260}

raw_260 [label="raw"]


// END RANK prose_248

raw_260 -> leaf_261
leaf_261  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Newlines are not included.
"]
// END RANK raw_260

prose_249 -> { raw_262 prespace_263 literal_264 raw_265}
{rank=same; raw_262 prespace_263 literal_264 raw_265}

raw_262 [label="raw"]

prespace_263 [label="prespace"]

literal_264 [label="literal"]

raw_265 [label="raw"]


// END RANK prose_249

raw_262 -> leaf_266
leaf_266  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
In addition, the first"]
// END RANK raw_262

prespace_263 -> leaf_267
leaf_267  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_263

literal_264 -> leaf_268
leaf_268  [color=Gray,shape=rectangle,fontname=Inconsolata,label="node:lines() traversal builds up
a sourcemap subsequently used by "]
// END RANK literal_264

raw_265 -> leaf_269
leaf_269  [color=Gray,shape=rectangle,fontname=Inconsolata,label="node:atLine(pos)= to
return the line and column of a given position.
"]
// END RANK raw_265

codeblock_250 -> leaf_270
leaf_270  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.lines(node)
  local function yieldLines(node, linum)
     for _, str in ipairs(node.__lines) do
        coroutine.yield(str)
      end
  end

  if node.__lines then
     return coroutine.wrap(function ()
                              yieldLines(node)
                           end)
  else
     node.__lines = {}
  end

  local function buildLines(str)
      if str == nil then
        return nil
      end
      local rest = \"\"
      local first, last = string.find(str, \"\\n\")
      if first == nil then
        return nil
      else
        local line = string.sub(str, 1, first - 1) -- no newline
        rest       = string.sub(str, last + 1)    -- skip newline
        node.__lines[#node.__lines + 1] = line
        coroutine.yield(line)
      end
      buildLines(rest)
  end

  return coroutine.wrap(function ()
                           buildLines(node.str)
                        end)
end"]
// END RANK codeblock_250

section_84 -> { header_271 prose_272 prose_273 codeblock_274}
{rank=same; header_271 prose_272 prose_273 codeblock_274}

header_271 [label="4 : Node.linePos(node, position)"]

prose_272 [label="prose"]

prose_273 [label="prose"]

codeblock_274 [label="code block 356-380"]


// END RANK section_84

header_271 -> leaf_275
leaf_275  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.linePos(node, position)"]
// END RANK header_271

prose_272 -> { raw_276}
{rank=same; raw_276}

raw_276 [label="raw"]


// END RANK prose_272

raw_276 -> leaf_277
leaf_277  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Returns the line and column given a position.
"]
// END RANK raw_276

prose_273 -> { raw_278}
{rank=same; raw_278}

raw_278 [label="raw"]


// END RANK prose_273

raw_278 -> leaf_279
leaf_279  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This is implemented as a classic loop made slightly harder to get
right by Lua's indexing and the missing newline.
"]
// END RANK raw_278

codeblock_274 -> leaf_280
leaf_280  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.linePos(node, position)
   if not node.__lines then
      for _ in node:lines() do
        -- nothing, this generates the line map
      end
   end
   local offset = 0
   local position = position
   local linum = nil
   for i, v in ipairs(node.__lines) do
       linum = i
       local len = #v + 1 -- for nl
       local offset = offset + len
       if offset > position then
          return linum, position
       elseif offset == position then
          return linum, len
       else
          position = position - #v - 1
       end
   end
   return nil -- this position is off the end of the string
end"]
// END RANK codeblock_274

section_85 -> { header_281 prose_282 prose_283 codeblock_284}
{rank=same; header_281 prose_282 prose_283 codeblock_284}

header_281 [label="4 : Node.lastLeaf(node)"]

prose_282 [label="prose"]

prose_283 [label="prose"]

codeblock_284 [label="code block 389-397"]


// END RANK section_85

header_281 -> leaf_285
leaf_285  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.lastLeaf(node)"]
// END RANK header_281

prose_282 -> { raw_286}
{rank=same; raw_286}

raw_286 [label="raw"]


// END RANK prose_282

raw_286 -> leaf_287
leaf_287  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Returns the last leaf of the node.
"]
// END RANK raw_286

prose_283 -> { raw_288}
{rank=same; raw_288}

raw_288 [label="raw"]


// END RANK prose_283

raw_288 -> leaf_289
leaf_289  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Useful to check for terminal errors, for stop-on-error parsing.
"]
// END RANK raw_288

codeblock_284 -> leaf_290
leaf_290  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.lastLeaf(node)
  if #node == 0 then
    return node
  else
    return Node.lastLeaf(node[#node])
  end
end"]
// END RANK codeblock_284

section_48 -> { header_291 prose_292 prose_293 codeblock_294}
{rank=same; header_291 prose_292 prose_293 codeblock_294}

header_291 [label="3 : Collectors"]

prose_292 [label="prose"]

prose_293 [label="prose"]

codeblock_294 [label="code block 407-416"]


// END RANK section_48

header_291 -> leaf_295
leaf_295  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Collectors"]
// END RANK header_291

prose_292 -> { raw_296}
{rank=same; raw_296}

raw_296 [label="raw"]


// END RANK prose_292

raw_296 -> leaf_297
leaf_297  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

These return an array of all results.
"]
// END RANK raw_296

prose_293 -> { raw_298}
{rank=same; raw_298}

raw_298 [label="raw"]


// END RANK prose_293

raw_298 -> leaf_299
leaf_299  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- [ ] #todo  Add a Forest class to provide the iterator interface for
             the return arrays of this class.
"]
// END RANK raw_298

codeblock_294 -> leaf_300
leaf_300  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.gather(node, pred)
  local gathered = {}
  for ast in node:select(pred) do
    gathered[#gathered + 1] = ast
  end

  return gathered
end"]
// END RANK codeblock_294

section_49 -> { header_301 prose_302 codeblock_303}
{rank=same; header_301 prose_302 codeblock_303}

header_301 [label="3 : Validation"]

prose_302 [label="prose"]

codeblock_303 [label="code block 425-448"]


// END RANK section_49

header_301 -> leaf_304
leaf_304  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Validation"]
// END RANK header_301

prose_302 -> { raw_305}
{rank=same; raw_305}

raw_305 [label="raw"]


// END RANK prose_302

raw_305 -> leaf_306
leaf_306  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This checks that a Node, including all its children, meets the social
contract of Node behavior.
"]
// END RANK raw_305

codeblock_303 -> leaf_307
leaf_307  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
function Node.isValid(node)
  assert(node.isNode == Node, \"isNode flag must be Node metatable, id: \"
         .. node.id .. \" \" .. tostring(node))
  assert(node.first, \"node must have first\")
  assert(type(node.first) == \"number\", \"node.first must be of type number\")
  assert(node.last, \"node must have last\")
  assert(type(node.last) == \"number\", \"node.last must be of type number\")
  assert(node.str, \"node must have str\")
  assert(type(node.str) == \"string\" or node.str.isPhrase, \"str must be string or phrase\")
  assert(node.parent, \"node must have parent\")
  assert(type(node:span()) == \"string\", \"span() must yield string\")
  return true
end

function Node.validate(node)
  for twig in node:walk() do
    twig:isValid()
  end
  return true
end
"]
// END RANK codeblock_303

section_50 -> { header_308 prose_309 section_310}
{rank=same; header_308 prose_309 section_310}

header_308 [label="3 : Subclassing and construction"]

prose_309 [label="prose"]

section_310 [label="section: 453-471"]


// END RANK section_50

header_308 -> leaf_311
leaf_311  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Subclassing and construction"]
// END RANK header_308

prose_309 -> { raw_312}
{rank=same; raw_312}

raw_312 [label="raw"]


// END RANK prose_309

raw_312 -> leaf_313
leaf_313  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

"]
// END RANK raw_312

section_310 -> { header_314 prose_315 codeblock_316}
{rank=same; header_314 prose_315 codeblock_316}

header_314 [label="4 : N.inherit(node)"]

prose_315 [label="prose"]

codeblock_316 [label="code block 455-469"]


// END RANK section_310

header_314 -> leaf_317
leaf_317  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** N.inherit(node)"]
// END RANK header_314

prose_315 -> { raw_318}
{rank=same; raw_318}

raw_318 [label="raw"]


// END RANK prose_315

raw_318 -> leaf_319
leaf_319  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_318

codeblock_316 -> leaf_320
leaf_320  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.inherit(node)
  local Meta = setmetatable({}, node)
  Meta.__index = Meta
  local meta = setmetatable({}, Meta)
  meta.__index = meta
  return Meta, meta
end

function Node.export(_, mod, constructor)
  mod.__call = constructor
  return setmetatable({}, mod)
end
"]
// END RANK codeblock_316

section_8 -> { header_321 prose_322 prose_323 prose_324 section_325 section_326}
{rank=same; header_321 prose_322 prose_323 prose_324 section_325 section_326}

header_321 [label="2 : Node Instances"]

prose_322 [label="prose"]

prose_323 [label="prose"]

prose_324 [label="prose"]

section_325 [label="section: 483-491"]

section_326 [label="section: 492-501"]


// END RANK section_8

header_321 -> leaf_327
leaf_327  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Node Instances"]
// END RANK header_321

prose_322 -> { raw_328}
{rank=same; raw_328}

raw_328 [label="raw"]


// END RANK prose_322

raw_328 -> leaf_329
leaf_329  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  To be a Node, indexed elements of the Array portion must also be
Nodes.
"]
// END RANK raw_328

prose_323 -> { raw_330}
{rank=same; raw_330}

raw_330 [label="raw"]


// END RANK prose_323

raw_330 -> leaf_331
leaf_331  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If there are no children of the Node, it is considered to be a leaf node.
"]
// END RANK raw_330

prose_324 -> { raw_332}
{rank=same; raw_332}

raw_332 [label="raw"]


// END RANK prose_324

raw_332 -> leaf_333
leaf_333  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Most of the Node library will fail to halt, and probably blow stack, if
cyclic Node graphs are made.  The Grammar class will not do this to you.

"]
// END RANK raw_332

section_325 -> { header_334 prose_335 prose_336}
{rank=same; header_334 prose_335 prose_336}

header_334 [label="3 : Fields"]

prose_335 [label="prose"]

prose_336 [label="prose"]


// END RANK section_325

header_334 -> leaf_337
leaf_337  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Fields"]
// END RANK header_334

prose_335 -> { raw_338}
{rank=same; raw_338}

raw_338 [label="raw"]


// END RANK prose_335

raw_338 -> leaf_339
leaf_339  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  There are invariant fields a Node is also expected to have, they are:
"]
// END RANK raw_338

prose_336 -> { raw_340 prespace_341 literal_342 raw_343 prespace_344 literal_345 raw_346}
{rank=same; raw_340 prespace_341 literal_342 raw_343 prespace_344 literal_345 raw_346}

raw_340 [label="raw"]

prespace_341 [label="prespace"]

literal_342 [label="literal"]

raw_343 [label="raw"]

prespace_344 [label="prespace"]

literal_345 [label="literal"]

raw_346 [label="raw"]


// END RANK prose_336

raw_340 -> leaf_347
leaf_347  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  - first :  Index into"]
// END RANK raw_340

prespace_341 -> leaf_348
leaf_348  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_341

literal_342 -> leaf_349
leaf_349  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str"]
// END RANK literal_342

raw_343 -> leaf_350
leaf_350  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" which begins the span.
  - last  :  Index into"]
// END RANK raw_343

prespace_344 -> leaf_351
leaf_351  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_344

literal_345 -> leaf_352
leaf_352  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str"]
// END RANK literal_345

raw_346 -> leaf_353
leaf_353  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" which ends the span.
  - str   :  The string of which the Node spans part or the whole.

"]
// END RANK raw_346

section_326 -> { header_354 prose_355 codeblock_356}
{rank=same; header_354 prose_355 codeblock_356}

header_354 [label="3 : Other fields"]

prose_355 [label="prose"]

codeblock_356 [label="code block 496-498"]


// END RANK section_326

header_354 -> leaf_357
leaf_357  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Other fields"]
// END RANK header_354

prose_355 -> { raw_358}
{rank=same; raw_358}

raw_358 [label="raw"]


// END RANK prose_355

raw_358 -> leaf_359
leaf_359  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  In principle, anything at all.
"]
// END RANK raw_358

codeblock_356 -> leaf_360
leaf_360  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return Node"]
// END RANK codeblock_356


}
