digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 456"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-361"]


section_1 -> { header_2 prose_3 section_4 section_5 section_6 section_7 section_8}
{rank=same; header_2 prose_3 section_4 section_5 section_6 section_7 section_8}

header_2 [label="1 : Node"]

prose_3 [label="prose"]

section_4 [label="section: 6-13"]

section_5 [label="section: 14-28"]

section_6 [label="section: 29-45"]

section_7 [label="section: 46-340"]

section_8 [label="section: 362-421"]


header_2 -> leaf_9
leaf_9  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Node"]
prose_3 -> { raw_10}
{rank=same; raw_10}

raw_10 [label="raw"]


raw_10 -> leaf_11
leaf_11  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


  Time to stabilize this class once and for all. 
"]
section_4 -> { header_12 prose_13 codeblock_14}
{rank=same; header_12 prose_13 codeblock_14}

header_12 [label="3 : includes"]

prose_13 [label="prose"]

codeblock_14 [label="code block 8-12"]


header_12 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** includes"]
prose_13 -> { raw_16}
{rank=same; raw_16}

raw_16 [label="raw"]


raw_16 -> leaf_17
leaf_17  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_14 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local s = require \"status\" ()
local a = require \"ansi\"
local dot = require \"node/dot\""]
section_5 -> { header_19 prose_20 codeblock_21}
{rank=same; header_19 prose_20 codeblock_21}

header_19 [label="2 : Node metatable"]

prose_20 [label="prose"]

codeblock_21 [label="code block 20-25"]


header_19 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Node metatable"]
prose_20 -> { raw_23 prespace_24 literal_25 raw_26}
{rank=same; raw_23 prespace_24 literal_25 raw_26}

raw_23 [label="raw"]

prespace_24 [label="prespace"]

literal_25 [label="literal"]

raw_26 [label="raw"]


raw_23 -> leaf_27
leaf_27  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  The Node metatable is the root table for any Node.  I'm planning to make
an intermediate class/table called Root that is in common for any instance
Node.  All Root absolutely has to contain is"]
prespace_24 -> leaf_28
leaf_28  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_25 -> leaf_29
leaf_29  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str"]
raw_26 -> leaf_30
leaf_30  [color=Gray,shape=rectangle,fontname=Inconsolata,label=". 
"]
codeblock_21 -> leaf_31
leaf_31  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
local Node = {}
Node.__index = Node
Node.isNode = true"]
section_6 -> { header_32 prose_33 prose_34 codeblock_35 prose_36}
{rank=same; header_32 prose_33 prose_34 codeblock_35 prose_36}

header_32 [label="2 : Fields"]

prose_33 [label="prose"]

prose_34 [label="prose"]

codeblock_35 [label="code block 38-41"]

prose_36 [label="prose"]


header_32 -> leaf_37
leaf_37  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Fields"]
prose_33 -> { raw_38}
{rank=same; raw_38}

raw_38 [label="raw"]


raw_38 -> leaf_39
leaf_39  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

   - id :  A string naming the Node. 
           This is identical to the name of the pattern that recognizes
           or captures it.
"]
prose_34 -> { raw_40}
{rank=same; raw_40}

raw_40 [label="raw"]


raw_40 -> leaf_41
leaf_41  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
   - line_first :  Always -1. #deprecated
   - line_last  :  Always -1. #deprecated
"]
codeblock_35 -> leaf_42
leaf_42  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Node.line_first = -1
Node.line_last  = -1"]
prose_36 -> { raw_43 link_44 raw_45}
{rank=same; raw_43 link_44 raw_45}

raw_43 [label="raw"]

link_44 [label="link"]

raw_45 [label="raw"]


raw_43 -> leaf_46
leaf_46  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
It occurs to me we could lazily calculate these using the "]
link_44 -> { anchortext_47 url_48}
{rank=same; anchortext_47 url_48}

anchortext_47 [label="anchortext"]

url_48 [label="url"]


anchortext_47 -> leaf_49
leaf_49  [color=Gray,shape=rectangle,fontname=Inconsolata,label="line iterator"]
url_48 -> leaf_50
leaf_50  [color=Gray,shape=rectangle,fontname=Inconsolata,label="httk://"]
raw_45 -> leaf_51
leaf_51  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".

"]
section_7 -> { header_52 prose_53 section_54 section_55 section_56 section_57 section_58}
{rank=same; header_52 prose_53 section_54 section_55 section_56 section_57 section_58}

header_52 [label="2 : Methods"]

prose_53 [label="prose"]

section_54 [label="section: 48-49"]

section_55 [label="section: 62-100"]

section_56 [label="section: 101-298"]

section_57 [label="section: 323-340"]

section_58 [label="section: 341-343"]


header_52 -> leaf_59
leaf_59  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Methods"]
prose_53 -> { raw_60}
{rank=same; raw_60}

raw_60 [label="raw"]


raw_60 -> leaf_61
leaf_61  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
section_54 -> { header_62 prose_63 section_64}
{rank=same; header_62 prose_63 section_64}

header_62 [label="3 : Scaffolding "]

prose_63 [label="prose"]

section_64 [label="section: 50-61"]


header_62 -> leaf_65
leaf_65  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Scaffolding "]
prose_63 -> { raw_66}
{rank=same; raw_66}

raw_66 [label="raw"]


raw_66 -> leaf_67
leaf_67  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
section_64 -> { header_68 prose_69 codeblock_70}
{rank=same; header_68 prose_69 codeblock_70}

header_68 [label="4 : toLua"]

prose_69 [label="prose"]

codeblock_70 [label="code block 55-59"]


header_68 -> leaf_71
leaf_71  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** toLua"]
prose_69 -> { raw_72}
{rank=same; raw_72}

raw_72 [label="raw"]


raw_72 -> leaf_73
leaf_73  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This is not a general method in any sense, it's here as a backstop
while I build out Clu. 
"]
codeblock_70 -> leaf_74
leaf_74  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.toLua(node)
  s:halt(\"No toLua method for \" .. node.id)
end"]
section_55 -> { header_75 prose_76 prose_77 codeblock_78}
{rank=same; header_75 prose_76 prose_77 codeblock_78}

header_75 [label="3 : Visualizer"]

prose_76 [label="prose"]

prose_77 [label="prose"]

codeblock_78 [label="code block 69-99"]


header_75 -> leaf_79
leaf_79  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Visualizer"]
prose_76 -> { raw_80}
{rank=same; raw_80}

raw_80 [label="raw"]


raw_80 -> leaf_81
leaf_81  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This gives us a nice, tree-shaped printout of an entire Node.
"]
prose_77 -> { raw_82}
{rank=same; raw_82}

raw_82 [label="raw"]


raw_82 -> leaf_83
leaf_83  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
We're less disciplined than we should be about up-assigning this to
inherited Node classes. 
"]
codeblock_78 -> leaf_84
leaf_84  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.toString(node, depth)
   local depth = depth or 0
   local phrase = \"\"
   phrase = (\"  \"):rep(depth) .. a.bright(node.id) .. \"    \"
      .. a.cyan(node.first) .. \"-\" .. a.cyan(node.last)
   if node[1] then
      local extra = \"    \"
      if Node.len(node) > 56 then
         local span = Node.span(node)
         local pre, post = string.sub(span, 1, 28), string.sub(span, -28, -1)
         extra = extra .. a.dim(pre) .. a.bright(\"…\") .. a.dim(post)
         extra = extra:gsub(\"\\n\", \"◼︎\")
      else
         extra = extra .. a.dim(Node.span(node):gsub(\"\\n\", \"◼︎\"))
      end
      phrase = phrase .. extra .. \"\\n\"
      for _,v in ipairs(node) do
         if (v.isNode) then
            phrase = phrase .. Node.toString(v, depth + 1)
         end
      end
   else
      local val = node.str:sub(node.first, node.last)
                          :gsub(\" \", a.clear() .. a.dim(\"_\") .. a.green())
      val = a.green(val)
      phrase = phrase .. \"    \" .. val  .. \"\\n\"
   end
   return phrase
end"]
section_56 -> { header_85 prose_86 section_87 section_88 section_89 section_90 section_91 section_92 section_93 section_94}
{rank=same; header_85 prose_86 section_87 section_88 section_89 section_90 section_91 section_92 section_93 section_94}

header_85 [label="3 : Metrics"]

prose_86 [label="prose"]

section_87 [label="section: 104-112"]

section_88 [label="section: 113-123"]

section_89 [label="section: 124-195"]

section_90 [label="section: 196-216"]

section_91 [label="section: 217-239"]

section_92 [label="section: 240-279"]

section_93 [label="section: 280-298"]

section_94 [label="section: 299-322"]


header_85 -> leaf_95
leaf_95  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Metrics"]
prose_86 -> { raw_96}
{rank=same; raw_96}

raw_96 [label="raw"]


raw_96 -> leaf_97
leaf_97  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

"]
section_87 -> { header_98 prose_99 codeblock_100}
{rank=same; header_98 prose_99 codeblock_100}

header_98 [label="4 : span"]

prose_99 [label="prose"]

codeblock_100 [label="code block 106-110"]


header_98 -> leaf_101
leaf_101  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** span"]
prose_99 -> { raw_102}
{rank=same; raw_102}

raw_102 [label="raw"]


raw_102 -> leaf_103
leaf_103  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_100 -> leaf_104
leaf_104  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.span(node)
   return string.sub(node.str, node.first, node.last)
end"]
section_88 -> { header_105 prose_106 codeblock_107}
{rank=same; header_105 prose_106 codeblock_107}

header_105 [label="4 : len"]

prose_106 [label="prose"]

codeblock_107 [label="code block 117-121"]


header_105 -> leaf_108
leaf_108  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** len"]
prose_106 -> { raw_109}
{rank=same; raw_109}

raw_109 [label="raw"]


raw_109 -> leaf_110
leaf_110  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

ahh, the pleasure of indexing by one. 
"]
codeblock_107 -> leaf_111
leaf_111  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.len(node)
    return 1 + node.last - node.first
end"]
section_89 -> { header_112 prose_113 prose_114 prose_115 prose_116 prose_117 codeblock_118 codeblock_119}
{rank=same; header_112 prose_113 prose_114 prose_115 prose_116 prose_117 codeblock_118 codeblock_119}

header_112 [label="4 : Node:gap(node)"]

prose_113 [label="prose"]

prose_114 [label="prose"]

prose_115 [label="prose"]

prose_116 [label="prose"]

prose_117 [label="prose"]

codeblock_118 [label="code block 143-163"]

codeblock_119 [label="code block 166-194"]


header_112 -> leaf_120
leaf_120  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node:gap(node)"]
prose_113 -> { raw_121 prespace_122 literal_123 raw_124 prespace_125 literal_126 raw_127 prespace_128 literal_129 raw_130 prespace_131 literal_132 raw_133 prespace_134 bold_135 raw_136}
{rank=same; raw_121 prespace_122 literal_123 raw_124 prespace_125 literal_126 raw_127 prespace_128 literal_129 raw_130 prespace_131 literal_132 raw_133 prespace_134 bold_135 raw_136}

raw_121 [label="raw"]

prespace_122 [label="prespace"]

literal_123 [label="literal"]

raw_124 [label="raw"]

prespace_125 [label="prespace"]

literal_126 [label="literal"]

raw_127 [label="raw"]

prespace_128 [label="prespace"]

literal_129 [label="literal"]

raw_130 [label="raw"]

prespace_131 [label="prespace"]

literal_132 [label="literal"]

raw_133 [label="raw"]

prespace_134 [label="prespace"]

bold_135 [label="bold"]

raw_136 [label="raw"]


raw_121 -> leaf_137
leaf_137  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

=Node.gap(left, right)= compares the"]
prespace_122 -> leaf_138
leaf_138  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_123 -> leaf_139
leaf_139  [color=Gray,shape=rectangle,fontname=Inconsolata,label="last"]
raw_124 -> leaf_140
leaf_140  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" field of the"]
prespace_125 -> leaf_141
leaf_141  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_126 -> leaf_142
leaf_142  [color=Gray,shape=rectangle,fontname=Inconsolata,label="left"]
raw_127 -> leaf_143
leaf_143  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" parameter
with the"]
prespace_128 -> leaf_144
leaf_144  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_129 -> leaf_145
leaf_145  [color=Gray,shape=rectangle,fontname=Inconsolata,label="first"]
raw_130 -> leaf_146
leaf_146  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" field of the"]
prespace_131 -> leaf_147
leaf_147  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_132 -> leaf_148
leaf_148  [color=Gray,shape=rectangle,fontname=Inconsolata,label="right"]
raw_133 -> leaf_149
leaf_149  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" parameter,"]
prespace_134 -> leaf_150
leaf_150  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
bold_135 -> leaf_151
leaf_151  [color=Gray,shape=rectangle,fontname=Inconsolata,label="if"]
raw_136 -> leaf_152
leaf_152  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" this is greater than
0. 
"]
prose_114 -> { raw_153 prespace_154 literal_155 raw_156 prespace_157 literal_158 raw_159 prespace_160 literal_161 raw_162 prespace_163 literal_164 raw_165}
{rank=same; raw_153 prespace_154 literal_155 raw_156 prespace_157 literal_158 raw_159 prespace_160 literal_161 raw_162 prespace_163 literal_164 raw_165}

raw_153 [label="raw"]

prespace_154 [label="prespace"]

literal_155 [label="literal"]

raw_156 [label="raw"]

prespace_157 [label="prespace"]

literal_158 [label="literal"]

raw_159 [label="raw"]

prespace_160 [label="prespace"]

literal_161 [label="literal"]

raw_162 [label="raw"]

prespace_163 [label="prespace"]

literal_164 [label="literal"]

raw_165 [label="raw"]


raw_153 -> leaf_166
leaf_166  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If it is negative,"]
prespace_154 -> leaf_167
leaf_167  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_155 -> leaf_168
leaf_168  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Node.gap"]
raw_156 -> leaf_169
leaf_169  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" attempts to measure the"]
prespace_157 -> leaf_170
leaf_170  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_158 -> leaf_171
leaf_171  [color=Gray,shape=rectangle,fontname=Inconsolata,label="first"]
raw_159 -> leaf_172
leaf_172  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" field of the
=right= parameter against the"]
prespace_160 -> leaf_173
leaf_173  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_161 -> leaf_174
leaf_174  [color=Gray,shape=rectangle,fontname=Inconsolata,label="last"]
raw_162 -> leaf_175
leaf_175  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" field of the"]
prespace_163 -> leaf_176
leaf_176  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_164 -> leaf_177
leaf_177  [color=Gray,shape=rectangle,fontname=Inconsolata,label="left"]
raw_165 -> leaf_178
leaf_178  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" parameter.
"]
prose_115 -> { raw_179 prespace_180 bold_181 raw_182}
{rank=same; raw_179 prespace_180 bold_181 raw_182}

raw_179 [label="raw"]

prespace_180 [label="prespace"]

bold_181 [label="bold"]

raw_182 [label="raw"]


raw_179 -> leaf_183
leaf_183  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If this is a natural number we return the"]
prespace_180 -> leaf_184
leaf_184  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
bold_181 -> leaf_185
leaf_185  [color=Gray,shape=rectangle,fontname=Inconsolata,label="negation"]
raw_182 -> leaf_186
leaf_186  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" of this value.  If both
should prove to be positive, we halt. 
"]
prose_116 -> { raw_187 prespace_188 literal_189 raw_190}
{rank=same; raw_187 prespace_188 literal_189 raw_190}

raw_187 [label="raw"]

prespace_188 [label="prespace"]

literal_189 [label="literal"]

raw_190 [label="raw"]


raw_187 -> leaf_191
leaf_191  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
No effort is made to check that the"]
prespace_188 -> leaf_192
leaf_192  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_189 -> leaf_193
leaf_193  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str"]
raw_190 -> leaf_194
leaf_194  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" field matches between nodes unless
we have an error, in which case it could prove helpful for diagnosis.  
"]
prose_117 -> { raw_195}
{rank=same; raw_195}

raw_195 [label="raw"]


raw_195 -> leaf_196
leaf_196  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Indeed such a check would be a disaster in streams or other sort of
piecewise parse.  Which will require implementation in and of itself, but
in the meantime...
"]
codeblock_118 -> leaf_197
leaf_197  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.gap(left, right)
  assert(left.last, \"no left.last\")
  assert(right.first, \"no right.first\")
  assert(right.last, \"no right.last\")
  assert(left.first, \"no left.first\")
  if left.first >= right.last then
    local left, right = right, left
  elseif left.last > right.first then
    s:halt(\"overlapping regions or str issue\")
  end
  local gap = left
  if gap >= 0 then
    return gap
  else
    s:halt(\"some kind of situation where gap is \" .. tostring(gap))
  end

  return nil 
end"]
codeblock_119 -> leaf_198
leaf_198  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.dotLabel(node)
  return node.id
end

function Node.toMarkdown(node)
  if not node[1] then
    return string.sub(node.str, node.first, node.last)
  else
    s:halt(\"no toMarkdown for \" .. node.id)
  end
end

function Node.dot(node)
  return dot.dot(node)
end

function Node.toValue(node)
  if node.__VALUE then
    return node.__VALUE
  end
  if node.str then
    return node.str:sub(node.first,node.last)
  else
    s:halt(\"no str on node \" .. node.id)
  end
end
"]
section_90 -> { header_199 prose_200 codeblock_201}
{rank=same; header_199 prose_200 codeblock_201}

header_199 [label="4 : Node.walkPost"]

prose_200 [label="prose"]

codeblock_201 [label="code block 200-215"]


header_199 -> leaf_202
leaf_202  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.walkPost"]
prose_200 -> { raw_203}
{rank=same; raw_203}

raw_203 [label="raw"]


raw_203 -> leaf_204
leaf_204  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Depth-first iterator, postfix 
"]
codeblock_201 -> leaf_205
leaf_205  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.walkPost(node)
    local function traverse(ast)
        if not ast.isNode then return nil end

        for _, v in ipairs(ast) do
            if type(v) == 'table' and v.isNode then
              traverse(v)
            end
        end
        coroutine.yield(ast)
    end

    return coroutine.wrap(function() traverse(node) end)
end"]
section_91 -> { header_206 prose_207 codeblock_208}
{rank=same; header_206 prose_207 codeblock_208}

header_206 [label="4 : Node.walk"]

prose_207 [label="prose"]

codeblock_208 [label="code block 221-237"]


header_206 -> leaf_209
leaf_209  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.walk"]
prose_207 -> { raw_210}
{rank=same; raw_210}

raw_210 [label="raw"]


raw_210 -> leaf_211
leaf_211  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Presearch iterator.  This is the default. 
"]
codeblock_208 -> leaf_212
leaf_212  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.walk(node)
  local function traverse(ast)
    if not ast.isNode then return nil end

    coroutine.yield(ast)
    for _, v in ipairs(ast) do
      if type(v) == 'table' and v.isNode then
        traverse(v)
      end
    end
  end

  return coroutine.wrap(function() traverse(node) end)
end
"]
section_92 -> { header_213 prose_214 codeblock_215}
{rank=same; header_213 prose_214 codeblock_215}

header_213 [label="4 : Node.select(node, pred)"]

prose_214 [label="prose"]

codeblock_215 [label="code block 246-277"]


header_213 -> leaf_216
leaf_216  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.select(node, pred)"]
prose_214 -> { raw_217 prespace_218 literal_219 raw_220}
{rank=same; raw_217 prespace_218 literal_219 raw_220}

raw_217 [label="raw"]

prespace_218 [label="prespace"]

literal_219 [label="literal"]

raw_220 [label="raw"]


raw_217 -> leaf_221
leaf_221  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Takes the Node and walks it, yielding the Nodes which match the predicate.
=pred= is either a string, which matches to"]
prespace_218 -> leaf_222
leaf_222  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_219 -> leaf_223
leaf_223  [color=Gray,shape=rectangle,fontname=Inconsolata,label="id"]
raw_220 -> leaf_224
leaf_224  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", or a function, which takes
a Node and returns true or false on some premise. 
"]
codeblock_215 -> leaf_225
leaf_225  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.select(node, pred)
   local function qualifies(node, pred)
      if type(pred) == 'string' then
         if type(node) == 'table' 
          and node.id and node.id == pred then
            return true
         else
            return false
         end
      elseif type(pred) == 'function' then
         return pred(node)
      else
         s:halt(\"cannot select on predicate of type \" .. type(pred))
      end
   end

   local function traverse(ast)
      -- breadth first
      if qualifies(ast, pred) then
         coroutine.yield(ast)
      end
      if ast.isNode then
         for _, v in ipairs(ast) do
            traverse(v)
         end
      end
   end

   return coroutine.wrap(function() traverse(node) end)
end"]
section_93 -> { header_226 prose_227 codeblock_228}
{rank=same; header_226 prose_227 codeblock_228}

header_226 [label="4 : Node.tokens(node)"]

prose_227 [label="prose"]

codeblock_228 [label="code block 284-296"]


header_226 -> leaf_229
leaf_229  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.tokens(node)"]
prose_227 -> { raw_230}
{rank=same; raw_230}

raw_230 [label="raw"]


raw_230 -> leaf_231
leaf_231  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Iterator returning all captured values as strings.
"]
codeblock_228 -> leaf_232
leaf_232  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.tokens(node)
  local function traverse(ast)
    for node in Node.walk(ast) do
      if not node[1] then
        coroutine.yield(node:toValue())
      end
    end
  end

  return coroutine.wrap(function() traverse(node) end)
end  "]
section_94 -> { header_233 prose_234 prose_235 prose_236 codeblock_237}
{rank=same; header_233 prose_234 prose_235 prose_236 codeblock_237}

header_233 [label="4 : Node.unroll(node)"]

prose_234 [label="prose"]

prose_235 [label="prose"]

prose_236 [label="prose"]

codeblock_237 [label="code block 313-320"]


header_233 -> leaf_238
leaf_238  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.unroll(node)"]
prose_234 -> { raw_239 prespace_240 literal_241 raw_242}
{rank=same; raw_239 prespace_240 literal_241 raw_242}

raw_239 [label="raw"]

prespace_240 [label="prespace"]

literal_241 [label="literal"]

raw_242 [label="raw"]


raw_239 -> leaf_243
leaf_243  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  This iterator returns all Nodes, in prefix order, while interpolating
strings.  Specifically: When a Node has a"]
prespace_240 -> leaf_244
leaf_244  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_241 -> leaf_245
leaf_245  [color=Gray,shape=rectangle,fontname=Inconsolata,label="first"]
raw_242 -> leaf_246
leaf_246  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" that is less than the
=first= if its first child, it makes a slice of the string corresponding to
that gap, and so on between each child, and once more at the end.
"]
prose_235 -> { raw_247}
{rank=same; raw_247}

raw_247 [label="raw"]


raw_247 -> leaf_248
leaf_248  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The effect is that any sections of the string which were dropped are now
interpolated into the unrolled Node.
"]
prose_236 -> { raw_249 prespace_250 literal_251 raw_252 prespace_253 literal_254 raw_255 prespace_256 literal_257 raw_258}
{rank=same; raw_249 prespace_250 literal_251 raw_252 prespace_253 literal_254 raw_255 prespace_256 literal_257 raw_258}

raw_249 [label="raw"]

prespace_250 [label="prespace"]

literal_251 [label="literal"]

raw_252 [label="raw"]

prespace_253 [label="prespace"]

literal_254 [label="literal"]

raw_255 [label="raw"]

prespace_256 [label="prespace"]

literal_257 [label="literal"]

raw_258 [label="raw"]


raw_249 -> leaf_259
leaf_259  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The premise is that by calling"]
prespace_250 -> leaf_260
leaf_260  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_251 -> leaf_261
leaf_261  [color=Gray,shape=rectangle,fontname=Inconsolata,label="toValue()"]
raw_252 -> leaf_262
leaf_262  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" or"]
prespace_253 -> leaf_263
leaf_263  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_254 -> leaf_264
leaf_264  [color=Gray,shape=rectangle,fontname=Inconsolata,label="span()"]
raw_255 -> leaf_265
leaf_265  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" on leaf nodes, and
grafting these to the interpolated strings in order, you will produce the
original"]
prespace_256 -> leaf_266
leaf_266  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_257 -> leaf_267
leaf_267  [color=Gray,shape=rectangle,fontname=Inconsolata,label="node.str"]
raw_258 -> leaf_268
leaf_268  [color=Gray,shape=rectangle,fontname=Inconsolata,label=". 
"]
codeblock_237 -> leaf_269
leaf_269  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.unroll(node)
  local function traverse(ast)
  end

  return coroutine.wrap(function() traverse(node) end)
end"]
section_57 -> { header_270 prose_271 prose_272 codeblock_273}
{rank=same; header_270 prose_271 prose_272 codeblock_273}

header_270 [label="3 : Collectors"]

prose_271 [label="prose"]

prose_272 [label="prose"]

codeblock_273 [label="code block 330-339"]


header_270 -> leaf_274
leaf_274  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Collectors"]
prose_271 -> { raw_275}
{rank=same; raw_275}

raw_275 [label="raw"]


raw_275 -> leaf_276
leaf_276  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

These return an array of all results. 
"]
prose_272 -> { raw_277}
{rank=same; raw_277}

raw_277 [label="raw"]


raw_277 -> leaf_278
leaf_278  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- [ ] #todo  Add a Forest class to provide the iterator interface for
             the return arrays of this class.
"]
codeblock_273 -> leaf_279
leaf_279  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.gather(node, pred)
  local gathered = {}
  for ast in node:select(pred) do
    gathered[#gathered + 1] = ast
  end
  
  return gathered
end"]
section_58 -> { header_280 prose_281 section_282}
{rank=same; header_280 prose_281 section_282}

header_280 [label="3 : Subclassing and construction"]

prose_281 [label="prose"]

section_282 [label="section: 344-361"]


header_280 -> leaf_283
leaf_283  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Subclassing and construction"]
prose_281 -> { raw_284}
{rank=same; raw_284}

raw_284 [label="raw"]


raw_284 -> leaf_285
leaf_285  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

"]
section_282 -> { header_286 prose_287 codeblock_288}
{rank=same; header_286 prose_287 codeblock_288}

header_286 [label="4 : N.inherit(node)"]

prose_287 [label="prose"]

codeblock_288 [label="code block 346-360"]


header_286 -> leaf_289
leaf_289  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** N.inherit(node)"]
prose_287 -> { raw_290}
{rank=same; raw_290}

raw_290 [label="raw"]


raw_290 -> leaf_291
leaf_291  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_288 -> leaf_292
leaf_292  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.inherit(node)
  local Meta = setmetatable({}, node)
  Meta.__index = Meta
  local meta = setmetatable({}, Meta)
  meta.__index = meta
  return Meta, meta
end

function Node.export(_, mod, constructor)
  mod.__call = constructor
  return setmetatable({}, mod)
end
"]
section_8 -> { header_293 prose_294 prose_295 prose_296 prose_297 prose_298 section_299 section_300}
{rank=same; header_293 prose_294 prose_295 prose_296 prose_297 prose_298 section_299 section_300}

header_293 [label="2 : Node Instances"]

prose_294 [label="prose"]

prose_295 [label="prose"]

prose_296 [label="prose"]

prose_297 [label="prose"]

prose_298 [label="prose"]

section_299 [label="section: 386-408"]

section_300 [label="section: 422-456"]


header_293 -> leaf_301
leaf_301  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Node Instances"]
prose_294 -> { raw_302}
{rank=same; raw_302}

raw_302 [label="raw"]


raw_302 -> leaf_303
leaf_303  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  To be a Node, currently, indexed elements of the Array portion must also be 
Nodes. 
"]
prose_295 -> { raw_304}
{rank=same; raw_304}

raw_304 [label="raw"]


raw_304 -> leaf_305
leaf_305  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I'm mostly convinced that indexed elements can also be strings, and that 
this is the form leaf nodes should take.  Currently, they have a 'val' field
and no children, which we should replace with a child string at [1].
"]
prose_296 -> { raw_306 prespace_307 literal_308 raw_309 prespace_310 literal_311 raw_312}
{rank=same; raw_306 prespace_307 literal_308 raw_309 prespace_310 literal_311 raw_312}

raw_306 [label="raw"]

prespace_307 [label="prespace"]

literal_308 [label="literal"]

raw_309 [label="raw"]

prespace_310 [label="prespace"]

literal_311 [label="literal"]

raw_312 [label="raw"]


raw_306 -> leaf_313
leaf_313  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This gives us a lighter way to handle the circumstance where we have, say,
a list,"]
prespace_307 -> leaf_314
leaf_314  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_308 -> leaf_315
leaf_315  [color=Gray,shape=rectangle,fontname=Inconsolata,label="(foo bar baz)"]
raw_309 -> leaf_316
leaf_316  [color=Gray,shape=rectangle,fontname=Inconsolata,label=". We currently either need a \"left-per\" or \"pal\"
Node class to hold the"]
prespace_310 -> leaf_317
leaf_317  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_311 -> leaf_318
leaf_318  [color=Gray,shape=rectangle,fontname=Inconsolata,label="("]
raw_312 -> leaf_319
leaf_319  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", or we would have to skip it entirely.
"]
prose_297 -> { raw_320 prespace_321 italic_322 raw_323}
{rank=same; raw_320 prespace_321 italic_322 raw_323}

raw_320 [label="raw"]

prespace_321 [label="prespace"]

italic_322 [label="italic"]

raw_323 [label="raw"]


raw_320 -> leaf_324
leaf_324  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Quipu can't lose any information from the string, so they have to include
whitespace.  We're not limited in the same way and can reconstruct less 
semantically crucial parts of a document using the span and the original 
string, since we're not"]
prespace_321 -> leaf_325
leaf_325  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
italic_322 -> leaf_326
leaf_326  [color=Gray,shape=rectangle,fontname=Inconsolata,label="currently"]
raw_323 -> leaf_327
leaf_327  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" editing our strings once they're
entered in.
"]
prose_298 -> { raw_328}
{rank=same; raw_328}

raw_328 [label="raw"]


raw_328 -> leaf_329
leaf_329  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Nodes are meant to be broadly compatible with everything we intend to
do with abstract syntax trees.  The more I think about this the better
it strikes me as an approach. 

"]
section_299 -> { header_330 prose_331 prose_332 prose_333 prose_334 prose_335 section_336}
{rank=same; header_330 prose_331 prose_332 prose_333 prose_334 prose_335 section_336}

header_330 [label="3 : Fields"]

prose_331 [label="prose"]

prose_332 [label="prose"]

prose_333 [label="prose"]

prose_334 [label="prose"]

prose_335 [label="prose"]

section_336 [label="section: 409-421"]


header_330 -> leaf_337
leaf_337  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Fields"]
prose_331 -> { raw_338 prespace_339 literal_340 raw_341 prespace_342 literal_343 raw_344}
{rank=same; raw_338 prespace_339 literal_340 raw_341 prespace_342 literal_343 raw_344}

raw_338 [label="raw"]

prespace_339 [label="prespace"]

literal_340 [label="literal"]

raw_341 [label="raw"]

prespace_342 [label="prespace"]

literal_343 [label="literal"]

raw_344 [label="raw"]


raw_338 -> leaf_345
leaf_345  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  There are invariant fields a Node is also expected to have, they are:
 
  - first :  Index into"]
prespace_339 -> leaf_346
leaf_346  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_340 -> leaf_347
leaf_347  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str"]
raw_341 -> leaf_348
leaf_348  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" which begins the span.
  - last  :  Index into"]
prespace_342 -> leaf_349
leaf_349  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_343 -> leaf_350
leaf_350  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str"]
raw_344 -> leaf_351
leaf_351  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" which ends the span.
"]
prose_332 -> { raw_352 prespace_353 literal_354 raw_355}
{rank=same; raw_352 prespace_353 literal_354 raw_355}

raw_352 [label="raw"]

prespace_353 [label="prespace"]

literal_354 [label="literal"]

raw_355 [label="raw"]


raw_352 -> leaf_356
leaf_356  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
In principle, we want the Node to be localized. We could include a 
reference to the whole"]
prespace_353 -> leaf_357
leaf_357  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_354 -> leaf_358
leaf_358  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str"]
raw_355 -> leaf_359
leaf_359  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" and derive substrings lazily.
"]
prose_333 -> { raw_360}
{rank=same; raw_360}

raw_360 [label="raw"]


raw_360 -> leaf_361
leaf_361  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If we included the full span as a substring on each Node, we'd end up
with a lot of spans, and wouldn't use most of them. Even slicing a piece
out is costly if we're not going to use it. 
"]
prose_334 -> { raw_362}
{rank=same; raw_362}

raw_362 [label="raw"]


raw_362 -> leaf_363
leaf_363  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
So our constructor for a Node class takes (Constructor, node, str) as 
the standard interface.  If a module needs a non-standard constructor,
as our Section and Block modules currently take an array of lines, that
will need to be provided as the second return from the module. 
"]
prose_335 -> { raw_364}
{rank=same; raw_364}

raw_364 [label="raw"]


raw_364 -> leaf_365
leaf_365  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This will allow for the kind of multi-pass recursive-descent that I'm
aiming for. 

"]
section_336 -> { header_366 prose_367 prose_368 prose_369 prose_370}
{rank=same; header_366 prose_367 prose_368 prose_369 prose_370}

header_366 [label="4 : line tracking (optional)"]

prose_367 [label="prose"]

prose_368 [label="prose"]

prose_369 [label="prose"]

prose_370 [label="prose"]


header_366 -> leaf_371
leaf_371  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** line tracking (optional)"]
prose_367 -> { raw_372}
{rank=same; raw_372}

raw_372 [label="raw"]


raw_372 -> leaf_373
leaf_373  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

It may be wise to always track lines, in which case we will include:
"]
prose_368 -> { raw_374}
{rank=same; raw_374}

raw_374 [label="raw"]


raw_374 -> leaf_375
leaf_375  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  - line_first :  The line at which the match begins
  - line_last  :  The line at which the match ends
"]
prose_369 -> { raw_376}
{rank=same; raw_376}

raw_376 [label="raw"]


raw_376 -> leaf_377
leaf_377  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This is, at least, a frequent enough pattern that the metatable should return
a negative number if these aren't assigned. 
"]
prose_370 -> { raw_378}
{rank=same; raw_378}

raw_378 [label="raw"]


raw_378 -> leaf_379
leaf_379  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- [ ] #todo decide if line tracking is in fact optional

"]
section_300 -> { header_380 prose_381 prose_382 prose_383 prose_384 prose_385 prose_386 prose_387 prose_388 codeblock_389}
{rank=same; header_380 prose_381 prose_382 prose_383 prose_384 prose_385 prose_386 prose_387 prose_388 codeblock_389}

header_380 [label="3 : Other fields"]

prose_381 [label="prose"]

prose_382 [label="prose"]

prose_383 [label="prose"]

prose_384 [label="prose"]

prose_385 [label="prose"]

prose_386 [label="prose"]

prose_387 [label="prose"]

prose_388 [label="prose"]

codeblock_389 [label="code block 451-453"]


header_380 -> leaf_390
leaf_390  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Other fields"]
prose_381 -> { raw_391 prespace_392 literal_393 raw_394}
{rank=same; raw_391 prespace_392 literal_393 raw_394}

raw_391 [label="raw"]

prespace_392 [label="prespace"]

literal_393 [label="literal"]

raw_394 [label="raw"]


raw_391 -> leaf_395
leaf_395  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  The way the Grammar class will work: each"]
prespace_392 -> leaf_396
leaf_396  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_393 -> leaf_397
leaf_397  [color=Gray,shape=rectangle,fontname=Inconsolata,label="V\"patt\""]
raw_394 -> leaf_398
leaf_398  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" can have a metatable.
These are passed in as the second parameter during construction, with the key
the same name as the rule. 
"]
prose_382 -> { raw_399}
{rank=same; raw_399}

raw_399 [label="raw"]


raw_399 -> leaf_400
leaf_400  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If a pattern doesn't have a metatable, it's given a Node class and consists of
only the above fields, plus an array representing any subrules. 
"]
prose_383 -> { raw_401 prespace_402 literal_403 raw_404}
{rank=same; raw_401 prespace_402 literal_403 raw_404}

raw_401 [label="raw"]

prespace_402 [label="prespace"]

literal_403 [label="literal"]

raw_404 [label="raw"]


raw_401 -> leaf_405
leaf_405  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If it does, the metatable will have a"]
prespace_402 -> leaf_406
leaf_406  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_403 -> leaf_407
leaf_407  [color=Gray,shape=rectangle,fontname=Inconsolata,label="__call"]
raw_404 -> leaf_408
leaf_408  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" method, which expects two
parameters, itself, and the node, which will include the span. 
"]
prose_384 -> { raw_409 prespace_410 literal_411 raw_412}
{rank=same; raw_409 prespace_410 literal_411 raw_412}

raw_409 [label="raw"]

prespace_410 [label="prespace"]

literal_411 [label="literal"]

raw_412 [label="raw"]


raw_409 -> leaf_413
leaf_413  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This will require reattunement of basically every class in the"]
prespace_410 -> leaf_414
leaf_414  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_411 -> leaf_415
leaf_415  [color=Gray,shape=rectangle,fontname=Inconsolata,label="/grym"]
raw_412 -> leaf_416
leaf_416  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" folder,
but let's build the Prose parse first.  I do want the whole shebang in a single
grammar eventually.
"]
prose_385 -> { raw_417}
{rank=same; raw_417}

raw_417 [label="raw"]


raw_417 -> leaf_418
leaf_418  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The intention is to allow multiple grammars to coexist peacefully. Currently
the parser is handrolled and we have special case values for everything.
The idea is to stabilize this, so that multi-pass parsing works but in a
standard way where the Node constructor is a consistent interface. 
"]
prose_386 -> { raw_419}
{rank=same; raw_419}

raw_419 [label="raw"]


raw_419 -> leaf_420
leaf_420  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
In the meantime we have things like
"]
prose_387 -> { raw_421 prespace_422 literal_423 raw_424}
{rank=same; raw_421 prespace_422 literal_423 raw_424}

raw_421 [label="raw"]

prespace_422 [label="prespace"]

literal_423 [label="literal"]

raw_424 [label="raw"]


raw_421 -> leaf_425
leaf_425  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- lines :  If this exists, there's a collection of lines which need to be
           joined with"]
prespace_422 -> leaf_426
leaf_426  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_423 -> leaf_427
leaf_427  [color=Gray,shape=rectangle,fontname=Inconsolata,label="\\n"]
raw_424 -> leaf_428
leaf_428  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" to reconstruct the actual span.
"]
prose_388 -> { raw_429}
{rank=same; raw_429}

raw_429 [label="raw"]


raw_429 -> leaf_430
leaf_430  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
           We want to do this the other way, and use the span itself for the
           inner parse. 
"]
codeblock_389 -> leaf_431
leaf_431  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return Node"]

}
