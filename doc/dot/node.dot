digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 317"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-222"]


section_1 -> { header_2 prose_3 section_4 section_5 section_6 section_7 section_8}
{rank=same; header_2 prose_3 section_4 section_5 section_6 section_7 section_8}

header_2 [label="1 : Node"]

prose_3 [label="prose"]

section_4 [label="section: 6-12"]

section_5 [label="section: 13-27"]

section_6 [label="section: 28-44"]

section_7 [label="section: 45-204"]

section_8 [label="section: 223-282"]


header_2 -> leaf_9
leaf_9  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Node"]
prose_3 -> { raw_10}
{rank=same; raw_10}

raw_10 [label="raw"]


raw_10 -> leaf_11
leaf_11  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


  Time to stabilize this class once and for all. 
"]
section_4 -> { header_12 prose_13 codeblock_14}
{rank=same; header_12 prose_13 codeblock_14}

header_12 [label="3 : includes"]

prose_13 [label="prose"]

codeblock_14 [label="code block 8-11"]


header_12 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** includes"]
prose_13 -> { raw_16}
{rank=same; raw_16}

raw_16 [label="raw"]


raw_16 -> leaf_17
leaf_17  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_14 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local s = require \"status\"
local dot = require \"node/dot\""]
section_5 -> { header_19 prose_20 codeblock_21}
{rank=same; header_19 prose_20 codeblock_21}

header_19 [label="2 : Node metatable"]

prose_20 [label="prose"]

codeblock_21 [label="code block 19-24"]


header_19 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Node metatable"]
prose_20 -> { raw_23 literal_24 raw_25}
{rank=same; raw_23 literal_24 raw_25}

raw_23 [label="raw"]

literal_24 [label="literal"]

raw_25 [label="raw"]


raw_23 -> leaf_26
leaf_26  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  The Node metatable is the root table for any Node.  I'm planning to make
an intermediate class/table called Root that is in common for any instance
Node.  All Root absolutely has to contain is "]
literal_24 -> leaf_27
leaf_27  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str"]
raw_25 -> leaf_28
leaf_28  [color=Gray,shape=rectangle,fontname=Inconsolata,label=". 
"]
codeblock_21 -> leaf_29
leaf_29  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
local N = {}
N.__index = N
N.isNode = true"]
section_6 -> { header_30 prose_31 prose_32 codeblock_33 prose_34}
{rank=same; header_30 prose_31 prose_32 codeblock_33 prose_34}

header_30 [label="2 : Fields"]

prose_31 [label="prose"]

prose_32 [label="prose"]

codeblock_33 [label="code block 37-40"]

prose_34 [label="prose"]


header_30 -> leaf_35
leaf_35  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Fields"]
prose_31 -> { raw_36}
{rank=same; raw_36}

raw_36 [label="raw"]


raw_36 -> leaf_37
leaf_37  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

   - id :  A string naming the Node. 
           This is identical to the name of the pattern that recognizes
           or captures it.
"]
prose_32 -> { raw_38}
{rank=same; raw_38}

raw_38 [label="raw"]


raw_38 -> leaf_39
leaf_39  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
   - line_first :  Always -1.
   - line_last  :  Always -1. 
"]
codeblock_33 -> leaf_40
leaf_40  [color=Gray,shape=rectangle,fontname=Inconsolata,label="N.line_first = -1
N.line_last  = -1"]
prose_34 -> { raw_41 link_42 raw_43}
{rank=same; raw_41 link_42 raw_43}

raw_41 [label="raw"]

link_42 [label="link"]

raw_43 [label="raw"]


raw_41 -> leaf_44
leaf_44  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
It occurs to me we could lazily calculate these using the "]
link_42 -> { anchortext_45 url_46}
{rank=same; anchortext_45 url_46}

anchortext_45 [label="anchortext"]

url_46 [label="url"]


anchortext_45 -> leaf_47
leaf_47  [color=Gray,shape=rectangle,fontname=Inconsolata,label="line iterator"]
url_46 -> leaf_48
leaf_48  [color=Gray,shape=rectangle,fontname=Inconsolata,label="httk://"]
raw_43 -> leaf_49
leaf_49  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".

"]
section_7 -> { header_50 prose_51 section_52 section_53}
{rank=same; header_50 prose_51 section_52 section_53}

header_50 [label="2 : Methods"]

prose_51 [label="prose"]

section_52 [label="section: 48-185"]

section_53 [label="section: 205-222"]


header_50 -> leaf_54
leaf_54  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Methods"]
prose_51 -> { raw_55}
{rank=same; raw_55}

raw_55 [label="raw"]


raw_55 -> leaf_56
leaf_56  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

"]
section_52 -> { header_57 prose_58 prose_59 codeblock_60 codeblock_61 section_62 section_63 section_64 section_65}
{rank=same; header_57 prose_58 prose_59 codeblock_60 codeblock_61 section_62 section_63 section_64 section_65}

header_57 [label="3 : Visualizers"]

prose_58 [label="prose"]

prose_59 [label="prose"]

codeblock_60 [label="code block 55-70"]

codeblock_61 [label="code block 72-100"]

section_62 [label="section: 102-122"]

section_63 [label="section: 123-145"]

section_64 [label="section: 146-185"]

section_65 [label="section: 186-204"]


header_57 -> leaf_66
leaf_66  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Visualizers"]
prose_58 -> { raw_67}
{rank=same; raw_67}

raw_67 [label="raw"]


raw_67 -> leaf_68
leaf_68  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This gives us a nice, tree-shaped printout of an entire Node.
"]
prose_59 -> { raw_69}
{rank=same; raw_69}

raw_69 [label="raw"]


raw_69 -> leaf_70
leaf_70  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
We're less disciplined than we should be about up-assigning this to
inherited Node classes. 
"]
codeblock_60 -> leaf_71
leaf_71  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function N.toString(node, depth)
   local depth = depth or 0
   local phrase = \"\"
   phrase = (\"  \"):rep(depth) .. \"id: \" .. node.id .. \",  \"
      .. \"first: \" .. node.first .. \", last: \" .. node.last .. \"\\n\"
   if node[1] then
    for _,v in ipairs(node) do
      if(v.isNode) then
        phrase = phrase .. N.toString(v, depth + 1)
      end
    end
  end 
   return phrase
end"]
codeblock_61 -> leaf_72
leaf_72  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function N.dotLabel(node)
  return node.id
end

function N.toMarkdown(node)
  if not node[1] then
    return string.sub(node.str, node.first, node.last)
  else
    s:halt(\"no toMarkdown for \" .. node.id)
  end
end

function N.dot(node)
  return dot.dot(node)
end

function N.toValue(node)
  if node.__VALUE then
    return node.__VALUE
  end
  if node.str then
    return node.str:sub(node.first,node.last)
  else
    s:halt(\"no str on node \" .. node.id)
  end
end
"]
section_62 -> { header_73 prose_74 codeblock_75}
{rank=same; header_73 prose_74 codeblock_75}

header_73 [label="4 : N.walkDeep"]

prose_74 [label="prose"]

codeblock_75 [label="code block 106-121"]


header_73 -> leaf_76
leaf_76  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** N.walkDeep"]
prose_74 -> { raw_77}
{rank=same; raw_77}

raw_77 [label="raw"]


raw_77 -> leaf_78
leaf_78  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Depth-first iterator. 
"]
codeblock_75 -> leaf_79
leaf_79  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function N.walkDeep(node)
    local function traverse(ast)
        if not ast.isNode then return nil end

        for _, v in ipairs(ast) do
            if type(v) == 'table' and v.isNode then
              traverse(v)
            end
        end
        coroutine.yield(ast)
    end

    return coroutine.wrap(function() traverse(node) end)
end"]
section_63 -> { header_80 prose_81 codeblock_82}
{rank=same; header_80 prose_81 codeblock_82}

header_80 [label="4 : N.walk"]

prose_81 [label="prose"]

codeblock_82 [label="code block 127-143"]


header_80 -> leaf_83
leaf_83  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** N.walk"]
prose_81 -> { raw_84}
{rank=same; raw_84}

raw_84 [label="raw"]


raw_84 -> leaf_85
leaf_85  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Breadth-first iterator.  This is the default. 
"]
codeblock_82 -> leaf_86
leaf_86  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function N.walk(node)
  local function traverse(ast)
    if not ast.isNode then return nil end

    coroutine.yield(ast)
    for _, v in ipairs(ast) do
      if type(v) == 'table' and v.isNode then
        traverse(v)
      end
    end
  end

  return coroutine.wrap(function() traverse(node) end)
end
"]
section_64 -> { header_87 prose_88 codeblock_89}
{rank=same; header_87 prose_88 codeblock_89}

header_87 [label="4 : N.select(node, pred)"]

prose_88 [label="prose"]

codeblock_89 [label="code block 152-183"]


header_87 -> leaf_90
leaf_90  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** N.select(node, pred)"]
prose_88 -> { raw_91 literal_92 raw_93 literal_94 raw_95}
{rank=same; raw_91 literal_92 raw_93 literal_94 raw_95}

raw_91 [label="raw"]

literal_92 [label="literal"]

raw_93 [label="raw"]

literal_94 [label="literal"]

raw_95 [label="raw"]


raw_91 -> leaf_96
leaf_96  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Takes the Node and walks it, yielding the Nodes which match the predicate."]
literal_92 -> leaf_97
leaf_97  [color=Gray,shape=rectangle,fontname=Inconsolata,label="pred"]
raw_93 -> leaf_98
leaf_98  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is either a string, which matches to "]
literal_94 -> leaf_99
leaf_99  [color=Gray,shape=rectangle,fontname=Inconsolata,label="id"]
raw_95 -> leaf_100
leaf_100  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", or a function, which takes
a Node and returns true or false on some premise. 
"]
codeblock_89 -> leaf_101
leaf_101  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function N.select(node, pred)
   local function qualifies(node, pred)
      if type(pred) == 'string' then
         if type(node) == 'table' 
          and node.id and node.id == pred then
            return true
         else
            return false
         end
      elseif type(pred) == 'function' then
         return pred(node)
      else
         s:halt(\"cannot select on predicate of type \" .. type(pred))
      end
   end

   local function traverse(ast)
      -- depth first
      if qualifies(ast, pred) then
         coroutine.yield(ast)
      end
      if ast.isNode then
         for _, v in ipairs(ast) do
            traverse(v)
         end
      end
   end

   return coroutine.wrap(function() traverse(node) end)
end"]
section_65 -> { header_102 prose_103 codeblock_104}
{rank=same; header_102 prose_103 codeblock_104}

header_102 [label="4 : N.tokens(node)"]

prose_103 [label="prose"]

codeblock_104 [label="code block 190-202"]


header_102 -> leaf_105
leaf_105  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** N.tokens(node)"]
prose_103 -> { raw_106}
{rank=same; raw_106}

raw_106 [label="raw"]


raw_106 -> leaf_107
leaf_107  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Iterator returning all 'captured' values as strings.
"]
codeblock_104 -> leaf_108
leaf_108  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function N.tokens(node)
  local function traverse(ast)
    for node in N.walk(ast) do
      if not node[1] then
        coroutine.yield(node:toValue())
      end
    end
  end

  return coroutine.wrap(function() traverse(node) end)
end  "]
section_53 -> { header_109 prose_110 prose_111 codeblock_112}
{rank=same; header_109 prose_110 prose_111 codeblock_112}

header_109 [label="3 : Collectors"]

prose_110 [label="prose"]

prose_111 [label="prose"]

codeblock_112 [label="code block 212-221"]


header_109 -> leaf_113
leaf_113  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Collectors"]
prose_110 -> { raw_114}
{rank=same; raw_114}

raw_114 [label="raw"]


raw_114 -> leaf_115
leaf_115  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

These return an array of all results. 
"]
prose_111 -> { raw_116}
{rank=same; raw_116}

raw_116 [label="raw"]


raw_116 -> leaf_117
leaf_117  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- [ ] #todo  Add a Forest class to provide the iterator interface for
             the return arrays of this class.
"]
codeblock_112 -> leaf_118
leaf_118  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function N.gather(node, pred)
  local gathered = {}
  for ast in node:select(pred) do
    gathered[#gathered + 1] = ast
  end
  
  return gathered
end"]
section_8 -> { header_119 prose_120 prose_121 prose_122 prose_123 prose_124 section_125 section_126}
{rank=same; header_119 prose_120 prose_121 prose_122 prose_123 prose_124 section_125 section_126}

header_119 [label="2 : Node Instances"]

prose_120 [label="prose"]

prose_121 [label="prose"]

prose_122 [label="prose"]

prose_123 [label="prose"]

prose_124 [label="prose"]

section_125 [label="section: 247-269"]

section_126 [label="section: 283-317"]


header_119 -> leaf_127
leaf_127  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Node Instances"]
prose_120 -> { raw_128}
{rank=same; raw_128}

raw_128 [label="raw"]


raw_128 -> leaf_129
leaf_129  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  To be a Node, currently, indexed elements of the Array portion must also be 
Nodes. 
"]
prose_121 -> { raw_130}
{rank=same; raw_130}

raw_130 [label="raw"]


raw_130 -> leaf_131
leaf_131  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I'm mostly convinced that indexed elements can also be strings, and that 
this is the form leaf nodes should take.  Currently, they have a 'val' field
and no children, which we should replace with a child string at [1].
"]
prose_122 -> { raw_132 literal_133 raw_134 literal_135 raw_136}
{rank=same; raw_132 literal_133 raw_134 literal_135 raw_136}

raw_132 [label="raw"]

literal_133 [label="literal"]

raw_134 [label="raw"]

literal_135 [label="literal"]

raw_136 [label="raw"]


raw_132 -> leaf_137
leaf_137  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This gives us a lighter way to handle the circumstance where we have, say,
a list, "]
literal_133 -> leaf_138
leaf_138  [color=Gray,shape=rectangle,fontname=Inconsolata,label="(foo bar baz)"]
raw_134 -> leaf_139
leaf_139  [color=Gray,shape=rectangle,fontname=Inconsolata,label=". We currently either need a \"left-per\" or \"pal\"
Node class to hold the "]
literal_135 -> leaf_140
leaf_140  [color=Gray,shape=rectangle,fontname=Inconsolata,label="("]
raw_136 -> leaf_141
leaf_141  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", or we would have to skip it entirely.
"]
prose_123 -> { raw_142}
{rank=same; raw_142}

raw_142 [label="raw"]


raw_142 -> leaf_143
leaf_143  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Quipu can't lose any information from the string, so they have to include
whitespace.  We're not limited in the same way and can reconstruct less 
semantically crucial parts of a document using the span and the original 
string, since we're not /currently/ editing our strings once they're
entered in.
"]
prose_124 -> { raw_144}
{rank=same; raw_144}

raw_144 [label="raw"]


raw_144 -> leaf_145
leaf_145  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Nodes are meant to be broadly compatible with everything we intend to
do with abstract syntax trees.  The more I think about this the better
it strikes me as an approach. 

"]
section_125 -> { header_146 prose_147 prose_148 prose_149 prose_150 prose_151 section_152}
{rank=same; header_146 prose_147 prose_148 prose_149 prose_150 prose_151 section_152}

header_146 [label="3 : Fields"]

prose_147 [label="prose"]

prose_148 [label="prose"]

prose_149 [label="prose"]

prose_150 [label="prose"]

prose_151 [label="prose"]

section_152 [label="section: 270-282"]


header_146 -> leaf_153
leaf_153  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Fields"]
prose_147 -> { raw_154 literal_155 raw_156 literal_157 raw_158}
{rank=same; raw_154 literal_155 raw_156 literal_157 raw_158}

raw_154 [label="raw"]

literal_155 [label="literal"]

raw_156 [label="raw"]

literal_157 [label="literal"]

raw_158 [label="raw"]


raw_154 -> leaf_159
leaf_159  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  There are invariant fields a Node is also expected to have, they are:
 
  - first :  Index into "]
literal_155 -> leaf_160
leaf_160  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str"]
raw_156 -> leaf_161
leaf_161  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" which begins the span.
  - last  :  Index into "]
literal_157 -> leaf_162
leaf_162  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str"]
raw_158 -> leaf_163
leaf_163  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" which ends the span.
"]
prose_148 -> { raw_164 literal_165 raw_166}
{rank=same; raw_164 literal_165 raw_166}

raw_164 [label="raw"]

literal_165 [label="literal"]

raw_166 [label="raw"]


raw_164 -> leaf_167
leaf_167  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
In principle, we want the Node to be localized. We could include a 
reference to the whole "]
literal_165 -> leaf_168
leaf_168  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str"]
raw_166 -> leaf_169
leaf_169  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" and derive substrings lazily.
"]
prose_149 -> { raw_170}
{rank=same; raw_170}

raw_170 [label="raw"]


raw_170 -> leaf_171
leaf_171  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If we included the full span as a substring on each Node, we'd end up
with a lot of spans, and wouldn't use most of them. Even slicing a piece
out is costly if we're not going to use it. 
"]
prose_150 -> { raw_172}
{rank=same; raw_172}

raw_172 [label="raw"]


raw_172 -> leaf_173
leaf_173  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
So our constructor for a Node class takes (Constructor, node, str) as 
the standard interface.  If a module needs a non-standard constructor,
as our Section and Block modules currently take an array of lines, that
will need to be provided as the second return from the module. 
"]
prose_151 -> { raw_174}
{rank=same; raw_174}

raw_174 [label="raw"]


raw_174 -> leaf_175
leaf_175  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This will allow for the kind of multi-pass recursive-descent that I'm
aiming for. 

"]
section_152 -> { header_176 prose_177 prose_178 prose_179 prose_180}
{rank=same; header_176 prose_177 prose_178 prose_179 prose_180}

header_176 [label="4 : line tracking (optional)"]

prose_177 [label="prose"]

prose_178 [label="prose"]

prose_179 [label="prose"]

prose_180 [label="prose"]


header_176 -> leaf_181
leaf_181  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** line tracking (optional)"]
prose_177 -> { raw_182}
{rank=same; raw_182}

raw_182 [label="raw"]


raw_182 -> leaf_183
leaf_183  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

It may be wise to always track lines, in which case we will include:
"]
prose_178 -> { raw_184}
{rank=same; raw_184}

raw_184 [label="raw"]


raw_184 -> leaf_185
leaf_185  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  - line_first :  The line at which the match begins
  - line_last  :  The line at which the match ends
"]
prose_179 -> { raw_186}
{rank=same; raw_186}

raw_186 [label="raw"]


raw_186 -> leaf_187
leaf_187  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This is, at least, a frequent enough pattern that the metatable should return
a negative number if these aren't assigned. 
"]
prose_180 -> { raw_188}
{rank=same; raw_188}

raw_188 [label="raw"]


raw_188 -> leaf_189
leaf_189  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- [ ] #todo decide if line tracking is in fact optional

"]
section_126 -> { header_190 prose_191 prose_192 prose_193 prose_194 prose_195 prose_196 prose_197 prose_198 codeblock_199}
{rank=same; header_190 prose_191 prose_192 prose_193 prose_194 prose_195 prose_196 prose_197 prose_198 codeblock_199}

header_190 [label="3 : Other fields"]

prose_191 [label="prose"]

prose_192 [label="prose"]

prose_193 [label="prose"]

prose_194 [label="prose"]

prose_195 [label="prose"]

prose_196 [label="prose"]

prose_197 [label="prose"]

prose_198 [label="prose"]

codeblock_199 [label="code block 312-314"]


header_190 -> leaf_200
leaf_200  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Other fields"]
prose_191 -> { raw_201 literal_202 raw_203}
{rank=same; raw_201 literal_202 raw_203}

raw_201 [label="raw"]

literal_202 [label="literal"]

raw_203 [label="raw"]


raw_201 -> leaf_204
leaf_204  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  The way the Grammar class will work: each "]
literal_202 -> leaf_205
leaf_205  [color=Gray,shape=rectangle,fontname=Inconsolata,label="V\"patt\""]
raw_203 -> leaf_206
leaf_206  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" can have a metatable.
These are passed in as the second parameter during construction, with the key
the same name as the rule. 
"]
prose_192 -> { raw_207}
{rank=same; raw_207}

raw_207 [label="raw"]


raw_207 -> leaf_208
leaf_208  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If a pattern doesn't have a metatable, it's given a Node class and consists of
only the above fields, plus an array representing any subrules. 
"]
prose_193 -> { raw_209 literal_210 raw_211}
{rank=same; raw_209 literal_210 raw_211}

raw_209 [label="raw"]

literal_210 [label="literal"]

raw_211 [label="raw"]


raw_209 -> leaf_212
leaf_212  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If it does, the metatable will have a "]
literal_210 -> leaf_213
leaf_213  [color=Gray,shape=rectangle,fontname=Inconsolata,label="__call"]
raw_211 -> leaf_214
leaf_214  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" method, which expects two
parameters, itself, and the node, which will include the span. 
"]
prose_194 -> { raw_215 literal_216 raw_217}
{rank=same; raw_215 literal_216 raw_217}

raw_215 [label="raw"]

literal_216 [label="literal"]

raw_217 [label="raw"]


raw_215 -> leaf_218
leaf_218  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This will require reattunement of basically every class in the "]
literal_216 -> leaf_219
leaf_219  [color=Gray,shape=rectangle,fontname=Inconsolata,label="/grym"]
raw_217 -> leaf_220
leaf_220  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" folder,
but let's build the Prose parse first.  I do want the whole shebang in a single
grammar eventually.
"]
prose_195 -> { raw_221}
{rank=same; raw_221}

raw_221 [label="raw"]


raw_221 -> leaf_222
leaf_222  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The intention is to allow multiple grammars to coexist peacefully. Currently
the parser is handrolled and we have special case values for everything.
The idea is to stabilize this, so that multi-pass parsing works but in a
standard way where the Node constructor is a consistent interface. 
"]
prose_196 -> { raw_223}
{rank=same; raw_223}

raw_223 [label="raw"]


raw_223 -> leaf_224
leaf_224  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
In the meantime we have things like
"]
prose_197 -> { raw_225 literal_226 raw_227}
{rank=same; raw_225 literal_226 raw_227}

raw_225 [label="raw"]

literal_226 [label="literal"]

raw_227 [label="raw"]


raw_225 -> leaf_228
leaf_228  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- lines :  If this exists, there's a collection of lines which need to be
           joined with "]
literal_226 -> leaf_229
leaf_229  [color=Gray,shape=rectangle,fontname=Inconsolata,label="\\n"]
raw_227 -> leaf_230
leaf_230  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" to reconstruct the actual span.
"]
prose_198 -> { raw_231}
{rank=same; raw_231}

raw_231 [label="raw"]


raw_231 -> leaf_232
leaf_232  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
           We want to do this the other way, and use the span itself for the
           inner parse. 
"]
codeblock_199 -> leaf_233
leaf_233  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return N"]

}
