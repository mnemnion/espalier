digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 454"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-359"]


section_1 -> { header_2 prose_3 section_4 section_5 section_6 section_7 section_8}
{rank=same; header_2 prose_3 section_4 section_5 section_6 section_7 section_8}

header_2 [label="1 : Node"]

prose_3 [label="prose"]

section_4 [label="section: 6-13"]

section_5 [label="section: 14-28"]

section_6 [label="section: 29-45"]

section_7 [label="section: 46-338"]

section_8 [label="section: 360-419"]


header_2 -> leaf_9
leaf_9  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Node"]
prose_3 -> { raw_10}
{rank=same; raw_10}

raw_10 [label="raw"]


raw_10 -> leaf_11
leaf_11  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


  Time to stabilize this class once and for all. 
"]
section_4 -> { header_12 prose_13 codeblock_14}
{rank=same; header_12 prose_13 codeblock_14}

header_12 [label="3 : includes"]

prose_13 [label="prose"]

codeblock_14 [label="code block 8-12"]


header_12 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** includes"]
prose_13 -> { raw_16}
{rank=same; raw_16}

raw_16 [label="raw"]


raw_16 -> leaf_17
leaf_17  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_14 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local s = require \"status\" ()
local ansi = require \"ansi\"
local dot = require \"node/dot\""]
section_5 -> { header_19 prose_20 codeblock_21}
{rank=same; header_19 prose_20 codeblock_21}

header_19 [label="2 : Node metatable"]

prose_20 [label="prose"]

codeblock_21 [label="code block 20-25"]


header_19 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Node metatable"]
prose_20 -> { raw_23 literal_24 raw_25}
{rank=same; raw_23 literal_24 raw_25}

raw_23 [label="raw"]

literal_24 [label="literal"]

raw_25 [label="raw"]


raw_23 -> leaf_26
leaf_26  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  The Node metatable is the root table for any Node.  I'm planning to make
an intermediate class/table called Root that is in common for any instance
Node.  All Root absolutely has to contain is "]
literal_24 -> leaf_27
leaf_27  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str"]
raw_25 -> leaf_28
leaf_28  [color=Gray,shape=rectangle,fontname=Inconsolata,label=". 
"]
codeblock_21 -> leaf_29
leaf_29  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
local Node = {}
Node.__index = Node
Node.isNode = true"]
section_6 -> { header_30 prose_31 prose_32 codeblock_33 prose_34}
{rank=same; header_30 prose_31 prose_32 codeblock_33 prose_34}

header_30 [label="2 : Fields"]

prose_31 [label="prose"]

prose_32 [label="prose"]

codeblock_33 [label="code block 38-41"]

prose_34 [label="prose"]


header_30 -> leaf_35
leaf_35  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Fields"]
prose_31 -> { raw_36}
{rank=same; raw_36}

raw_36 [label="raw"]


raw_36 -> leaf_37
leaf_37  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

   - id :  A string naming the Node. 
           This is identical to the name of the pattern that recognizes
           or captures it.
"]
prose_32 -> { raw_38}
{rank=same; raw_38}

raw_38 [label="raw"]


raw_38 -> leaf_39
leaf_39  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
   - line_first :  Always -1. #deprecated
   - line_last  :  Always -1. #deprecated
"]
codeblock_33 -> leaf_40
leaf_40  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Node.line_first = -1
Node.line_last  = -1"]
prose_34 -> { raw_41 link_42 raw_43}
{rank=same; raw_41 link_42 raw_43}

raw_41 [label="raw"]

link_42 [label="link"]

raw_43 [label="raw"]


raw_41 -> leaf_44
leaf_44  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
It occurs to me we could lazily calculate these using the "]
link_42 -> { anchortext_45 url_46}
{rank=same; anchortext_45 url_46}

anchortext_45 [label="anchortext"]

url_46 [label="url"]


anchortext_45 -> leaf_47
leaf_47  [color=Gray,shape=rectangle,fontname=Inconsolata,label="line iterator"]
url_46 -> leaf_48
leaf_48  [color=Gray,shape=rectangle,fontname=Inconsolata,label="httk://"]
raw_43 -> leaf_49
leaf_49  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".

"]
section_7 -> { header_50 prose_51 section_52 section_53 section_54 section_55 section_56}
{rank=same; header_50 prose_51 section_52 section_53 section_54 section_55 section_56}

header_50 [label="2 : Methods"]

prose_51 [label="prose"]

section_52 [label="section: 48-49"]

section_53 [label="section: 62-98"]

section_54 [label="section: 99-296"]

section_55 [label="section: 321-338"]

section_56 [label="section: 339-341"]


header_50 -> leaf_57
leaf_57  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Methods"]
prose_51 -> { raw_58}
{rank=same; raw_58}

raw_58 [label="raw"]


raw_58 -> leaf_59
leaf_59  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
section_52 -> { header_60 prose_61 section_62}
{rank=same; header_60 prose_61 section_62}

header_60 [label="3 : Scaffolding "]

prose_61 [label="prose"]

section_62 [label="section: 50-61"]


header_60 -> leaf_63
leaf_63  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Scaffolding "]
prose_61 -> { raw_64}
{rank=same; raw_64}

raw_64 [label="raw"]


raw_64 -> leaf_65
leaf_65  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
section_62 -> { header_66 prose_67 codeblock_68}
{rank=same; header_66 prose_67 codeblock_68}

header_66 [label="4 : toLua"]

prose_67 [label="prose"]

codeblock_68 [label="code block 55-59"]


header_66 -> leaf_69
leaf_69  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** toLua"]
prose_67 -> { raw_70}
{rank=same; raw_70}

raw_70 [label="raw"]


raw_70 -> leaf_71
leaf_71  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This is not a general method in any sense, it's here as a backstop
while I build out Clu. 
"]
codeblock_68 -> leaf_72
leaf_72  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.toLua(node)
  s:halt(\"No toLua method for \" .. node.id)
end"]
section_53 -> { header_73 prose_74 prose_75 codeblock_76}
{rank=same; header_73 prose_74 prose_75 codeblock_76}

header_73 [label="3 : Visualizer"]

prose_74 [label="prose"]

prose_75 [label="prose"]

codeblock_76 [label="code block 69-97"]


header_73 -> leaf_77
leaf_77  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Visualizer"]
prose_74 -> { raw_78}
{rank=same; raw_78}

raw_78 [label="raw"]


raw_78 -> leaf_79
leaf_79  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This gives us a nice, tree-shaped printout of an entire Node.
"]
prose_75 -> { raw_80}
{rank=same; raw_80}

raw_80 [label="raw"]


raw_80 -> leaf_81
leaf_81  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
We're less disciplined than we should be about up-assigning this to
inherited Node classes. 
"]
codeblock_76 -> leaf_82
leaf_82  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.toString(node, depth)
   local depth = depth or 0
   local phrase = \"\"
   phrase = (\"  \"):rep(depth) .. \"id: \" .. ansi.bright(node.id) .. \",  \"
      .. \"first: \" .. node.first .. \", last: \" .. node.last
   if node[1] then
      local extra = \" span:  \"
      if Node.len(node) > 56 then
         local span = Node.span(node)
         local pre, post = string.sub(span, 1, 28), string.sub(span, -28, -1)
         extra = extra .. ansi.dim(pre) .. ansi.bright(\"…\") .. ansi.dim(post)
         extra = extra:gsub(\"\\n\", \"◼︎\")
      else
         extra = extra .. ansi.dim(Node.span(node):gsub(\"\\n\", \"◼︎\"))
      end
      phrase = phrase .. extra .. \"\\n\"
      for _,v in ipairs(node) do
         if (v.isNode) then
            phrase = phrase .. Node.toString(v, depth + 1)
         end
      end
   else
      phrase = phrase .. \",  val:  \" 
             .. ansi.green(node.str:sub(node.first, node.last)) .. \"\\n\"
   end
   return phrase
end"]
section_54 -> { header_83 prose_84 section_85 section_86 section_87 section_88 section_89 section_90 section_91 section_92}
{rank=same; header_83 prose_84 section_85 section_86 section_87 section_88 section_89 section_90 section_91 section_92}

header_83 [label="3 : Metrics"]

prose_84 [label="prose"]

section_85 [label="section: 102-110"]

section_86 [label="section: 111-121"]

section_87 [label="section: 122-193"]

section_88 [label="section: 194-214"]

section_89 [label="section: 215-237"]

section_90 [label="section: 238-277"]

section_91 [label="section: 278-296"]

section_92 [label="section: 297-320"]


header_83 -> leaf_93
leaf_93  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Metrics"]
prose_84 -> { raw_94}
{rank=same; raw_94}

raw_94 [label="raw"]


raw_94 -> leaf_95
leaf_95  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

"]
section_85 -> { header_96 prose_97 codeblock_98}
{rank=same; header_96 prose_97 codeblock_98}

header_96 [label="4 : span"]

prose_97 [label="prose"]

codeblock_98 [label="code block 104-108"]


header_96 -> leaf_99
leaf_99  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** span"]
prose_97 -> { raw_100}
{rank=same; raw_100}

raw_100 [label="raw"]


raw_100 -> leaf_101
leaf_101  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_98 -> leaf_102
leaf_102  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.span(node)
   return string.sub(node.str, node.first, node.last)
end"]
section_86 -> { header_103 prose_104 codeblock_105}
{rank=same; header_103 prose_104 codeblock_105}

header_103 [label="4 : len"]

prose_104 [label="prose"]

codeblock_105 [label="code block 115-119"]


header_103 -> leaf_106
leaf_106  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** len"]
prose_104 -> { raw_107}
{rank=same; raw_107}

raw_107 [label="raw"]


raw_107 -> leaf_108
leaf_108  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

ahh, the pleasure of indexing by one. 
"]
codeblock_105 -> leaf_109
leaf_109  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.len(node)
    return 1 + node.last - node.first
end"]
section_87 -> { header_110 prose_111 prose_112 prose_113 prose_114 prose_115 codeblock_116 codeblock_117}
{rank=same; header_110 prose_111 prose_112 prose_113 prose_114 prose_115 codeblock_116 codeblock_117}

header_110 [label="4 : Node:gap(node)"]

prose_111 [label="prose"]

prose_112 [label="prose"]

prose_113 [label="prose"]

prose_114 [label="prose"]

prose_115 [label="prose"]

codeblock_116 [label="code block 141-161"]

codeblock_117 [label="code block 164-192"]


header_110 -> leaf_118
leaf_118  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node:gap(node)"]
prose_111 -> { raw_119 literal_120 raw_121 literal_122 raw_123 literal_124 raw_125 literal_126 raw_127 literal_128 raw_129 bold_130 raw_131}
{rank=same; raw_119 literal_120 raw_121 literal_122 raw_123 literal_124 raw_125 literal_126 raw_127 literal_128 raw_129 bold_130 raw_131}

raw_119 [label="raw"]

literal_120 [label="literal"]

raw_121 [label="raw"]

literal_122 [label="literal"]

raw_123 [label="raw"]

literal_124 [label="literal"]

raw_125 [label="raw"]

literal_126 [label="literal"]

raw_127 [label="raw"]

literal_128 [label="literal"]

raw_129 [label="raw"]

bold_130 [label="bold"]

raw_131 [label="raw"]


raw_119 -> leaf_132
leaf_132  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
literal_120 -> leaf_133
leaf_133  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Node.gap(left, right)"]
raw_121 -> leaf_134
leaf_134  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" compares the "]
literal_122 -> leaf_135
leaf_135  [color=Gray,shape=rectangle,fontname=Inconsolata,label="last"]
raw_123 -> leaf_136
leaf_136  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" field of the "]
literal_124 -> leaf_137
leaf_137  [color=Gray,shape=rectangle,fontname=Inconsolata,label="left"]
raw_125 -> leaf_138
leaf_138  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" parameter
with the "]
literal_126 -> leaf_139
leaf_139  [color=Gray,shape=rectangle,fontname=Inconsolata,label="first"]
raw_127 -> leaf_140
leaf_140  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" field of the "]
literal_128 -> leaf_141
leaf_141  [color=Gray,shape=rectangle,fontname=Inconsolata,label="right"]
raw_129 -> leaf_142
leaf_142  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" parameter, "]
bold_130 -> leaf_143
leaf_143  [color=Gray,shape=rectangle,fontname=Inconsolata,label="if"]
raw_131 -> leaf_144
leaf_144  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" this is greater than
0. 
"]
prose_112 -> { raw_145 literal_146 raw_147 literal_148 raw_149 literal_150 raw_151 literal_152 raw_153 literal_154 raw_155}
{rank=same; raw_145 literal_146 raw_147 literal_148 raw_149 literal_150 raw_151 literal_152 raw_153 literal_154 raw_155}

raw_145 [label="raw"]

literal_146 [label="literal"]

raw_147 [label="raw"]

literal_148 [label="literal"]

raw_149 [label="raw"]

literal_150 [label="literal"]

raw_151 [label="raw"]

literal_152 [label="literal"]

raw_153 [label="raw"]

literal_154 [label="literal"]

raw_155 [label="raw"]


raw_145 -> leaf_156
leaf_156  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If it is negative, "]
literal_146 -> leaf_157
leaf_157  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Node.gap"]
raw_147 -> leaf_158
leaf_158  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" attempts to measure the "]
literal_148 -> leaf_159
leaf_159  [color=Gray,shape=rectangle,fontname=Inconsolata,label="first"]
raw_149 -> leaf_160
leaf_160  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" field of the"]
literal_150 -> leaf_161
leaf_161  [color=Gray,shape=rectangle,fontname=Inconsolata,label="right"]
raw_151 -> leaf_162
leaf_162  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" parameter against the "]
literal_152 -> leaf_163
leaf_163  [color=Gray,shape=rectangle,fontname=Inconsolata,label="last"]
raw_153 -> leaf_164
leaf_164  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" field of the "]
literal_154 -> leaf_165
leaf_165  [color=Gray,shape=rectangle,fontname=Inconsolata,label="left"]
raw_155 -> leaf_166
leaf_166  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" parameter.
"]
prose_113 -> { raw_167 bold_168 raw_169}
{rank=same; raw_167 bold_168 raw_169}

raw_167 [label="raw"]

bold_168 [label="bold"]

raw_169 [label="raw"]


raw_167 -> leaf_170
leaf_170  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If this is a natural number we return the "]
bold_168 -> leaf_171
leaf_171  [color=Gray,shape=rectangle,fontname=Inconsolata,label="negation"]
raw_169 -> leaf_172
leaf_172  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" of this value.  If both
should prove to be positive, we halt. 
"]
prose_114 -> { raw_173 literal_174 raw_175}
{rank=same; raw_173 literal_174 raw_175}

raw_173 [label="raw"]

literal_174 [label="literal"]

raw_175 [label="raw"]


raw_173 -> leaf_176
leaf_176  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
No effort is made to check that the "]
literal_174 -> leaf_177
leaf_177  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str"]
raw_175 -> leaf_178
leaf_178  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" field matches between nodes unless
we have an error, in which case it could prove helpful for diagnosis.  
"]
prose_115 -> { raw_179}
{rank=same; raw_179}

raw_179 [label="raw"]


raw_179 -> leaf_180
leaf_180  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Indeed such a check would be a disaster in streams or other sort of
piecewise parse.  Which will require implementation in and of itself, but
in the meantime...
"]
codeblock_116 -> leaf_181
leaf_181  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.gap(left, right)
  assert(left.last, \"no left.last\")
  assert(right.first, \"no right.first\")
  assert(right.last, \"no right.last\")
  assert(left.first, \"no left.first\")
  if left.first >= right.last then
    local left, right = right, left
  elseif left.last > right.first then
    s:halt(\"overlapping regions or str issue\")
  end
  local gap = left
  if gap >= 0 then
    return gap
  else
    s:halt(\"some kind of situation where gap is \" .. tostring(gap))
  end

  return nil 
end"]
codeblock_117 -> leaf_182
leaf_182  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.dotLabel(node)
  return node.id
end

function Node.toMarkdown(node)
  if not node[1] then
    return string.sub(node.str, node.first, node.last)
  else
    s:halt(\"no toMarkdown for \" .. node.id)
  end
end

function Node.dot(node)
  return dot.dot(node)
end

function Node.toValue(node)
  if node.__VALUE then
    return node.__VALUE
  end
  if node.str then
    return node.str:sub(node.first,node.last)
  else
    s:halt(\"no str on node \" .. node.id)
  end
end
"]
section_88 -> { header_183 prose_184 codeblock_185}
{rank=same; header_183 prose_184 codeblock_185}

header_183 [label="4 : Node.walkPost"]

prose_184 [label="prose"]

codeblock_185 [label="code block 198-213"]


header_183 -> leaf_186
leaf_186  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.walkPost"]
prose_184 -> { raw_187}
{rank=same; raw_187}

raw_187 [label="raw"]


raw_187 -> leaf_188
leaf_188  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Depth-first iterator, postfix 
"]
codeblock_185 -> leaf_189
leaf_189  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.walkPost(node)
    local function traverse(ast)
        if not ast.isNode then return nil end

        for _, v in ipairs(ast) do
            if type(v) == 'table' and v.isNode then
              traverse(v)
            end
        end
        coroutine.yield(ast)
    end

    return coroutine.wrap(function() traverse(node) end)
end"]
section_89 -> { header_190 prose_191 codeblock_192}
{rank=same; header_190 prose_191 codeblock_192}

header_190 [label="4 : Node.walk"]

prose_191 [label="prose"]

codeblock_192 [label="code block 219-235"]


header_190 -> leaf_193
leaf_193  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.walk"]
prose_191 -> { raw_194}
{rank=same; raw_194}

raw_194 [label="raw"]


raw_194 -> leaf_195
leaf_195  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Presearch iterator.  This is the default. 
"]
codeblock_192 -> leaf_196
leaf_196  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.walk(node)
  local function traverse(ast)
    if not ast.isNode then return nil end

    coroutine.yield(ast)
    for _, v in ipairs(ast) do
      if type(v) == 'table' and v.isNode then
        traverse(v)
      end
    end
  end

  return coroutine.wrap(function() traverse(node) end)
end
"]
section_90 -> { header_197 prose_198 codeblock_199}
{rank=same; header_197 prose_198 codeblock_199}

header_197 [label="4 : Node.select(node, pred)"]

prose_198 [label="prose"]

codeblock_199 [label="code block 244-275"]


header_197 -> leaf_200
leaf_200  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.select(node, pred)"]
prose_198 -> { raw_201 literal_202 raw_203 literal_204 raw_205}
{rank=same; raw_201 literal_202 raw_203 literal_204 raw_205}

raw_201 [label="raw"]

literal_202 [label="literal"]

raw_203 [label="raw"]

literal_204 [label="literal"]

raw_205 [label="raw"]


raw_201 -> leaf_206
leaf_206  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Takes the Node and walks it, yielding the Nodes which match the predicate."]
literal_202 -> leaf_207
leaf_207  [color=Gray,shape=rectangle,fontname=Inconsolata,label="pred"]
raw_203 -> leaf_208
leaf_208  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is either a string, which matches to "]
literal_204 -> leaf_209
leaf_209  [color=Gray,shape=rectangle,fontname=Inconsolata,label="id"]
raw_205 -> leaf_210
leaf_210  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", or a function, which takes
a Node and returns true or false on some premise. 
"]
codeblock_199 -> leaf_211
leaf_211  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.select(node, pred)
   local function qualifies(node, pred)
      if type(pred) == 'string' then
         if type(node) == 'table' 
          and node.id and node.id == pred then
            return true
         else
            return false
         end
      elseif type(pred) == 'function' then
         return pred(node)
      else
         s:halt(\"cannot select on predicate of type \" .. type(pred))
      end
   end

   local function traverse(ast)
      -- breadth first
      if qualifies(ast, pred) then
         coroutine.yield(ast)
      end
      if ast.isNode then
         for _, v in ipairs(ast) do
            traverse(v)
         end
      end
   end

   return coroutine.wrap(function() traverse(node) end)
end"]
section_91 -> { header_212 prose_213 codeblock_214}
{rank=same; header_212 prose_213 codeblock_214}

header_212 [label="4 : Node.tokens(node)"]

prose_213 [label="prose"]

codeblock_214 [label="code block 282-294"]


header_212 -> leaf_215
leaf_215  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.tokens(node)"]
prose_213 -> { raw_216}
{rank=same; raw_216}

raw_216 [label="raw"]


raw_216 -> leaf_217
leaf_217  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Iterator returning all captured values as strings.
"]
codeblock_214 -> leaf_218
leaf_218  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.tokens(node)
  local function traverse(ast)
    for node in Node.walk(ast) do
      if not node[1] then
        coroutine.yield(node:toValue())
      end
    end
  end

  return coroutine.wrap(function() traverse(node) end)
end  "]
section_92 -> { header_219 prose_220 prose_221 prose_222 codeblock_223}
{rank=same; header_219 prose_220 prose_221 prose_222 codeblock_223}

header_219 [label="4 : Node.unroll(node)"]

prose_220 [label="prose"]

prose_221 [label="prose"]

prose_222 [label="prose"]

codeblock_223 [label="code block 311-318"]


header_219 -> leaf_224
leaf_224  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.unroll(node)"]
prose_220 -> { raw_225 literal_226 raw_227 literal_228 raw_229}
{rank=same; raw_225 literal_226 raw_227 literal_228 raw_229}

raw_225 [label="raw"]

literal_226 [label="literal"]

raw_227 [label="raw"]

literal_228 [label="literal"]

raw_229 [label="raw"]


raw_225 -> leaf_230
leaf_230  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  This iterator returns all Nodes, in prefix order, while interpolating
strings.  Specifically: When a Node has a "]
literal_226 -> leaf_231
leaf_231  [color=Gray,shape=rectangle,fontname=Inconsolata,label="first"]
raw_227 -> leaf_232
leaf_232  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" that is less than the"]
literal_228 -> leaf_233
leaf_233  [color=Gray,shape=rectangle,fontname=Inconsolata,label="first"]
raw_229 -> leaf_234
leaf_234  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" if its first child, it makes a slice of the string corresponding to
that gap, and so on between each child, and once more at the end.
"]
prose_221 -> { raw_235}
{rank=same; raw_235}

raw_235 [label="raw"]


raw_235 -> leaf_236
leaf_236  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The effect is that any sections of the string which were dropped are now
interpolated into the unrolled Node.
"]
prose_222 -> { raw_237 literal_238 raw_239 literal_240 raw_241 literal_242 raw_243}
{rank=same; raw_237 literal_238 raw_239 literal_240 raw_241 literal_242 raw_243}

raw_237 [label="raw"]

literal_238 [label="literal"]

raw_239 [label="raw"]

literal_240 [label="literal"]

raw_241 [label="raw"]

literal_242 [label="literal"]

raw_243 [label="raw"]


raw_237 -> leaf_244
leaf_244  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The premise is that by calling "]
literal_238 -> leaf_245
leaf_245  [color=Gray,shape=rectangle,fontname=Inconsolata,label="toValue()"]
raw_239 -> leaf_246
leaf_246  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" or "]
literal_240 -> leaf_247
leaf_247  [color=Gray,shape=rectangle,fontname=Inconsolata,label="span()"]
raw_241 -> leaf_248
leaf_248  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" on leaf nodes, and
grafting these to the interpolated strings in order, you will produce the
original "]
literal_242 -> leaf_249
leaf_249  [color=Gray,shape=rectangle,fontname=Inconsolata,label="node.str"]
raw_243 -> leaf_250
leaf_250  [color=Gray,shape=rectangle,fontname=Inconsolata,label=". 
"]
codeblock_223 -> leaf_251
leaf_251  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.unroll(node)
  local function traverse(ast)
  end

  return coroutine.wrap(function() traverse(node) end)
end"]
section_55 -> { header_252 prose_253 prose_254 codeblock_255}
{rank=same; header_252 prose_253 prose_254 codeblock_255}

header_252 [label="3 : Collectors"]

prose_253 [label="prose"]

prose_254 [label="prose"]

codeblock_255 [label="code block 328-337"]


header_252 -> leaf_256
leaf_256  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Collectors"]
prose_253 -> { raw_257}
{rank=same; raw_257}

raw_257 [label="raw"]


raw_257 -> leaf_258
leaf_258  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

These return an array of all results. 
"]
prose_254 -> { raw_259}
{rank=same; raw_259}

raw_259 [label="raw"]


raw_259 -> leaf_260
leaf_260  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- [ ] #todo  Add a Forest class to provide the iterator interface for
             the return arrays of this class.
"]
codeblock_255 -> leaf_261
leaf_261  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.gather(node, pred)
  local gathered = {}
  for ast in node:select(pred) do
    gathered[#gathered + 1] = ast
  end
  
  return gathered
end"]
section_56 -> { header_262 prose_263 section_264}
{rank=same; header_262 prose_263 section_264}

header_262 [label="3 : Subclassing and construction"]

prose_263 [label="prose"]

section_264 [label="section: 342-359"]


header_262 -> leaf_265
leaf_265  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Subclassing and construction"]
prose_263 -> { raw_266}
{rank=same; raw_266}

raw_266 [label="raw"]


raw_266 -> leaf_267
leaf_267  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

"]
section_264 -> { header_268 prose_269 codeblock_270}
{rank=same; header_268 prose_269 codeblock_270}

header_268 [label="4 : N.inherit(node)"]

prose_269 [label="prose"]

codeblock_270 [label="code block 344-358"]


header_268 -> leaf_271
leaf_271  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** N.inherit(node)"]
prose_269 -> { raw_272}
{rank=same; raw_272}

raw_272 [label="raw"]


raw_272 -> leaf_273
leaf_273  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_270 -> leaf_274
leaf_274  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.inherit(node)
  Meta = setmetatable({}, node)
  Meta.__index = Meta
  local meta = setmetatable({}, Meta)
  meta.__index = meta
  return Meta, meta
end

function Node.export(_, mod, constructor)
  mod.__call = constructor
  return setmetatable({}, mod)
end
"]
section_8 -> { header_275 prose_276 prose_277 prose_278 prose_279 prose_280 section_281 section_282}
{rank=same; header_275 prose_276 prose_277 prose_278 prose_279 prose_280 section_281 section_282}

header_275 [label="2 : Node Instances"]

prose_276 [label="prose"]

prose_277 [label="prose"]

prose_278 [label="prose"]

prose_279 [label="prose"]

prose_280 [label="prose"]

section_281 [label="section: 384-406"]

section_282 [label="section: 420-454"]


header_275 -> leaf_283
leaf_283  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Node Instances"]
prose_276 -> { raw_284}
{rank=same; raw_284}

raw_284 [label="raw"]


raw_284 -> leaf_285
leaf_285  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  To be a Node, currently, indexed elements of the Array portion must also be 
Nodes. 
"]
prose_277 -> { raw_286}
{rank=same; raw_286}

raw_286 [label="raw"]


raw_286 -> leaf_287
leaf_287  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I'm mostly convinced that indexed elements can also be strings, and that 
this is the form leaf nodes should take.  Currently, they have a 'val' field
and no children, which we should replace with a child string at [1].
"]
prose_278 -> { raw_288 literal_289 raw_290 literal_291 raw_292}
{rank=same; raw_288 literal_289 raw_290 literal_291 raw_292}

raw_288 [label="raw"]

literal_289 [label="literal"]

raw_290 [label="raw"]

literal_291 [label="literal"]

raw_292 [label="raw"]


raw_288 -> leaf_293
leaf_293  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This gives us a lighter way to handle the circumstance where we have, say,
a list, "]
literal_289 -> leaf_294
leaf_294  [color=Gray,shape=rectangle,fontname=Inconsolata,label="(foo bar baz)"]
raw_290 -> leaf_295
leaf_295  [color=Gray,shape=rectangle,fontname=Inconsolata,label=". We currently either need a \"left-per\" or \"pal\"
Node class to hold the "]
literal_291 -> leaf_296
leaf_296  [color=Gray,shape=rectangle,fontname=Inconsolata,label="("]
raw_292 -> leaf_297
leaf_297  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", or we would have to skip it entirely.
"]
prose_279 -> { raw_298 italic_299 raw_300}
{rank=same; raw_298 italic_299 raw_300}

raw_298 [label="raw"]

italic_299 [label="italic"]

raw_300 [label="raw"]


raw_298 -> leaf_301
leaf_301  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Quipu can't lose any information from the string, so they have to include
whitespace.  We're not limited in the same way and can reconstruct less 
semantically crucial parts of a document using the span and the original 
string, since we're not "]
italic_299 -> leaf_302
leaf_302  [color=Gray,shape=rectangle,fontname=Inconsolata,label="currently"]
raw_300 -> leaf_303
leaf_303  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" editing our strings once they're
entered in.
"]
prose_280 -> { raw_304}
{rank=same; raw_304}

raw_304 [label="raw"]


raw_304 -> leaf_305
leaf_305  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Nodes are meant to be broadly compatible with everything we intend to
do with abstract syntax trees.  The more I think about this the better
it strikes me as an approach. 

"]
section_281 -> { header_306 prose_307 prose_308 prose_309 prose_310 prose_311 section_312}
{rank=same; header_306 prose_307 prose_308 prose_309 prose_310 prose_311 section_312}

header_306 [label="3 : Fields"]

prose_307 [label="prose"]

prose_308 [label="prose"]

prose_309 [label="prose"]

prose_310 [label="prose"]

prose_311 [label="prose"]

section_312 [label="section: 407-419"]


header_306 -> leaf_313
leaf_313  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Fields"]
prose_307 -> { raw_314 literal_315 raw_316 literal_317 raw_318}
{rank=same; raw_314 literal_315 raw_316 literal_317 raw_318}

raw_314 [label="raw"]

literal_315 [label="literal"]

raw_316 [label="raw"]

literal_317 [label="literal"]

raw_318 [label="raw"]


raw_314 -> leaf_319
leaf_319  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  There are invariant fields a Node is also expected to have, they are:
 
  - first :  Index into "]
literal_315 -> leaf_320
leaf_320  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str"]
raw_316 -> leaf_321
leaf_321  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" which begins the span.
  - last  :  Index into "]
literal_317 -> leaf_322
leaf_322  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str"]
raw_318 -> leaf_323
leaf_323  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" which ends the span.
"]
prose_308 -> { raw_324 literal_325 raw_326}
{rank=same; raw_324 literal_325 raw_326}

raw_324 [label="raw"]

literal_325 [label="literal"]

raw_326 [label="raw"]


raw_324 -> leaf_327
leaf_327  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
In principle, we want the Node to be localized. We could include a 
reference to the whole "]
literal_325 -> leaf_328
leaf_328  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str"]
raw_326 -> leaf_329
leaf_329  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" and derive substrings lazily.
"]
prose_309 -> { raw_330}
{rank=same; raw_330}

raw_330 [label="raw"]


raw_330 -> leaf_331
leaf_331  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If we included the full span as a substring on each Node, we'd end up
with a lot of spans, and wouldn't use most of them. Even slicing a piece
out is costly if we're not going to use it. 
"]
prose_310 -> { raw_332}
{rank=same; raw_332}

raw_332 [label="raw"]


raw_332 -> leaf_333
leaf_333  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
So our constructor for a Node class takes (Constructor, node, str) as 
the standard interface.  If a module needs a non-standard constructor,
as our Section and Block modules currently take an array of lines, that
will need to be provided as the second return from the module. 
"]
prose_311 -> { raw_334}
{rank=same; raw_334}

raw_334 [label="raw"]


raw_334 -> leaf_335
leaf_335  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This will allow for the kind of multi-pass recursive-descent that I'm
aiming for. 

"]
section_312 -> { header_336 prose_337 prose_338 prose_339 prose_340}
{rank=same; header_336 prose_337 prose_338 prose_339 prose_340}

header_336 [label="4 : line tracking (optional)"]

prose_337 [label="prose"]

prose_338 [label="prose"]

prose_339 [label="prose"]

prose_340 [label="prose"]


header_336 -> leaf_341
leaf_341  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** line tracking (optional)"]
prose_337 -> { raw_342}
{rank=same; raw_342}

raw_342 [label="raw"]


raw_342 -> leaf_343
leaf_343  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

It may be wise to always track lines, in which case we will include:
"]
prose_338 -> { raw_344}
{rank=same; raw_344}

raw_344 [label="raw"]


raw_344 -> leaf_345
leaf_345  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  - line_first :  The line at which the match begins
  - line_last  :  The line at which the match ends
"]
prose_339 -> { raw_346}
{rank=same; raw_346}

raw_346 [label="raw"]


raw_346 -> leaf_347
leaf_347  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This is, at least, a frequent enough pattern that the metatable should return
a negative number if these aren't assigned. 
"]
prose_340 -> { raw_348}
{rank=same; raw_348}

raw_348 [label="raw"]


raw_348 -> leaf_349
leaf_349  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- [ ] #todo decide if line tracking is in fact optional

"]
section_282 -> { header_350 prose_351 prose_352 prose_353 prose_354 prose_355 prose_356 prose_357 prose_358 codeblock_359}
{rank=same; header_350 prose_351 prose_352 prose_353 prose_354 prose_355 prose_356 prose_357 prose_358 codeblock_359}

header_350 [label="3 : Other fields"]

prose_351 [label="prose"]

prose_352 [label="prose"]

prose_353 [label="prose"]

prose_354 [label="prose"]

prose_355 [label="prose"]

prose_356 [label="prose"]

prose_357 [label="prose"]

prose_358 [label="prose"]

codeblock_359 [label="code block 449-451"]


header_350 -> leaf_360
leaf_360  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Other fields"]
prose_351 -> { raw_361 literal_362 raw_363}
{rank=same; raw_361 literal_362 raw_363}

raw_361 [label="raw"]

literal_362 [label="literal"]

raw_363 [label="raw"]


raw_361 -> leaf_364
leaf_364  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  The way the Grammar class will work: each "]
literal_362 -> leaf_365
leaf_365  [color=Gray,shape=rectangle,fontname=Inconsolata,label="V\"patt\""]
raw_363 -> leaf_366
leaf_366  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" can have a metatable.
These are passed in as the second parameter during construction, with the key
the same name as the rule. 
"]
prose_352 -> { raw_367}
{rank=same; raw_367}

raw_367 [label="raw"]


raw_367 -> leaf_368
leaf_368  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If a pattern doesn't have a metatable, it's given a Node class and consists of
only the above fields, plus an array representing any subrules. 
"]
prose_353 -> { raw_369 literal_370 raw_371}
{rank=same; raw_369 literal_370 raw_371}

raw_369 [label="raw"]

literal_370 [label="literal"]

raw_371 [label="raw"]


raw_369 -> leaf_372
leaf_372  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If it does, the metatable will have a "]
literal_370 -> leaf_373
leaf_373  [color=Gray,shape=rectangle,fontname=Inconsolata,label="__call"]
raw_371 -> leaf_374
leaf_374  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" method, which expects two
parameters, itself, and the node, which will include the span. 
"]
prose_354 -> { raw_375 literal_376 raw_377}
{rank=same; raw_375 literal_376 raw_377}

raw_375 [label="raw"]

literal_376 [label="literal"]

raw_377 [label="raw"]


raw_375 -> leaf_378
leaf_378  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This will require reattunement of basically every class in the "]
literal_376 -> leaf_379
leaf_379  [color=Gray,shape=rectangle,fontname=Inconsolata,label="/grym"]
raw_377 -> leaf_380
leaf_380  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" folder,
but let's build the Prose parse first.  I do want the whole shebang in a single
grammar eventually.
"]
prose_355 -> { raw_381}
{rank=same; raw_381}

raw_381 [label="raw"]


raw_381 -> leaf_382
leaf_382  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The intention is to allow multiple grammars to coexist peacefully. Currently
the parser is handrolled and we have special case values for everything.
The idea is to stabilize this, so that multi-pass parsing works but in a
standard way where the Node constructor is a consistent interface. 
"]
prose_356 -> { raw_383}
{rank=same; raw_383}

raw_383 [label="raw"]


raw_383 -> leaf_384
leaf_384  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
In the meantime we have things like
"]
prose_357 -> { raw_385 literal_386 raw_387}
{rank=same; raw_385 literal_386 raw_387}

raw_385 [label="raw"]

literal_386 [label="literal"]

raw_387 [label="raw"]


raw_385 -> leaf_388
leaf_388  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- lines :  If this exists, there's a collection of lines which need to be
           joined with "]
literal_386 -> leaf_389
leaf_389  [color=Gray,shape=rectangle,fontname=Inconsolata,label="\\n"]
raw_387 -> leaf_390
leaf_390  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" to reconstruct the actual span.
"]
prose_358 -> { raw_391}
{rank=same; raw_391}

raw_391 [label="raw"]


raw_391 -> leaf_392
leaf_392  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
           We want to do this the other way, and use the span itself for the
           inner parse. 
"]
codeblock_359 -> leaf_393
leaf_393  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return Node"]

}
