digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 382"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-352"]


section_1 -> { header_2 prose_3 section_4 section_5 section_6 section_7 section_8}
{rank=same; header_2 prose_3 section_4 section_5 section_6 section_7 section_8}

header_2 [label="1 : Node"]

prose_3 [label="prose"]

section_4 [label="section: 8-16"]

section_5 [label="section: 17-28"]

section_6 [label="section: 29-40"]

section_7 [label="section: 41-330"]

section_8 [label="section: 353-372"]


header_2 -> leaf_9
leaf_9  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Node"]
prose_3 -> { raw_10}
{rank=same; raw_10}

raw_10 [label="raw"]


raw_10 -> leaf_11
leaf_11  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


  The Node class implements an abstract syntax tree, in collaboration with
the [[Grammar class][/grammar] and lpeg more generally.  

"]
section_4 -> { header_12 prose_13 codeblock_14}
{rank=same; header_12 prose_13 codeblock_14}

header_12 [label="3 : includes"]

prose_13 [label="prose"]

codeblock_14 [label="code block 10-14"]


header_12 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** includes"]
prose_13 -> { raw_16}
{rank=same; raw_16}

raw_16 [label="raw"]


raw_16 -> leaf_17
leaf_17  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_14 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local s = require \"status\" ()
local a = require \"ansi\"
local dot = require \"node/dot\""]
section_5 -> { header_19 prose_20 codeblock_21}
{rank=same; header_19 prose_20 codeblock_21}

header_19 [label="2 : Node metatable"]

prose_20 [label="prose"]

codeblock_21 [label="code block 22-26"]


header_19 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Node metatable"]
prose_20 -> { raw_23}
{rank=same; raw_23}

raw_23 [label="raw"]


raw_23 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  The Node metatable is the root table for any Node, all of which should
subclass through [[Node:inherit()][httk://]].
"]
codeblock_21 -> leaf_25
leaf_25  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local Node = {}
Node.__index = Node
Node.isNode = true"]
section_6 -> { header_26 prose_27 prose_28 prose_29}
{rank=same; header_26 prose_27 prose_28 prose_29}

header_26 [label="2 : Fields"]

prose_27 [label="prose"]

prose_28 [label="prose"]

prose_29 [label="prose"]


header_26 -> leaf_30
leaf_30  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Fields"]
prose_27 -> { raw_31}
{rank=same; raw_31}

raw_31 [label="raw"]


raw_31 -> leaf_32
leaf_32  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

   - id :  A string naming the Node. 
           This is identical to the name of the pattern that recognizes
           or captures it.
"]
prose_28 -> { raw_33}
{rank=same; raw_33}

raw_33 [label="raw"]


raw_33 -> leaf_34
leaf_34  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
           This is never set on Node itself, and Grammar will fail to
           produce a Node which lacks this flag. 
"]
prose_29 -> { raw_35 prespace_36 literal_37 raw_38}
{rank=same; raw_35 prespace_36 literal_37 raw_38}

raw_35 [label="raw"]

prespace_36 [label="prespace"]

literal_37 [label="literal"]

raw_38 [label="raw"]


raw_35 -> leaf_39
leaf_39  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
   - isNode :  A boolean, always"]
prespace_36 -> leaf_40
leaf_40  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_37 -> leaf_41
leaf_41  [color=Gray,shape=rectangle,fontname=Inconsolata,label="true"]
raw_38 -> leaf_42
leaf_42  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".

"]
section_7 -> { header_43 prose_44 section_45 section_46 section_47 section_48 section_49}
{rank=same; header_43 prose_44 section_45 section_46 section_47 section_48 section_49}

header_43 [label="2 : Methods"]

prose_44 [label="prose"]

section_45 [label="section: 44-57"]

section_46 [label="section: 58-97"]

section_47 [label="section: 98-295"]

section_48 [label="section: 313-330"]

section_49 [label="section: 331-333"]


header_43 -> leaf_50
leaf_50  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Methods"]
prose_44 -> { raw_51}
{rank=same; raw_51}

raw_51 [label="raw"]


raw_51 -> leaf_52
leaf_52  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

"]
section_45 -> { header_53 prose_54 prose_55 codeblock_56}
{rank=same; header_53 prose_54 prose_55 codeblock_56}

header_53 [label="4 : toLua"]

prose_54 [label="prose"]

prose_55 [label="prose"]

codeblock_56 [label="code block 51-55"]


header_53 -> leaf_57
leaf_57  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** toLua"]
prose_54 -> { raw_58}
{rank=same; raw_58}

raw_58 [label="raw"]


raw_58 -> leaf_59
leaf_59  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This is not a general method in any sense, it's here as a backstop
while I build out Clu. 
"]
prose_55 -> { raw_60}
{rank=same; raw_60}

raw_60 [label="raw"]


raw_60 -> leaf_61
leaf_61  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  - [ ] #todo remove
"]
codeblock_56 -> leaf_62
leaf_62  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.toLua(node)
  s:halt(\"No toLua method for \" .. node.id)
end"]
section_46 -> { header_63 prose_64 prose_65 codeblock_66}
{rank=same; header_63 prose_64 prose_65 codeblock_66}

header_63 [label="3 : Visualizer"]

prose_64 [label="prose"]

prose_65 [label="prose"]

codeblock_66 [label="code block 65-96"]


header_63 -> leaf_67
leaf_67  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Visualizer"]
prose_64 -> { raw_68}
{rank=same; raw_68}

raw_68 [label="raw"]


raw_68 -> leaf_69
leaf_69  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This gives us a nice, tree-shaped printout of an entire Node.
"]
prose_65 -> { raw_70}
{rank=same; raw_70}

raw_70 [label="raw"]


raw_70 -> leaf_71
leaf_71  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
We're less disciplined than we should be about up-assigning this to
inherited Node classes. 
"]
codeblock_66 -> leaf_72
leaf_72  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.toString(node, depth)
   local depth = depth or 0
   local phrase = \"\"
   phrase = (\"  \"):rep(depth) .. a.bright(node.id) .. \"    \"
      .. a.cyan(node.first) .. \"-\" .. a.cyan(node.last)
   if node[1] then
      local extra = \"    \"
      if Node.len(node) > 56 then
         --  Truncate in the middle
         local span = Node.span(node)
         local pre, post = string.sub(span, 1, 26), string.sub(span, -26, -1)
         extra = extra .. a.dim(pre) .. a.bright(\"………\") .. a.dim(post)
         extra = extra:gsub(\"\\n\", \"◼︎\")
      else
         extra = extra .. a.dim(Node.span(node):gsub(\"\\n\", \"◼︎\"))
      end
      phrase = phrase .. extra .. \"\\n\"
      for _,v in ipairs(node) do
         if (v.isNode) then
            phrase = phrase .. Node.toString(v, depth + 1)
         end
      end
   else
      local val = node.str:sub(node.first, node.last)
                          :gsub(\" \", a.clear() .. a.dim(\"_\") .. a.green())
      val = a.green(val)
      phrase = phrase .. \"    \" .. val  .. \"\\n\"
   end
   return phrase
end"]
section_47 -> { header_73 prose_74 section_75 section_76 section_77 section_78 section_79 section_80 section_81 section_82}
{rank=same; header_73 prose_74 section_75 section_76 section_77 section_78 section_79 section_80 section_81 section_82}

header_73 [label="3 : Metrics"]

prose_74 [label="prose"]

section_75 [label="section: 101-109"]

section_76 [label="section: 110-120"]

section_77 [label="section: 121-192"]

section_78 [label="section: 193-213"]

section_79 [label="section: 214-236"]

section_80 [label="section: 237-276"]

section_81 [label="section: 277-295"]

section_82 [label="section: 296-312"]


header_73 -> leaf_83
leaf_83  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Metrics"]
prose_74 -> { raw_84}
{rank=same; raw_84}

raw_84 [label="raw"]


raw_84 -> leaf_85
leaf_85  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

"]
section_75 -> { header_86 prose_87 codeblock_88}
{rank=same; header_86 prose_87 codeblock_88}

header_86 [label="4 : span"]

prose_87 [label="prose"]

codeblock_88 [label="code block 103-107"]


header_86 -> leaf_89
leaf_89  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** span"]
prose_87 -> { raw_90}
{rank=same; raw_90}

raw_90 [label="raw"]


raw_90 -> leaf_91
leaf_91  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_88 -> leaf_92
leaf_92  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.span(node)
   return string.sub(node.str, node.first, node.last)
end"]
section_76 -> { header_93 prose_94 codeblock_95}
{rank=same; header_93 prose_94 codeblock_95}

header_93 [label="4 : len"]

prose_94 [label="prose"]

codeblock_95 [label="code block 114-118"]


header_93 -> leaf_96
leaf_96  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** len"]
prose_94 -> { raw_97}
{rank=same; raw_97}

raw_97 [label="raw"]


raw_97 -> leaf_98
leaf_98  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

ahh, the pleasure of indexing by one. 
"]
codeblock_95 -> leaf_99
leaf_99  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.len(node)
    return 1 + node.last - node.first
end"]
section_77 -> { header_100 prose_101 prose_102 prose_103 prose_104 prose_105 codeblock_106 codeblock_107}
{rank=same; header_100 prose_101 prose_102 prose_103 prose_104 prose_105 codeblock_106 codeblock_107}

header_100 [label="4 : Node:gap(node)"]

prose_101 [label="prose"]

prose_102 [label="prose"]

prose_103 [label="prose"]

prose_104 [label="prose"]

prose_105 [label="prose"]

codeblock_106 [label="code block 140-160"]

codeblock_107 [label="code block 163-191"]


header_100 -> leaf_108
leaf_108  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node:gap(node)"]
prose_101 -> { raw_109 prespace_110 literal_111 raw_112 prespace_113 literal_114 raw_115 prespace_116 literal_117 raw_118 prespace_119 literal_120 raw_121 prespace_122 literal_123 raw_124 prespace_125 bold_126 raw_127}
{rank=same; raw_109 prespace_110 literal_111 raw_112 prespace_113 literal_114 raw_115 prespace_116 literal_117 raw_118 prespace_119 literal_120 raw_121 prespace_122 literal_123 raw_124 prespace_125 bold_126 raw_127}

raw_109 [label="raw"]

prespace_110 [label="prespace"]

literal_111 [label="literal"]

raw_112 [label="raw"]

prespace_113 [label="prespace"]

literal_114 [label="literal"]

raw_115 [label="raw"]

prespace_116 [label="prespace"]

literal_117 [label="literal"]

raw_118 [label="raw"]

prespace_119 [label="prespace"]

literal_120 [label="literal"]

raw_121 [label="raw"]

prespace_122 [label="prespace"]

literal_123 [label="literal"]

raw_124 [label="raw"]

prespace_125 [label="prespace"]

bold_126 [label="bold"]

raw_127 [label="raw"]


raw_109 -> leaf_128
leaf_128  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
prespace_110 -> leaf_129
leaf_129  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
literal_111 -> leaf_130
leaf_130  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Node.gap(left, right)"]
raw_112 -> leaf_131
leaf_131  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" compares the"]
prespace_113 -> leaf_132
leaf_132  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_114 -> leaf_133
leaf_133  [color=Gray,shape=rectangle,fontname=Inconsolata,label="last"]
raw_115 -> leaf_134
leaf_134  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" field of the"]
prespace_116 -> leaf_135
leaf_135  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_117 -> leaf_136
leaf_136  [color=Gray,shape=rectangle,fontname=Inconsolata,label="left"]
raw_118 -> leaf_137
leaf_137  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" parameter
with the"]
prespace_119 -> leaf_138
leaf_138  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_120 -> leaf_139
leaf_139  [color=Gray,shape=rectangle,fontname=Inconsolata,label="first"]
raw_121 -> leaf_140
leaf_140  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" field of the"]
prespace_122 -> leaf_141
leaf_141  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_123 -> leaf_142
leaf_142  [color=Gray,shape=rectangle,fontname=Inconsolata,label="right"]
raw_124 -> leaf_143
leaf_143  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" parameter,"]
prespace_125 -> leaf_144
leaf_144  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
bold_126 -> leaf_145
leaf_145  [color=Gray,shape=rectangle,fontname=Inconsolata,label="if"]
raw_127 -> leaf_146
leaf_146  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" this is greater than
0. 
"]
prose_102 -> { raw_147 prespace_148 literal_149 raw_150 prespace_151 literal_152 raw_153 prespace_154 literal_155 raw_156 prespace_157 literal_158 raw_159 prespace_160 literal_161 raw_162}
{rank=same; raw_147 prespace_148 literal_149 raw_150 prespace_151 literal_152 raw_153 prespace_154 literal_155 raw_156 prespace_157 literal_158 raw_159 prespace_160 literal_161 raw_162}

raw_147 [label="raw"]

prespace_148 [label="prespace"]

literal_149 [label="literal"]

raw_150 [label="raw"]

prespace_151 [label="prespace"]

literal_152 [label="literal"]

raw_153 [label="raw"]

prespace_154 [label="prespace"]

literal_155 [label="literal"]

raw_156 [label="raw"]

prespace_157 [label="prespace"]

literal_158 [label="literal"]

raw_159 [label="raw"]

prespace_160 [label="prespace"]

literal_161 [label="literal"]

raw_162 [label="raw"]


raw_147 -> leaf_163
leaf_163  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If it is negative,"]
prespace_148 -> leaf_164
leaf_164  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_149 -> leaf_165
leaf_165  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Node.gap"]
raw_150 -> leaf_166
leaf_166  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" attempts to measure the"]
prespace_151 -> leaf_167
leaf_167  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_152 -> leaf_168
leaf_168  [color=Gray,shape=rectangle,fontname=Inconsolata,label="first"]
raw_153 -> leaf_169
leaf_169  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" field of the"]
prespace_154 -> leaf_170
leaf_170  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
literal_155 -> leaf_171
leaf_171  [color=Gray,shape=rectangle,fontname=Inconsolata,label="right"]
raw_156 -> leaf_172
leaf_172  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" parameter against the"]
prespace_157 -> leaf_173
leaf_173  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_158 -> leaf_174
leaf_174  [color=Gray,shape=rectangle,fontname=Inconsolata,label="last"]
raw_159 -> leaf_175
leaf_175  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" field of the"]
prespace_160 -> leaf_176
leaf_176  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_161 -> leaf_177
leaf_177  [color=Gray,shape=rectangle,fontname=Inconsolata,label="left"]
raw_162 -> leaf_178
leaf_178  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" parameter.
"]
prose_103 -> { raw_179 prespace_180 bold_181 raw_182}
{rank=same; raw_179 prespace_180 bold_181 raw_182}

raw_179 [label="raw"]

prespace_180 [label="prespace"]

bold_181 [label="bold"]

raw_182 [label="raw"]


raw_179 -> leaf_183
leaf_183  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If this is a natural number we return the"]
prespace_180 -> leaf_184
leaf_184  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
bold_181 -> leaf_185
leaf_185  [color=Gray,shape=rectangle,fontname=Inconsolata,label="negation"]
raw_182 -> leaf_186
leaf_186  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" of this value.  If both
should prove to be positive, we halt. 
"]
prose_104 -> { raw_187 prespace_188 literal_189 raw_190}
{rank=same; raw_187 prespace_188 literal_189 raw_190}

raw_187 [label="raw"]

prespace_188 [label="prespace"]

literal_189 [label="literal"]

raw_190 [label="raw"]


raw_187 -> leaf_191
leaf_191  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
No effort is made to check that the"]
prespace_188 -> leaf_192
leaf_192  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_189 -> leaf_193
leaf_193  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str"]
raw_190 -> leaf_194
leaf_194  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" field matches between nodes unless
we have an error, in which case it could prove helpful for diagnosis.  
"]
prose_105 -> { raw_195}
{rank=same; raw_195}

raw_195 [label="raw"]


raw_195 -> leaf_196
leaf_196  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Indeed such a check would be a disaster in streams or other sort of
piecewise parse.  Which will require implementation in and of itself, but
in the meantime...
"]
codeblock_106 -> leaf_197
leaf_197  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.gap(left, right)
  assert(left.last, \"no left.last\")
  assert(right.first, \"no right.first\")
  assert(right.last, \"no right.last\")
  assert(left.first, \"no left.first\")
  if left.first >= right.last then
    local left, right = right, left
  elseif left.last > right.first then
    s:halt(\"overlapping regions or str issue\")
  end
  local gap = left
  if gap >= 0 then
    return gap
  else
    s:halt(\"some kind of situation where gap is \" .. tostring(gap))
  end

  return nil 
end"]
codeblock_107 -> leaf_198
leaf_198  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.dotLabel(node)
  return node.id
end

function Node.toMarkdown(node)
  if not node[1] then
    return string.sub(node.str, node.first, node.last)
  else
    s:halt(\"no toMarkdown for \" .. node.id)
  end
end

function Node.dot(node)
  return dot.dot(node)
end

function Node.toValue(node)
  if node.__VALUE then
    return node.__VALUE
  end
  if node.str then
    return node.str:sub(node.first,node.last)
  else
    s:halt(\"no str on node \" .. node.id)
  end
end
"]
section_78 -> { header_199 prose_200 codeblock_201}
{rank=same; header_199 prose_200 codeblock_201}

header_199 [label="4 : Node.walkPost"]

prose_200 [label="prose"]

codeblock_201 [label="code block 197-212"]


header_199 -> leaf_202
leaf_202  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.walkPost"]
prose_200 -> { raw_203}
{rank=same; raw_203}

raw_203 [label="raw"]


raw_203 -> leaf_204
leaf_204  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Depth-first iterator, postfix 
"]
codeblock_201 -> leaf_205
leaf_205  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.walkPost(node)
    local function traverse(ast)
        if not ast.isNode then return nil end

        for _, v in ipairs(ast) do
            if type(v) == 'table' and v.isNode then
              traverse(v)
            end
        end
        coroutine.yield(ast)
    end

    return coroutine.wrap(function() traverse(node) end)
end"]
section_79 -> { header_206 prose_207 codeblock_208}
{rank=same; header_206 prose_207 codeblock_208}

header_206 [label="4 : Node.walk"]

prose_207 [label="prose"]

codeblock_208 [label="code block 218-234"]


header_206 -> leaf_209
leaf_209  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.walk"]
prose_207 -> { raw_210}
{rank=same; raw_210}

raw_210 [label="raw"]


raw_210 -> leaf_211
leaf_211  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Presearch iterator.  This is the default. 
"]
codeblock_208 -> leaf_212
leaf_212  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.walk(node)
  local function traverse(ast)
    if not ast.isNode then return nil end

    coroutine.yield(ast)
    for _, v in ipairs(ast) do
      if type(v) == 'table' and v.isNode then
        traverse(v)
      end
    end
  end

  return coroutine.wrap(function() traverse(node) end)
end
"]
section_80 -> { header_213 prose_214 codeblock_215}
{rank=same; header_213 prose_214 codeblock_215}

header_213 [label="4 : Node.select(node, pred)"]

prose_214 [label="prose"]

codeblock_215 [label="code block 243-274"]


header_213 -> leaf_216
leaf_216  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.select(node, pred)"]
prose_214 -> { raw_217 prespace_218 literal_219 raw_220 prespace_221 literal_222 raw_223}
{rank=same; raw_217 prespace_218 literal_219 raw_220 prespace_221 literal_222 raw_223}

raw_217 [label="raw"]

prespace_218 [label="prespace"]

literal_219 [label="literal"]

raw_220 [label="raw"]

prespace_221 [label="prespace"]

literal_222 [label="literal"]

raw_223 [label="raw"]


raw_217 -> leaf_224
leaf_224  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Takes the Node and walks it, yielding the Nodes which match the predicate."]
prespace_218 -> leaf_225
leaf_225  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
literal_219 -> leaf_226
leaf_226  [color=Gray,shape=rectangle,fontname=Inconsolata,label="pred"]
raw_220 -> leaf_227
leaf_227  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is either a string, which matches to"]
prespace_221 -> leaf_228
leaf_228  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_222 -> leaf_229
leaf_229  [color=Gray,shape=rectangle,fontname=Inconsolata,label="id"]
raw_223 -> leaf_230
leaf_230  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", or a function, which takes
a Node and returns true or false on some premise. 
"]
codeblock_215 -> leaf_231
leaf_231  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.select(node, pred)
   local function qualifies(node, pred)
      if type(pred) == 'string' then
         if type(node) == 'table' 
          and node.id and node.id == pred then
            return true
         else
            return false
         end
      elseif type(pred) == 'function' then
         return pred(node)
      else
         s:halt(\"cannot select on predicate of type \" .. type(pred))
      end
   end

   local function traverse(ast)
      -- breadth first
      if qualifies(ast, pred) then
         coroutine.yield(ast)
      end
      if ast.isNode then
         for _, v in ipairs(ast) do
            traverse(v)
         end
      end
   end

   return coroutine.wrap(function() traverse(node) end)
end"]
section_81 -> { header_232 prose_233 codeblock_234}
{rank=same; header_232 prose_233 codeblock_234}

header_232 [label="4 : Node.tokens(node)"]

prose_233 [label="prose"]

codeblock_234 [label="code block 281-293"]


header_232 -> leaf_235
leaf_235  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.tokens(node)"]
prose_233 -> { raw_236}
{rank=same; raw_236}

raw_236 [label="raw"]


raw_236 -> leaf_237
leaf_237  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Iterator returning all captured values as strings.
"]
codeblock_234 -> leaf_238
leaf_238  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.tokens(node)
  local function traverse(ast)
    for node in Node.walk(ast) do
      if not node[1] then
        coroutine.yield(node:toValue())
      end
    end
  end

  return coroutine.wrap(function() traverse(node) end)
end  "]
section_82 -> { header_239 prose_240 prose_241 codeblock_242}
{rank=same; header_239 prose_240 prose_241 codeblock_242}

header_239 [label="4 : Node.lastLeaf(node)"]

prose_240 [label="prose"]

prose_241 [label="prose"]

codeblock_242 [label="code block 302-310"]


header_239 -> leaf_243
leaf_243  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.lastLeaf(node)"]
prose_240 -> { raw_244}
{rank=same; raw_244}

raw_244 [label="raw"]


raw_244 -> leaf_245
leaf_245  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Returns the last leaf of the node.
"]
prose_241 -> { raw_246}
{rank=same; raw_246}

raw_246 [label="raw"]


raw_246 -> leaf_247
leaf_247  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Useful to check for terminal errors, for stop-on-error parsing. 
"]
codeblock_242 -> leaf_248
leaf_248  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.lastLeaf(node)
  if #node == 0 then 
    return node
  else
    return Node.lastLeaf(node[#node])
  end
end"]
section_48 -> { header_249 prose_250 prose_251 codeblock_252}
{rank=same; header_249 prose_250 prose_251 codeblock_252}

header_249 [label="3 : Collectors"]

prose_250 [label="prose"]

prose_251 [label="prose"]

codeblock_252 [label="code block 320-329"]


header_249 -> leaf_253
leaf_253  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Collectors"]
prose_250 -> { raw_254}
{rank=same; raw_254}

raw_254 [label="raw"]


raw_254 -> leaf_255
leaf_255  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

These return an array of all results. 
"]
prose_251 -> { raw_256}
{rank=same; raw_256}

raw_256 [label="raw"]


raw_256 -> leaf_257
leaf_257  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- [ ] #todo  Add a Forest class to provide the iterator interface for
             the return arrays of this class.
"]
codeblock_252 -> leaf_258
leaf_258  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.gather(node, pred)
  local gathered = {}
  for ast in node:select(pred) do
    gathered[#gathered + 1] = ast
  end
  
  return gathered
end"]
section_49 -> { header_259 prose_260 section_261}
{rank=same; header_259 prose_260 section_261}

header_259 [label="3 : Subclassing and construction"]

prose_260 [label="prose"]

section_261 [label="section: 334-352"]


header_259 -> leaf_262
leaf_262  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Subclassing and construction"]
prose_260 -> { raw_263}
{rank=same; raw_263}

raw_263 [label="raw"]


raw_263 -> leaf_264
leaf_264  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

"]
section_261 -> { header_265 prose_266 codeblock_267}
{rank=same; header_265 prose_266 codeblock_267}

header_265 [label="4 : N.inherit(node)"]

prose_266 [label="prose"]

codeblock_267 [label="code block 336-350"]


header_265 -> leaf_268
leaf_268  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** N.inherit(node)"]
prose_266 -> { raw_269}
{rank=same; raw_269}

raw_269 [label="raw"]


raw_269 -> leaf_270
leaf_270  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_267 -> leaf_271
leaf_271  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.inherit(node)
  local Meta = setmetatable({}, node)
  Meta.__index = Meta
  local meta = setmetatable({}, Meta)
  meta.__index = meta
  return Meta, meta
end

function Node.export(_, mod, constructor)
  mod.__call = constructor
  return setmetatable({}, mod)
end
"]
section_8 -> { header_272 prose_273 prose_274 prose_275 section_276 section_277}
{rank=same; header_272 prose_273 prose_274 prose_275 section_276 section_277}

header_272 [label="2 : Node Instances"]

prose_273 [label="prose"]

prose_274 [label="prose"]

prose_275 [label="prose"]

section_276 [label="section: 364-372"]

section_277 [label="section: 373-382"]


header_272 -> leaf_278
leaf_278  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Node Instances"]
prose_273 -> { raw_279}
{rank=same; raw_279}

raw_279 [label="raw"]


raw_279 -> leaf_280
leaf_280  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  To be a Node, indexed elements of the Array portion must also be 
Nodes. 
"]
prose_274 -> { raw_281}
{rank=same; raw_281}

raw_281 [label="raw"]


raw_281 -> leaf_282
leaf_282  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If there are no children of the Node, it is considered to be a leaf node.
"]
prose_275 -> { raw_283}
{rank=same; raw_283}

raw_283 [label="raw"]


raw_283 -> leaf_284
leaf_284  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Most of the Node library will fail to halt, and probably blow stack, if
cyclic Node graphs are made.  The Grammar class will not do this to you. 

"]
section_276 -> { header_285 prose_286}
{rank=same; header_285 prose_286}

header_285 [label="3 : Fields"]

prose_286 [label="prose"]


header_285 -> leaf_287
leaf_287  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Fields"]
prose_286 -> { raw_288 prespace_289 literal_290 raw_291 prespace_292 literal_293 raw_294}
{rank=same; raw_288 prespace_289 literal_290 raw_291 prespace_292 literal_293 raw_294}

raw_288 [label="raw"]

prespace_289 [label="prespace"]

literal_290 [label="literal"]

raw_291 [label="raw"]

prespace_292 [label="prespace"]

literal_293 [label="literal"]

raw_294 [label="raw"]


raw_288 -> leaf_295
leaf_295  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  There are invariant fields a Node is also expected to have, they are:
 
  - first :  Index into"]
prespace_289 -> leaf_296
leaf_296  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_290 -> leaf_297
leaf_297  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str"]
raw_291 -> leaf_298
leaf_298  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" which begins the span.
  - last  :  Index into"]
prespace_292 -> leaf_299
leaf_299  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_293 -> leaf_300
leaf_300  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str"]
raw_294 -> leaf_301
leaf_301  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" which ends the span.
  - str   :  The string of which the Node spans part or the whole.

"]
section_277 -> { header_302 prose_303 codeblock_304}
{rank=same; header_302 prose_303 codeblock_304}

header_302 [label="3 : Other fields"]

prose_303 [label="prose"]

codeblock_304 [label="code block 377-379"]


header_302 -> leaf_305
leaf_305  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Other fields"]
prose_303 -> { raw_306}
{rank=same; raw_306}

raw_306 [label="raw"]


raw_306 -> leaf_307
leaf_307  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  In principle, anything at all. 
"]
codeblock_304 -> leaf_308
leaf_308  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return Node"]

}
