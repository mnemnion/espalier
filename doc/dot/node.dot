digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 455"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-360"]


section_1 -> { header_2 prose_3 section_4 section_5 section_6 section_7 section_8}
{rank=same; header_2 prose_3 section_4 section_5 section_6 section_7 section_8}

header_2 [label="1 : Node"]

prose_3 [label="prose"]

section_4 [label="section: 6-13"]

section_5 [label="section: 14-27"]

section_6 [label="section: 28-44"]

section_7 [label="section: 45-339"]

section_8 [label="section: 361-420"]


header_2 -> leaf_9
leaf_9  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Node"]
prose_3 -> { raw_10}
{rank=same; raw_10}

raw_10 [label="raw"]


raw_10 -> leaf_11
leaf_11  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


  Time to stabilize this class once and for all. 
"]
section_4 -> { header_12 prose_13 codeblock_14}
{rank=same; header_12 prose_13 codeblock_14}

header_12 [label="3 : includes"]

prose_13 [label="prose"]

codeblock_14 [label="code block 8-12"]


header_12 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** includes"]
prose_13 -> { raw_16}
{rank=same; raw_16}

raw_16 [label="raw"]


raw_16 -> leaf_17
leaf_17  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_14 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local s = require \"status\" ()
local a = require \"ansi\"
local dot = require \"node/dot\""]
section_5 -> { header_19 prose_20 codeblock_21}
{rank=same; header_19 prose_20 codeblock_21}

header_19 [label="2 : Node metatable"]

prose_20 [label="prose"]

codeblock_21 [label="code block 20-24"]


header_19 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Node metatable"]
prose_20 -> { raw_23 prespace_24 literal_25 raw_26}
{rank=same; raw_23 prespace_24 literal_25 raw_26}

raw_23 [label="raw"]

prespace_24 [label="prespace"]

literal_25 [label="literal"]

raw_26 [label="raw"]


raw_23 -> leaf_27
leaf_27  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  The Node metatable is the root table for any Node.  I'm planning to make
an intermediate class/table called Root that is in common for any instance
Node.  All Root absolutely has to contain is"]
prespace_24 -> leaf_28
leaf_28  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_25 -> leaf_29
leaf_29  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str"]
raw_26 -> leaf_30
leaf_30  [color=Gray,shape=rectangle,fontname=Inconsolata,label=". 
"]
codeblock_21 -> leaf_31
leaf_31  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local Node = {}
Node.__index = Node
Node.isNode = true"]
section_6 -> { header_32 prose_33 prose_34 codeblock_35 prose_36}
{rank=same; header_32 prose_33 prose_34 codeblock_35 prose_36}

header_32 [label="2 : Fields"]

prose_33 [label="prose"]

prose_34 [label="prose"]

codeblock_35 [label="code block 37-40"]

prose_36 [label="prose"]


header_32 -> leaf_37
leaf_37  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Fields"]
prose_33 -> { raw_38}
{rank=same; raw_38}

raw_38 [label="raw"]


raw_38 -> leaf_39
leaf_39  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

   - id :  A string naming the Node. 
           This is identical to the name of the pattern that recognizes
           or captures it.
"]
prose_34 -> { raw_40}
{rank=same; raw_40}

raw_40 [label="raw"]


raw_40 -> leaf_41
leaf_41  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
   - line_first :  Always -1. #deprecated
   - line_last  :  Always -1. #deprecated
"]
codeblock_35 -> leaf_42
leaf_42  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Node.line_first = -1
Node.line_last  = -1"]
prose_36 -> { raw_43 link_44 raw_45}
{rank=same; raw_43 link_44 raw_45}

raw_43 [label="raw"]

link_44 [label="link"]

raw_45 [label="raw"]


raw_43 -> leaf_46
leaf_46  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
It occurs to me we could lazily calculate these using the "]
link_44 -> { anchortext_47 url_48}
{rank=same; anchortext_47 url_48}

anchortext_47 [label="anchortext"]

url_48 [label="url"]


anchortext_47 -> leaf_49
leaf_49  [color=Gray,shape=rectangle,fontname=Inconsolata,label="line iterator"]
url_48 -> leaf_50
leaf_50  [color=Gray,shape=rectangle,fontname=Inconsolata,label="httk://"]
raw_45 -> leaf_51
leaf_51  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".

"]
section_7 -> { header_52 prose_53 section_54 section_55 section_56 section_57 section_58}
{rank=same; header_52 prose_53 section_54 section_55 section_56 section_57 section_58}

header_52 [label="2 : Methods"]

prose_53 [label="prose"]

section_54 [label="section: 47-48"]

section_55 [label="section: 61-99"]

section_56 [label="section: 100-297"]

section_57 [label="section: 322-339"]

section_58 [label="section: 340-342"]


header_52 -> leaf_59
leaf_59  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Methods"]
prose_53 -> { raw_60}
{rank=same; raw_60}

raw_60 [label="raw"]


raw_60 -> leaf_61
leaf_61  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
section_54 -> { header_62 prose_63 section_64}
{rank=same; header_62 prose_63 section_64}

header_62 [label="3 : Scaffolding "]

prose_63 [label="prose"]

section_64 [label="section: 49-60"]


header_62 -> leaf_65
leaf_65  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Scaffolding "]
prose_63 -> { raw_66}
{rank=same; raw_66}

raw_66 [label="raw"]


raw_66 -> leaf_67
leaf_67  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
section_64 -> { header_68 prose_69 codeblock_70}
{rank=same; header_68 prose_69 codeblock_70}

header_68 [label="4 : toLua"]

prose_69 [label="prose"]

codeblock_70 [label="code block 54-58"]


header_68 -> leaf_71
leaf_71  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** toLua"]
prose_69 -> { raw_72}
{rank=same; raw_72}

raw_72 [label="raw"]


raw_72 -> leaf_73
leaf_73  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This is not a general method in any sense, it's here as a backstop
while I build out Clu. 
"]
codeblock_70 -> leaf_74
leaf_74  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.toLua(node)
  s:halt(\"No toLua method for \" .. node.id)
end"]
section_55 -> { header_75 prose_76 prose_77 codeblock_78}
{rank=same; header_75 prose_76 prose_77 codeblock_78}

header_75 [label="3 : Visualizer"]

prose_76 [label="prose"]

prose_77 [label="prose"]

codeblock_78 [label="code block 68-98"]


header_75 -> leaf_79
leaf_79  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Visualizer"]
prose_76 -> { raw_80}
{rank=same; raw_80}

raw_80 [label="raw"]


raw_80 -> leaf_81
leaf_81  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This gives us a nice, tree-shaped printout of an entire Node.
"]
prose_77 -> { raw_82}
{rank=same; raw_82}

raw_82 [label="raw"]


raw_82 -> leaf_83
leaf_83  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
We're less disciplined than we should be about up-assigning this to
inherited Node classes. 
"]
codeblock_78 -> leaf_84
leaf_84  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.toString(node, depth)
   local depth = depth or 0
   local phrase = \"\"
   phrase = (\"  \"):rep(depth) .. a.bright(node.id) .. \"    \"
      .. a.cyan(node.first) .. \"-\" .. a.cyan(node.last)
   if node[1] then
      local extra = \"    \"
      if Node.len(node) > 56 then
         local span = Node.span(node)
         local pre, post = string.sub(span, 1, 28), string.sub(span, -28, -1)
         extra = extra .. a.dim(pre) .. a.bright(\"…\") .. a.dim(post)
         extra = extra:gsub(\"\\n\", \"◼︎\")
      else
         extra = extra .. a.dim(Node.span(node):gsub(\"\\n\", \"◼︎\"))
      end
      phrase = phrase .. extra .. \"\\n\"
      for _,v in ipairs(node) do
         if (v.isNode) then
            phrase = phrase .. Node.toString(v, depth + 1)
         end
      end
   else
      local val = node.str:sub(node.first, node.last)
                          :gsub(\" \", a.clear() .. a.dim(\"_\") .. a.green())
      val = a.green(val)
      phrase = phrase .. \"    \" .. val  .. \"\\n\"
   end
   return phrase
end"]
section_56 -> { header_85 prose_86 section_87 section_88 section_89 section_90 section_91 section_92 section_93 section_94}
{rank=same; header_85 prose_86 section_87 section_88 section_89 section_90 section_91 section_92 section_93 section_94}

header_85 [label="3 : Metrics"]

prose_86 [label="prose"]

section_87 [label="section: 103-111"]

section_88 [label="section: 112-122"]

section_89 [label="section: 123-194"]

section_90 [label="section: 195-215"]

section_91 [label="section: 216-238"]

section_92 [label="section: 239-278"]

section_93 [label="section: 279-297"]

section_94 [label="section: 298-321"]


header_85 -> leaf_95
leaf_95  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Metrics"]
prose_86 -> { raw_96}
{rank=same; raw_96}

raw_96 [label="raw"]


raw_96 -> leaf_97
leaf_97  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

"]
section_87 -> { header_98 prose_99 codeblock_100}
{rank=same; header_98 prose_99 codeblock_100}

header_98 [label="4 : span"]

prose_99 [label="prose"]

codeblock_100 [label="code block 105-109"]


header_98 -> leaf_101
leaf_101  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** span"]
prose_99 -> { raw_102}
{rank=same; raw_102}

raw_102 [label="raw"]


raw_102 -> leaf_103
leaf_103  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_100 -> leaf_104
leaf_104  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.span(node)
   return string.sub(node.str, node.first, node.last)
end"]
section_88 -> { header_105 prose_106 codeblock_107}
{rank=same; header_105 prose_106 codeblock_107}

header_105 [label="4 : len"]

prose_106 [label="prose"]

codeblock_107 [label="code block 116-120"]


header_105 -> leaf_108
leaf_108  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** len"]
prose_106 -> { raw_109}
{rank=same; raw_109}

raw_109 [label="raw"]


raw_109 -> leaf_110
leaf_110  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

ahh, the pleasure of indexing by one. 
"]
codeblock_107 -> leaf_111
leaf_111  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.len(node)
    return 1 + node.last - node.first
end"]
section_89 -> { header_112 prose_113 prose_114 prose_115 prose_116 prose_117 codeblock_118 codeblock_119}
{rank=same; header_112 prose_113 prose_114 prose_115 prose_116 prose_117 codeblock_118 codeblock_119}

header_112 [label="4 : Node:gap(node)"]

prose_113 [label="prose"]

prose_114 [label="prose"]

prose_115 [label="prose"]

prose_116 [label="prose"]

prose_117 [label="prose"]

codeblock_118 [label="code block 142-162"]

codeblock_119 [label="code block 165-193"]


header_112 -> leaf_120
leaf_120  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node:gap(node)"]
prose_113 -> { raw_121 prespace_122 literal_123 raw_124 prespace_125 literal_126 raw_127 prespace_128 literal_129 raw_130 prespace_131 literal_132 raw_133 prespace_134 literal_135 raw_136 prespace_137 bold_138 raw_139}
{rank=same; raw_121 prespace_122 literal_123 raw_124 prespace_125 literal_126 raw_127 prespace_128 literal_129 raw_130 prespace_131 literal_132 raw_133 prespace_134 literal_135 raw_136 prespace_137 bold_138 raw_139}

raw_121 [label="raw"]

prespace_122 [label="prespace"]

literal_123 [label="literal"]

raw_124 [label="raw"]

prespace_125 [label="prespace"]

literal_126 [label="literal"]

raw_127 [label="raw"]

prespace_128 [label="prespace"]

literal_129 [label="literal"]

raw_130 [label="raw"]

prespace_131 [label="prespace"]

literal_132 [label="literal"]

raw_133 [label="raw"]

prespace_134 [label="prespace"]

literal_135 [label="literal"]

raw_136 [label="raw"]

prespace_137 [label="prespace"]

bold_138 [label="bold"]

raw_139 [label="raw"]


raw_121 -> leaf_140
leaf_140  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
prespace_122 -> leaf_141
leaf_141  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
literal_123 -> leaf_142
leaf_142  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Node.gap(left, right)"]
raw_124 -> leaf_143
leaf_143  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" compares the"]
prespace_125 -> leaf_144
leaf_144  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_126 -> leaf_145
leaf_145  [color=Gray,shape=rectangle,fontname=Inconsolata,label="last"]
raw_127 -> leaf_146
leaf_146  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" field of the"]
prespace_128 -> leaf_147
leaf_147  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_129 -> leaf_148
leaf_148  [color=Gray,shape=rectangle,fontname=Inconsolata,label="left"]
raw_130 -> leaf_149
leaf_149  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" parameter
with the"]
prespace_131 -> leaf_150
leaf_150  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_132 -> leaf_151
leaf_151  [color=Gray,shape=rectangle,fontname=Inconsolata,label="first"]
raw_133 -> leaf_152
leaf_152  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" field of the"]
prespace_134 -> leaf_153
leaf_153  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_135 -> leaf_154
leaf_154  [color=Gray,shape=rectangle,fontname=Inconsolata,label="right"]
raw_136 -> leaf_155
leaf_155  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" parameter,"]
prespace_137 -> leaf_156
leaf_156  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
bold_138 -> leaf_157
leaf_157  [color=Gray,shape=rectangle,fontname=Inconsolata,label="if"]
raw_139 -> leaf_158
leaf_158  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" this is greater than
0. 
"]
prose_114 -> { raw_159 prespace_160 literal_161 raw_162 prespace_163 literal_164 raw_165 prespace_166 literal_167 raw_168 prespace_169 literal_170 raw_171 prespace_172 literal_173 raw_174}
{rank=same; raw_159 prespace_160 literal_161 raw_162 prespace_163 literal_164 raw_165 prespace_166 literal_167 raw_168 prespace_169 literal_170 raw_171 prespace_172 literal_173 raw_174}

raw_159 [label="raw"]

prespace_160 [label="prespace"]

literal_161 [label="literal"]

raw_162 [label="raw"]

prespace_163 [label="prespace"]

literal_164 [label="literal"]

raw_165 [label="raw"]

prespace_166 [label="prespace"]

literal_167 [label="literal"]

raw_168 [label="raw"]

prespace_169 [label="prespace"]

literal_170 [label="literal"]

raw_171 [label="raw"]

prespace_172 [label="prespace"]

literal_173 [label="literal"]

raw_174 [label="raw"]


raw_159 -> leaf_175
leaf_175  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If it is negative,"]
prespace_160 -> leaf_176
leaf_176  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_161 -> leaf_177
leaf_177  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Node.gap"]
raw_162 -> leaf_178
leaf_178  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" attempts to measure the"]
prespace_163 -> leaf_179
leaf_179  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_164 -> leaf_180
leaf_180  [color=Gray,shape=rectangle,fontname=Inconsolata,label="first"]
raw_165 -> leaf_181
leaf_181  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" field of the"]
prespace_166 -> leaf_182
leaf_182  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
literal_167 -> leaf_183
leaf_183  [color=Gray,shape=rectangle,fontname=Inconsolata,label="right"]
raw_168 -> leaf_184
leaf_184  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" parameter against the"]
prespace_169 -> leaf_185
leaf_185  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_170 -> leaf_186
leaf_186  [color=Gray,shape=rectangle,fontname=Inconsolata,label="last"]
raw_171 -> leaf_187
leaf_187  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" field of the"]
prespace_172 -> leaf_188
leaf_188  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_173 -> leaf_189
leaf_189  [color=Gray,shape=rectangle,fontname=Inconsolata,label="left"]
raw_174 -> leaf_190
leaf_190  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" parameter.
"]
prose_115 -> { raw_191 prespace_192 bold_193 raw_194}
{rank=same; raw_191 prespace_192 bold_193 raw_194}

raw_191 [label="raw"]

prespace_192 [label="prespace"]

bold_193 [label="bold"]

raw_194 [label="raw"]


raw_191 -> leaf_195
leaf_195  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If this is a natural number we return the"]
prespace_192 -> leaf_196
leaf_196  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
bold_193 -> leaf_197
leaf_197  [color=Gray,shape=rectangle,fontname=Inconsolata,label="negation"]
raw_194 -> leaf_198
leaf_198  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" of this value.  If both
should prove to be positive, we halt. 
"]
prose_116 -> { raw_199 prespace_200 literal_201 raw_202}
{rank=same; raw_199 prespace_200 literal_201 raw_202}

raw_199 [label="raw"]

prespace_200 [label="prespace"]

literal_201 [label="literal"]

raw_202 [label="raw"]


raw_199 -> leaf_203
leaf_203  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
No effort is made to check that the"]
prespace_200 -> leaf_204
leaf_204  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_201 -> leaf_205
leaf_205  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str"]
raw_202 -> leaf_206
leaf_206  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" field matches between nodes unless
we have an error, in which case it could prove helpful for diagnosis.  
"]
prose_117 -> { raw_207}
{rank=same; raw_207}

raw_207 [label="raw"]


raw_207 -> leaf_208
leaf_208  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Indeed such a check would be a disaster in streams or other sort of
piecewise parse.  Which will require implementation in and of itself, but
in the meantime...
"]
codeblock_118 -> leaf_209
leaf_209  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.gap(left, right)
  assert(left.last, \"no left.last\")
  assert(right.first, \"no right.first\")
  assert(right.last, \"no right.last\")
  assert(left.first, \"no left.first\")
  if left.first >= right.last then
    local left, right = right, left
  elseif left.last > right.first then
    s:halt(\"overlapping regions or str issue\")
  end
  local gap = left
  if gap >= 0 then
    return gap
  else
    s:halt(\"some kind of situation where gap is \" .. tostring(gap))
  end

  return nil 
end"]
codeblock_119 -> leaf_210
leaf_210  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.dotLabel(node)
  return node.id
end

function Node.toMarkdown(node)
  if not node[1] then
    return string.sub(node.str, node.first, node.last)
  else
    s:halt(\"no toMarkdown for \" .. node.id)
  end
end

function Node.dot(node)
  return dot.dot(node)
end

function Node.toValue(node)
  if node.__VALUE then
    return node.__VALUE
  end
  if node.str then
    return node.str:sub(node.first,node.last)
  else
    s:halt(\"no str on node \" .. node.id)
  end
end
"]
section_90 -> { header_211 prose_212 codeblock_213}
{rank=same; header_211 prose_212 codeblock_213}

header_211 [label="4 : Node.walkPost"]

prose_212 [label="prose"]

codeblock_213 [label="code block 199-214"]


header_211 -> leaf_214
leaf_214  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.walkPost"]
prose_212 -> { raw_215}
{rank=same; raw_215}

raw_215 [label="raw"]


raw_215 -> leaf_216
leaf_216  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Depth-first iterator, postfix 
"]
codeblock_213 -> leaf_217
leaf_217  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.walkPost(node)
    local function traverse(ast)
        if not ast.isNode then return nil end

        for _, v in ipairs(ast) do
            if type(v) == 'table' and v.isNode then
              traverse(v)
            end
        end
        coroutine.yield(ast)
    end

    return coroutine.wrap(function() traverse(node) end)
end"]
section_91 -> { header_218 prose_219 codeblock_220}
{rank=same; header_218 prose_219 codeblock_220}

header_218 [label="4 : Node.walk"]

prose_219 [label="prose"]

codeblock_220 [label="code block 220-236"]


header_218 -> leaf_221
leaf_221  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.walk"]
prose_219 -> { raw_222}
{rank=same; raw_222}

raw_222 [label="raw"]


raw_222 -> leaf_223
leaf_223  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Presearch iterator.  This is the default. 
"]
codeblock_220 -> leaf_224
leaf_224  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.walk(node)
  local function traverse(ast)
    if not ast.isNode then return nil end

    coroutine.yield(ast)
    for _, v in ipairs(ast) do
      if type(v) == 'table' and v.isNode then
        traverse(v)
      end
    end
  end

  return coroutine.wrap(function() traverse(node) end)
end
"]
section_92 -> { header_225 prose_226 codeblock_227}
{rank=same; header_225 prose_226 codeblock_227}

header_225 [label="4 : Node.select(node, pred)"]

prose_226 [label="prose"]

codeblock_227 [label="code block 245-276"]


header_225 -> leaf_228
leaf_228  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.select(node, pred)"]
prose_226 -> { raw_229 prespace_230 literal_231 raw_232 prespace_233 literal_234 raw_235}
{rank=same; raw_229 prespace_230 literal_231 raw_232 prespace_233 literal_234 raw_235}

raw_229 [label="raw"]

prespace_230 [label="prespace"]

literal_231 [label="literal"]

raw_232 [label="raw"]

prespace_233 [label="prespace"]

literal_234 [label="literal"]

raw_235 [label="raw"]


raw_229 -> leaf_236
leaf_236  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Takes the Node and walks it, yielding the Nodes which match the predicate."]
prespace_230 -> leaf_237
leaf_237  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
literal_231 -> leaf_238
leaf_238  [color=Gray,shape=rectangle,fontname=Inconsolata,label="pred"]
raw_232 -> leaf_239
leaf_239  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is either a string, which matches to"]
prespace_233 -> leaf_240
leaf_240  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_234 -> leaf_241
leaf_241  [color=Gray,shape=rectangle,fontname=Inconsolata,label="id"]
raw_235 -> leaf_242
leaf_242  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", or a function, which takes
a Node and returns true or false on some premise. 
"]
codeblock_227 -> leaf_243
leaf_243  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.select(node, pred)
   local function qualifies(node, pred)
      if type(pred) == 'string' then
         if type(node) == 'table' 
          and node.id and node.id == pred then
            return true
         else
            return false
         end
      elseif type(pred) == 'function' then
         return pred(node)
      else
         s:halt(\"cannot select on predicate of type \" .. type(pred))
      end
   end

   local function traverse(ast)
      -- breadth first
      if qualifies(ast, pred) then
         coroutine.yield(ast)
      end
      if ast.isNode then
         for _, v in ipairs(ast) do
            traverse(v)
         end
      end
   end

   return coroutine.wrap(function() traverse(node) end)
end"]
section_93 -> { header_244 prose_245 codeblock_246}
{rank=same; header_244 prose_245 codeblock_246}

header_244 [label="4 : Node.tokens(node)"]

prose_245 [label="prose"]

codeblock_246 [label="code block 283-295"]


header_244 -> leaf_247
leaf_247  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.tokens(node)"]
prose_245 -> { raw_248}
{rank=same; raw_248}

raw_248 [label="raw"]


raw_248 -> leaf_249
leaf_249  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Iterator returning all captured values as strings.
"]
codeblock_246 -> leaf_250
leaf_250  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.tokens(node)
  local function traverse(ast)
    for node in Node.walk(ast) do
      if not node[1] then
        coroutine.yield(node:toValue())
      end
    end
  end

  return coroutine.wrap(function() traverse(node) end)
end  "]
section_94 -> { header_251 prose_252 prose_253 prose_254 codeblock_255}
{rank=same; header_251 prose_252 prose_253 prose_254 codeblock_255}

header_251 [label="4 : Node.unroll(node) "]

prose_252 [label="prose"]

prose_253 [label="prose"]

prose_254 [label="prose"]

codeblock_255 [label="code block 312-319"]


header_251 -> leaf_256
leaf_256  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Node.unroll(node) "]
prose_252 -> { raw_257 prespace_258 literal_259 raw_260 prespace_261 literal_262 raw_263}
{rank=same; raw_257 prespace_258 literal_259 raw_260 prespace_261 literal_262 raw_263}

raw_257 [label="raw"]

prespace_258 [label="prespace"]

literal_259 [label="literal"]

raw_260 [label="raw"]

prespace_261 [label="prespace"]

literal_262 [label="literal"]

raw_263 [label="raw"]


raw_257 -> leaf_264
leaf_264  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  This iterator returns all Nodes, in prefix order, while interpolating
strings.  Specifically: When a Node has a"]
prespace_258 -> leaf_265
leaf_265  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_259 -> leaf_266
leaf_266  [color=Gray,shape=rectangle,fontname=Inconsolata,label="first"]
raw_260 -> leaf_267
leaf_267  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" that is less than the"]
prespace_261 -> leaf_268
leaf_268  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
literal_262 -> leaf_269
leaf_269  [color=Gray,shape=rectangle,fontname=Inconsolata,label="first"]
raw_263 -> leaf_270
leaf_270  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" if its first child, it makes a slice of the string corresponding to
that gap, and so on between each child, and once more at the end.
"]
prose_253 -> { raw_271}
{rank=same; raw_271}

raw_271 [label="raw"]


raw_271 -> leaf_272
leaf_272  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The effect is that any sections of the string which were dropped are now
interpolated into the unrolled Node.
"]
prose_254 -> { raw_273 prespace_274 literal_275 raw_276 prespace_277 literal_278 raw_279 prespace_280 literal_281 raw_282}
{rank=same; raw_273 prespace_274 literal_275 raw_276 prespace_277 literal_278 raw_279 prespace_280 literal_281 raw_282}

raw_273 [label="raw"]

prespace_274 [label="prespace"]

literal_275 [label="literal"]

raw_276 [label="raw"]

prespace_277 [label="prespace"]

literal_278 [label="literal"]

raw_279 [label="raw"]

prespace_280 [label="prespace"]

literal_281 [label="literal"]

raw_282 [label="raw"]


raw_273 -> leaf_283
leaf_283  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The premise is that by calling"]
prespace_274 -> leaf_284
leaf_284  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_275 -> leaf_285
leaf_285  [color=Gray,shape=rectangle,fontname=Inconsolata,label="toValue()"]
raw_276 -> leaf_286
leaf_286  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" or"]
prespace_277 -> leaf_287
leaf_287  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_278 -> leaf_288
leaf_288  [color=Gray,shape=rectangle,fontname=Inconsolata,label="span()"]
raw_279 -> leaf_289
leaf_289  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" on leaf nodes, and
grafting these to the interpolated strings in order, you will produce the
original"]
prespace_280 -> leaf_290
leaf_290  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_281 -> leaf_291
leaf_291  [color=Gray,shape=rectangle,fontname=Inconsolata,label="node.str"]
raw_282 -> leaf_292
leaf_292  [color=Gray,shape=rectangle,fontname=Inconsolata,label=". 
"]
codeblock_255 -> leaf_293
leaf_293  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.unroll(node)
  local function traverse(ast)
  end

  return coroutine.wrap(function() traverse(node) end)
end"]
section_57 -> { header_294 prose_295 prose_296 codeblock_297}
{rank=same; header_294 prose_295 prose_296 codeblock_297}

header_294 [label="3 : Collectors"]

prose_295 [label="prose"]

prose_296 [label="prose"]

codeblock_297 [label="code block 329-338"]


header_294 -> leaf_298
leaf_298  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Collectors"]
prose_295 -> { raw_299}
{rank=same; raw_299}

raw_299 [label="raw"]


raw_299 -> leaf_300
leaf_300  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

These return an array of all results. 
"]
prose_296 -> { raw_301}
{rank=same; raw_301}

raw_301 [label="raw"]


raw_301 -> leaf_302
leaf_302  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- [ ] #todo  Add a Forest class to provide the iterator interface for
             the return arrays of this class.
"]
codeblock_297 -> leaf_303
leaf_303  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.gather(node, pred)
  local gathered = {}
  for ast in node:select(pred) do
    gathered[#gathered + 1] = ast
  end
  
  return gathered
end"]
section_58 -> { header_304 prose_305 section_306}
{rank=same; header_304 prose_305 section_306}

header_304 [label="3 : Subclassing and construction"]

prose_305 [label="prose"]

section_306 [label="section: 343-360"]


header_304 -> leaf_307
leaf_307  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Subclassing and construction"]
prose_305 -> { raw_308}
{rank=same; raw_308}

raw_308 [label="raw"]


raw_308 -> leaf_309
leaf_309  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

"]
section_306 -> { header_310 prose_311 codeblock_312}
{rank=same; header_310 prose_311 codeblock_312}

header_310 [label="4 : N.inherit(node)"]

prose_311 [label="prose"]

codeblock_312 [label="code block 345-359"]


header_310 -> leaf_313
leaf_313  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** N.inherit(node)"]
prose_311 -> { raw_314}
{rank=same; raw_314}

raw_314 [label="raw"]


raw_314 -> leaf_315
leaf_315  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_312 -> leaf_316
leaf_316  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Node.inherit(node)
  local Meta = setmetatable({}, node)
  Meta.__index = Meta
  local meta = setmetatable({}, Meta)
  meta.__index = meta
  return Meta, meta
end

function Node.export(_, mod, constructor)
  mod.__call = constructor
  return setmetatable({}, mod)
end
"]
section_8 -> { header_317 prose_318 prose_319 prose_320 prose_321 prose_322 section_323 section_324}
{rank=same; header_317 prose_318 prose_319 prose_320 prose_321 prose_322 section_323 section_324}

header_317 [label="2 : Node Instances"]

prose_318 [label="prose"]

prose_319 [label="prose"]

prose_320 [label="prose"]

prose_321 [label="prose"]

prose_322 [label="prose"]

section_323 [label="section: 385-407"]

section_324 [label="section: 421-455"]


header_317 -> leaf_325
leaf_325  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Node Instances"]
prose_318 -> { raw_326}
{rank=same; raw_326}

raw_326 [label="raw"]


raw_326 -> leaf_327
leaf_327  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  To be a Node, currently, indexed elements of the Array portion must also be 
Nodes. 
"]
prose_319 -> { raw_328}
{rank=same; raw_328}

raw_328 [label="raw"]


raw_328 -> leaf_329
leaf_329  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I'm mostly convinced that indexed elements can also be strings, and that 
this is the form leaf nodes should take.  Currently, they have a 'val' field
and no children, which we should replace with a child string at [1].
"]
prose_320 -> { raw_330 prespace_331 literal_332 raw_333 prespace_334 literal_335 raw_336}
{rank=same; raw_330 prespace_331 literal_332 raw_333 prespace_334 literal_335 raw_336}

raw_330 [label="raw"]

prespace_331 [label="prespace"]

literal_332 [label="literal"]

raw_333 [label="raw"]

prespace_334 [label="prespace"]

literal_335 [label="literal"]

raw_336 [label="raw"]


raw_330 -> leaf_337
leaf_337  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This gives us a lighter way to handle the circumstance where we have, say,
a list,"]
prespace_331 -> leaf_338
leaf_338  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_332 -> leaf_339
leaf_339  [color=Gray,shape=rectangle,fontname=Inconsolata,label="(foo bar baz)"]
raw_333 -> leaf_340
leaf_340  [color=Gray,shape=rectangle,fontname=Inconsolata,label=". We currently either need a \"left-per\" or \"pal\"
Node class to hold the"]
prespace_334 -> leaf_341
leaf_341  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_335 -> leaf_342
leaf_342  [color=Gray,shape=rectangle,fontname=Inconsolata,label="("]
raw_336 -> leaf_343
leaf_343  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", or we would have to skip it entirely.
"]
prose_321 -> { raw_344 prespace_345 italic_346 raw_347}
{rank=same; raw_344 prespace_345 italic_346 raw_347}

raw_344 [label="raw"]

prespace_345 [label="prespace"]

italic_346 [label="italic"]

raw_347 [label="raw"]


raw_344 -> leaf_348
leaf_348  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Quipu can't lose any information from the string, so they have to include
whitespace.  We're not limited in the same way and can reconstruct less 
semantically crucial parts of a document using the span and the original 
string, since we're not"]
prespace_345 -> leaf_349
leaf_349  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
italic_346 -> leaf_350
leaf_350  [color=Gray,shape=rectangle,fontname=Inconsolata,label="currently"]
raw_347 -> leaf_351
leaf_351  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" editing our strings once they're
entered in.
"]
prose_322 -> { raw_352}
{rank=same; raw_352}

raw_352 [label="raw"]


raw_352 -> leaf_353
leaf_353  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Nodes are meant to be broadly compatible with everything we intend to
do with abstract syntax trees.  The more I think about this the better
it strikes me as an approach. 

"]
section_323 -> { header_354 prose_355 prose_356 prose_357 prose_358 prose_359 section_360}
{rank=same; header_354 prose_355 prose_356 prose_357 prose_358 prose_359 section_360}

header_354 [label="3 : Fields"]

prose_355 [label="prose"]

prose_356 [label="prose"]

prose_357 [label="prose"]

prose_358 [label="prose"]

prose_359 [label="prose"]

section_360 [label="section: 408-420"]


header_354 -> leaf_361
leaf_361  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Fields"]
prose_355 -> { raw_362 prespace_363 literal_364 raw_365 prespace_366 literal_367 raw_368}
{rank=same; raw_362 prespace_363 literal_364 raw_365 prespace_366 literal_367 raw_368}

raw_362 [label="raw"]

prespace_363 [label="prespace"]

literal_364 [label="literal"]

raw_365 [label="raw"]

prespace_366 [label="prespace"]

literal_367 [label="literal"]

raw_368 [label="raw"]


raw_362 -> leaf_369
leaf_369  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  There are invariant fields a Node is also expected to have, they are:
 
  - first :  Index into"]
prespace_363 -> leaf_370
leaf_370  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_364 -> leaf_371
leaf_371  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str"]
raw_365 -> leaf_372
leaf_372  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" which begins the span.
  - last  :  Index into"]
prespace_366 -> leaf_373
leaf_373  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_367 -> leaf_374
leaf_374  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str"]
raw_368 -> leaf_375
leaf_375  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" which ends the span.
"]
prose_356 -> { raw_376 prespace_377 literal_378 raw_379}
{rank=same; raw_376 prespace_377 literal_378 raw_379}

raw_376 [label="raw"]

prespace_377 [label="prespace"]

literal_378 [label="literal"]

raw_379 [label="raw"]


raw_376 -> leaf_380
leaf_380  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
In principle, we want the Node to be localized. We could include a 
reference to the whole"]
prespace_377 -> leaf_381
leaf_381  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_378 -> leaf_382
leaf_382  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str"]
raw_379 -> leaf_383
leaf_383  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" and derive substrings lazily.
"]
prose_357 -> { raw_384}
{rank=same; raw_384}

raw_384 [label="raw"]


raw_384 -> leaf_385
leaf_385  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If we included the full span as a substring on each Node, we'd end up
with a lot of spans, and wouldn't use most of them. Even slicing a piece
out is costly if we're not going to use it. 
"]
prose_358 -> { raw_386}
{rank=same; raw_386}

raw_386 [label="raw"]


raw_386 -> leaf_387
leaf_387  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
So our constructor for a Node class takes (Constructor, node, str) as 
the standard interface.  If a module needs a non-standard constructor,
as our Section and Block modules currently take an array of lines, that
will need to be provided as the second return from the module. 
"]
prose_359 -> { raw_388}
{rank=same; raw_388}

raw_388 [label="raw"]


raw_388 -> leaf_389
leaf_389  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This will allow for the kind of multi-pass recursive-descent that I'm
aiming for. 

"]
section_360 -> { header_390 prose_391 prose_392 prose_393 prose_394}
{rank=same; header_390 prose_391 prose_392 prose_393 prose_394}

header_390 [label="4 : line tracking (optional)"]

prose_391 [label="prose"]

prose_392 [label="prose"]

prose_393 [label="prose"]

prose_394 [label="prose"]


header_390 -> leaf_395
leaf_395  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** line tracking (optional)"]
prose_391 -> { raw_396}
{rank=same; raw_396}

raw_396 [label="raw"]


raw_396 -> leaf_397
leaf_397  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

It may be wise to always track lines, in which case we will include:
"]
prose_392 -> { raw_398}
{rank=same; raw_398}

raw_398 [label="raw"]


raw_398 -> leaf_399
leaf_399  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  - line_first :  The line at which the match begins
  - line_last  :  The line at which the match ends
"]
prose_393 -> { raw_400}
{rank=same; raw_400}

raw_400 [label="raw"]


raw_400 -> leaf_401
leaf_401  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This is, at least, a frequent enough pattern that the metatable should return
a negative number if these aren't assigned. 
"]
prose_394 -> { raw_402}
{rank=same; raw_402}

raw_402 [label="raw"]


raw_402 -> leaf_403
leaf_403  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- [ ] #todo decide if line tracking is in fact optional

"]
section_324 -> { header_404 prose_405 prose_406 prose_407 prose_408 prose_409 prose_410 prose_411 prose_412 codeblock_413}
{rank=same; header_404 prose_405 prose_406 prose_407 prose_408 prose_409 prose_410 prose_411 prose_412 codeblock_413}

header_404 [label="3 : Other fields"]

prose_405 [label="prose"]

prose_406 [label="prose"]

prose_407 [label="prose"]

prose_408 [label="prose"]

prose_409 [label="prose"]

prose_410 [label="prose"]

prose_411 [label="prose"]

prose_412 [label="prose"]

codeblock_413 [label="code block 450-452"]


header_404 -> leaf_414
leaf_414  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Other fields"]
prose_405 -> { raw_415 prespace_416 literal_417 raw_418}
{rank=same; raw_415 prespace_416 literal_417 raw_418}

raw_415 [label="raw"]

prespace_416 [label="prespace"]

literal_417 [label="literal"]

raw_418 [label="raw"]


raw_415 -> leaf_419
leaf_419  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  The way the Grammar class will work: each"]
prespace_416 -> leaf_420
leaf_420  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_417 -> leaf_421
leaf_421  [color=Gray,shape=rectangle,fontname=Inconsolata,label="V\"patt\""]
raw_418 -> leaf_422
leaf_422  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" can have a metatable.
These are passed in as the second parameter during construction, with the key
the same name as the rule. 
"]
prose_406 -> { raw_423}
{rank=same; raw_423}

raw_423 [label="raw"]


raw_423 -> leaf_424
leaf_424  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If a pattern doesn't have a metatable, it's given a Node class and consists of
only the above fields, plus an array representing any subrules. 
"]
prose_407 -> { raw_425 prespace_426 literal_427 raw_428}
{rank=same; raw_425 prespace_426 literal_427 raw_428}

raw_425 [label="raw"]

prespace_426 [label="prespace"]

literal_427 [label="literal"]

raw_428 [label="raw"]


raw_425 -> leaf_429
leaf_429  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If it does, the metatable will have a"]
prespace_426 -> leaf_430
leaf_430  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_427 -> leaf_431
leaf_431  [color=Gray,shape=rectangle,fontname=Inconsolata,label="__call"]
raw_428 -> leaf_432
leaf_432  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" method, which expects two
parameters, itself, and the node, which will include the span. 
"]
prose_408 -> { raw_433 prespace_434 literal_435 raw_436}
{rank=same; raw_433 prespace_434 literal_435 raw_436}

raw_433 [label="raw"]

prespace_434 [label="prespace"]

literal_435 [label="literal"]

raw_436 [label="raw"]


raw_433 -> leaf_437
leaf_437  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This will require reattunement of basically every class in the"]
prespace_434 -> leaf_438
leaf_438  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_435 -> leaf_439
leaf_439  [color=Gray,shape=rectangle,fontname=Inconsolata,label="/grym"]
raw_436 -> leaf_440
leaf_440  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" folder,
but let's build the Prose parse first.  I do want the whole shebang in a single
grammar eventually.
"]
prose_409 -> { raw_441}
{rank=same; raw_441}

raw_441 [label="raw"]


raw_441 -> leaf_442
leaf_442  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The intention is to allow multiple grammars to coexist peacefully. Currently
the parser is handrolled and we have special case values for everything.
The idea is to stabilize this, so that multi-pass parsing works but in a
standard way where the Node constructor is a consistent interface. 
"]
prose_410 -> { raw_443}
{rank=same; raw_443}

raw_443 [label="raw"]


raw_443 -> leaf_444
leaf_444  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
In the meantime we have things like
"]
prose_411 -> { raw_445 prespace_446 literal_447 raw_448}
{rank=same; raw_445 prespace_446 literal_447 raw_448}

raw_445 [label="raw"]

prespace_446 [label="prespace"]

literal_447 [label="literal"]

raw_448 [label="raw"]


raw_445 -> leaf_449
leaf_449  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- lines :  If this exists, there's a collection of lines which need to be
           joined with"]
prespace_446 -> leaf_450
leaf_450  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_447 -> leaf_451
leaf_451  [color=Gray,shape=rectangle,fontname=Inconsolata,label="\\n"]
raw_448 -> leaf_452
leaf_452  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" to reconstruct the actual span.
"]
prose_412 -> { raw_453}
{rank=same; raw_453}

raw_453 [label="raw"]


raw_453 -> leaf_454
leaf_454  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
           We want to do this the other way, and use the span itself for the
           inner parse. 
"]
codeblock_413 -> leaf_455
leaf_455  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return Node"]

}
