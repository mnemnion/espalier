digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 252"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-5"]


section_1 -> { header_2 prose_3 section_4}
{rank=same; header_2 prose_3 section_4}

header_2 [label="1 : Grammar Module"]

prose_3 [label="prose"]

section_4 [label="section: 6-115"]


header_2 -> leaf_5
leaf_5  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Grammar Module"]
prose_3 -> { raw_6}
{rank=same; raw_6}

raw_6 [label="raw"]


raw_6 -> leaf_7
leaf_7  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  The grammar module returns one function, which generates
a grammar. 
"]
section_4 -> { header_8 prose_9 prose_10 prose_11 section_12 section_13 section_14 section_15}
{rank=same; header_8 prose_9 prose_10 prose_11 section_12 section_13 section_14 section_15}

header_8 [label="2 : Parameters"]

prose_9 [label="prose"]

prose_10 [label="prose"]

prose_11 [label="prose"]

section_12 [label="section: 16-45"]

section_13 [label="section: 46-69"]

section_14 [label="section: 70-115"]

section_15 [label="section: 116-252"]


header_8 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Parameters"]
prose_9 -> { raw_17}
{rank=same; raw_17}

raw_17 [label="raw"]


raw_17 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This function takes two parameters, namely:
"]
prose_10 -> { raw_19 literal_20 raw_21}
{rank=same; raw_19 literal_20 raw_21}

raw_19 [label="raw"]

literal_20 [label="literal"]

raw_21 [label="raw"]


raw_19 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  - grammar_template :  A function with one parameter, which must be "]
literal_20 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label="_ENV"]
raw_21 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
  - metas :  A map with keys of string and values of Node subclass constructors.
"]
prose_11 -> { raw_25}
{rank=same; raw_25}

raw_25 [label="raw"]


raw_25 -> leaf_26
leaf_26  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Both of these are reasonably complex.

"]
section_12 -> { header_27 prose_28 prose_29 prose_30 prose_31 prose_32 prose_33 prose_34}
{rank=same; header_27 prose_28 prose_29 prose_30 prose_31 prose_32 prose_33 prose_34}

header_27 [label="3 : grammar_template"]

prose_28 [label="prose"]

prose_29 [label="prose"]

prose_30 [label="prose"]

prose_31 [label="prose"]

prose_32 [label="prose"]

prose_33 [label="prose"]

prose_34 [label="prose"]


header_27 -> leaf_35
leaf_35  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** grammar_template"]
prose_28 -> { raw_36 literal_37 raw_38}
{rank=same; raw_36 literal_37 raw_38}

raw_36 [label="raw"]

literal_37 [label="literal"]

raw_38 [label="raw"]


raw_36 -> leaf_39
leaf_39  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  The internal function @define creates a custom environment variable, neatly
sidestepping lua's pedantic insistance on prepending "]
literal_37 -> leaf_40
leaf_40  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local"]
raw_38 -> leaf_41
leaf_41  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" to all values of 
significance. 
"]
prose_29 -> { raw_42}
{rank=same; raw_42}

raw_42 [label="raw"]


raw_42 -> leaf_43
leaf_43  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
More relevantly, it constructs a full grammar, which will return a table of
type Node. 
"]
prose_30 -> { raw_44 literal_45 raw_46}
{rank=same; raw_44 literal_45 raw_46}

raw_44 [label="raw"]

literal_45 [label="literal"]

raw_46 [label="raw"]


raw_44 -> leaf_47
leaf_47  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If you stick to "]
literal_45 -> leaf_48
leaf_48  [color=Gray,shape=rectangle,fontname=Inconsolata,label="lpeg"]
raw_46 -> leaf_49
leaf_49  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" patterns, as you should, all array values will be of
Node, as is intended.  Captures will interpolate various other sorts of Lua
values, which will induce halting in some places and silently corrupt
execution in others. 
"]
prose_31 -> { raw_50 link_51 raw_52}
{rank=same; raw_50 link_51 raw_52}

raw_50 [label="raw"]

link_51 [label="link"]

raw_52 [label="raw"]


raw_50 -> leaf_53
leaf_53  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Though as yet poorly thought through, the "]
link_51 -> { anchortext_54 url_55}
{rank=same; anchortext_54 url_55}

anchortext_54 [label="anchortext"]

url_55 [label="url"]


anchortext_54 -> leaf_56
leaf_56  [color=Gray,shape=rectangle,fontname=Inconsolata,label="elpatt module"]
url_55 -> leaf_57
leaf_57  [color=Gray,shape=rectangle,fontname=Inconsolata,label="./elpatt"]
raw_52 -> leaf_58
leaf_58  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is
intended to provide only those patterns which are allowed in Grammars, while
expanding the scope of some favorites to properly respect utf-8 and otherwise
behave. 
"]
prose_32 -> { raw_59 link_60 raw_61}
{rank=same; raw_59 link_60 raw_61}

raw_59 [label="raw"]

link_60 [label="link"]

raw_61 [label="raw"]


raw_59 -> leaf_62
leaf_62  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
There are examples of the format in the "]
link_60 -> { anchortext_63 url_64}
{rank=same; anchortext_63 url_64}

anchortext_63 [label="anchortext"]

url_64 [label="url"]


anchortext_63 -> leaf_65
leaf_65  [color=Gray,shape=rectangle,fontname=Inconsolata,label="spec module"]
url_64 -> leaf_66
leaf_66  [color=Gray,shape=rectangle,fontname=Inconsolata,label="./spec"]
raw_61 -> leaf_67
leaf_67  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
"]
prose_33 -> { raw_68}
{rank=same; raw_68}

raw_68 [label="raw"]


raw_68 -> leaf_69
leaf_69  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Special fields include:
"]
prose_34 -> { raw_70}
{rank=same; raw_70}

raw_70 [label="raw"]


raw_70 -> leaf_71
leaf_71  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  -  START :  a string which must be the same as the starting rule.
  -  SUPPRESS :  either a string or an array of strings. These rules will be
                 removed from the Node. 
  -  P :  The lpeg P function.  Recognizes a certain pattern.
  -  V :  The lpeg V function.  Used for non-terminal rvalues in a grammar. 

"]
section_13 -> { header_72 prose_73 prose_74 prose_75 prose_76 prose_77}
{rank=same; header_72 prose_73 prose_74 prose_75 prose_76 prose_77}

header_72 [label="3 : metas"]

prose_73 [label="prose"]

prose_74 [label="prose"]

prose_75 [label="prose"]

prose_76 [label="prose"]

prose_77 [label="prose"]


header_72 -> leaf_78
leaf_78  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** metas"]
prose_73 -> { raw_79}
{rank=same; raw_79}

raw_79 [label="raw"]


raw_79 -> leaf_80
leaf_80  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  By default a node will inherit from the Node class.  If you want custom behavior,
you must pass in a table of metatable constructors.
"]
prose_74 -> { raw_81 literal_82 raw_83 literal_84 raw_85 literal_86 raw_87 literal_88 raw_89 literal_90 raw_91 literal_92 raw_93}
{rank=same; raw_81 literal_82 raw_83 literal_84 raw_85 literal_86 raw_87 literal_88 raw_89 literal_90 raw_91 literal_92 raw_93}

raw_81 [label="raw"]

literal_82 [label="literal"]

raw_83 [label="raw"]

literal_84 [label="literal"]

raw_85 [label="raw"]

literal_86 [label="literal"]

raw_87 [label="raw"]

literal_88 [label="literal"]

raw_89 [label="raw"]

literal_90 [label="literal"]

raw_91 [label="raw"]

literal_92 [label="literal"]

raw_93 [label="raw"]


raw_81 -> leaf_94
leaf_94  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
That's a fairly specific beast.  Any rule defined above will have an "]
literal_82 -> leaf_95
leaf_95  [color=Gray,shape=rectangle,fontname=Inconsolata,label="id"]
raw_83 -> leaf_96
leaf_96  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
corresonding to the name of the rule.  Unless "]
literal_84 -> leaf_97
leaf_97  [color=Gray,shape=rectangle,fontname=Inconsolata,label="SUPPRESS"]
raw_85 -> leaf_98
leaf_98  [color=Gray,shape=rectangle,fontname=Inconsolata,label="ed, this will become
a Node.  If the "]
literal_86 -> leaf_99
leaf_99  [color=Gray,shape=rectangle,fontname=Inconsolata,label="metas"]
raw_87 -> leaf_100
leaf_100  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" parameter has a key corresponding to "]
literal_88 -> leaf_101
leaf_101  [color=Gray,shape=rectangle,fontname=Inconsolata,label="id"]
raw_89 -> leaf_102
leaf_102  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", then it
must return a function taking two parameters:
   
   - node :  The node under construction, which under normal circumstances will
             already have the "]
literal_90 -> leaf_103
leaf_103  [color=Gray,shape=rectangle,fontname=Inconsolata,label="first"]
raw_91 -> leaf_104
leaf_104  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" and "]
literal_92 -> leaf_105
leaf_105  [color=Gray,shape=rectangle,fontname=Inconsolata,label="last"]
raw_93 -> leaf_106
leaf_106  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" fields.
   - str  :  The entire str the grammar is parsing.
"]
prose_75 -> { raw_107}
{rank=same; raw_107}

raw_107 [label="raw"]


raw_107 -> leaf_108
leaf_108  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Which must return that same node, decorated in whatever fashion is appropriate.
"]
prose_76 -> { raw_109 literal_110 raw_111 literal_112 raw_113}
{rank=same; raw_109 literal_110 raw_111 literal_112 raw_113}

raw_109 [label="raw"]

literal_110 [label="literal"]

raw_111 [label="raw"]

literal_112 [label="literal"]

raw_113 [label="raw"]


raw_109 -> leaf_114
leaf_114  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The node will not have a metatable at this point, and the function must attach a
metatable with "]
literal_110 -> leaf_115
leaf_115  [color=Gray,shape=rectangle,fontname=Inconsolata,label="__index"]
raw_111 -> leaf_116
leaf_116  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" equal to some table which itself has the "]
literal_112 -> leaf_117
leaf_117  [color=Gray,shape=rectangle,fontname=Inconsolata,label="__index"]
raw_113 -> leaf_118
leaf_118  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Node as some recursive backstop.
"]
prose_77 -> { raw_119 italic_120 raw_121}
{rank=same; raw_119 italic_120 raw_121}

raw_119 [label="raw"]

italic_120 [label="italic"]

raw_121 [label="raw"]


raw_119 -> leaf_122
leaf_122  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
You might say the return value must "]
italic_120 -> leaf_123
leaf_123  [color=Gray,shape=rectangle,fontname=Inconsolata,label="inherit"]
raw_121 -> leaf_124
leaf_124  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" from Node, if we were using
a language that did that sort of thing. 

"]
section_14 -> { header_125 prose_126 prose_127 prose_128 codeblock_129 prose_130 prose_131 codeblock_132}
{rank=same; header_125 prose_126 prose_127 prose_128 codeblock_129 prose_130 prose_131 codeblock_132}

header_125 [label="3 : includes"]

prose_126 [label="prose"]

prose_127 [label="prose"]

prose_128 [label="prose"]

codeblock_129 [label="code block 82-92"]

prose_130 [label="prose"]

prose_131 [label="prose"]

codeblock_132 [label="code block 98-113"]


header_125 -> leaf_133
leaf_133  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** includes"]
prose_126 -> { raw_134}
{rank=same; raw_134}

raw_134 [label="raw"]


raw_134 -> leaf_135
leaf_135  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


- [ ] #todo  Note the require strings below, which prevent this from
             being a usable library. 
"]
prose_127 -> { raw_136 literal_137 raw_138 literal_139 raw_140}
{rank=same; raw_136 literal_137 raw_138 literal_139 raw_140}

raw_136 [label="raw"]

literal_137 [label="literal"]

raw_138 [label="raw"]

literal_139 [label="literal"]

raw_140 [label="raw"]


raw_136 -> leaf_141
leaf_141  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
             The problem is almost a philosophical one, and it's what I'm
             setting out to solve with "]
literal_137 -> leaf_142
leaf_142  [color=Gray,shape=rectangle,fontname=Inconsolata,label="bridge"]
raw_138 -> leaf_143
leaf_143  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" and "]
literal_139 -> leaf_144
leaf_144  [color=Gray,shape=rectangle,fontname=Inconsolata,label="manifest"]
raw_140 -> leaf_145
leaf_145  [color=Gray,shape=rectangle,fontname=Inconsolata,label=". 
"]
prose_128 -> { raw_146 literal_147 raw_148}
{rank=same; raw_146 literal_147 raw_148}

raw_146 [label="raw"]

literal_147 [label="literal"]

raw_148 [label="raw"]


raw_146 -> leaf_149
leaf_149  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
             In the meantime, "]
literal_147 -> leaf_150
leaf_150  [color=Gray,shape=rectangle,fontname=Inconsolata,label="lpegnode"]
raw_148 -> leaf_151
leaf_151  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" has one consumer. Let's keep it
             happy. 
"]
codeblock_129 -> leaf_152
leaf_152  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local L = require \"lpeg\"

local s = require \"status\" ()
s.verbose = true

local Node = require \"node/node\"
local elpatt = require \"node/elpatt\"

local DROP = elpatt.DROP"]
prose_130 -> { raw_153}
{rank=same; raw_153}

raw_153 [label="raw"]


raw_153 -> leaf_154
leaf_154  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I like the dedication shown in this style of import.
"]
prose_131 -> { raw_155}
{rank=same; raw_155}

raw_155 [label="raw"]


raw_155 -> leaf_156
leaf_156  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
It's the kind of thing I'd like to automate. 
"]
codeblock_132 -> leaf_157
leaf_157  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local assert = assert
local string, io = assert( string ), assert( io )
local V = string.sub( assert( _VERSION ), -4 )
local _G = assert( _G )
local error = assert( error )
local pairs = assert( pairs )
local next = assert( next )
local type = assert( type )
local tostring = assert( tostring )
local setmetatable = assert( setmetatable )
if V == \" 5.1\" then
   local setfenv = assert( setfenv )
   local getfenv = assert( getfenv )
end"]
section_15 -> { header_158 prose_159 codeblock_160 codeblock_161 codeblock_162 codeblock_163}
{rank=same; header_158 prose_159 codeblock_160 codeblock_161 codeblock_162 codeblock_163}

header_158 [label="3 : define"]

prose_159 [label="prose"]

codeblock_160 [label="code block 118-207"]

codeblock_161 [label="code block 209-228"]

codeblock_162 [label="code block 231-248"]

codeblock_163 [label="code block 250-252"]


header_158 -> leaf_164
leaf_164  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** define"]
prose_159 -> { raw_165}
{rank=same; raw_165}

raw_165 [label="raw"]


raw_165 -> leaf_166
leaf_166  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_160 -> leaf_167
leaf_167  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function make_ast_node(id, first, t, last, str, metas, offset)
   local offset = offset or 0
   t.first = first + offset
   t.last  = last + offset - 1
   t.str   = str
   if metas[id] then
      local meta = metas[id]
      if type(meta) == \"function\" or meta.__call then
        t = metas[id](t, str)
      else
        t = setmetatable(t, meta)
      end
      assert(t.id == id)
   else
      t.id = id
       setmetatable(t, {__index = Node,
                     __tostring = Node.toString})
   end
   for _,v in ipairs(t) do
      if type(v) ~= \"table\" then
         s:complain(\"CAPTURE ISSUE\", 
                    \"type of capture subgroup is \" .. type(v) .. \"\\n\")
      end
      if v == DROP then
        s:verb(\"-- child v of t is DROP\")
      end
   end
   assert(t.isNode, \"failed isNode: \" .. id)
   assert(t.str)
   return t
end


-- some useful/common lpeg patterns
local Cp = L.Cp
local Cc = L.Cc
local Ct = L.Ct
local arg1_str = L.Carg(1)
local arg2_metas = L.Carg(2)
local arg3_offset = L.Carg(3)


-- setup an environment where you can easily define lpeg grammars
-- with lots of syntax sugar
local function define(func, g, e)
  g = g or {}
  if e == nil then
    e = V == \" 5.1\" and getfenv(func) or _G
  end
  local suppressed = {}
  local env = {}
  local env_index = {
    START = function(name) g[1] = name end,
    SUPPRESS = function(...)
      suppressed = {}
      for i = 1, select('#', ...) do
        suppressed[select(i, ... )] = true
      end
    end,
    V = L.V,
    P = L.P,
  }

  setmetatable(env_index, { __index = e })
  setmetatable(env, {
    __index = env_index,
    __newindex = function( _, name, val )
      if suppressed[ name ] then
        g[ name ] = val
      else
        g[ name ] = (Cc(name) 
              * Cp() 
              * Ct(val)
              * Cp()
              * arg1_str
              * arg2_metas)
              * arg3_offset / make_ast_node
      end
    end
  })
  -- call passed function with custom environment (5.1- and 5.2-style)
  if V == \" 5.1\" then
    setfenv( func, env )
  end
  func( env )
  assert( g[ 1 ] and g[ g[ 1 ] ], \"no start rule defined\" )
  return g
end"]
codeblock_161 -> leaf_168
leaf_168  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function refineMetas(metas)
  s:verb(\"refining metatables\")
  for id, meta in pairs(metas) do
    s:verb(\"  id: \" .. id .. \" type: \" .. type(meta))
    if type(meta) == \"table\" then
      if not meta[\"__tostring\"] then
        meta[\"__tostring\"] = Node.toString
      end
      if not meta.id then
        s:verb(\"    inserting metatable id: \" .. id)
        meta.id = id
      else
        s:verb(\"    id of \" .. id .. \" is \" .. meta.id)
      end
    end
  end
  return metas
end"]
codeblock_162 -> leaf_169
leaf_169  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function new(grammar_template, metas)
  if type(grammar_template) == 'function' then
    local metas = metas or {}
    metas = refineMetas(metas)
    local grammar = define(grammar_template, nil, metas)

    local function parse(str, offset)
      local offset = offset or 0
      return L.match(grammar, str, 1, str, metas, offset) -- other 
    end

    return parse
  else
    s:halt(\"no way to build grammar out of \" .. type(template))
  end
end"]
codeblock_163 -> leaf_170
leaf_170  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return new"]

}
