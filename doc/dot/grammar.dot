digraph lpegNode {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 390"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-344"]


// END RANK doc_0

section_1 -> { header_2 prose_3 section_4 section_5}
{rank=same; header_2 prose_3 section_4 section_5}

header_2 [label="1 : Grammar Module"]

prose_3 [label="prose"]

section_4 [label="section: 6-119"]

section_5 [label="section: 345-390"]


// END RANK section_1

header_2 -> leaf_6
leaf_6  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Grammar Module"]
// END RANK header_2

prose_3 -> { raw_7}
{rank=same; raw_7}

raw_7 [label="raw"]


// END RANK prose_3

raw_7 -> leaf_8
leaf_8  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  The grammar module returns one function, which generates
a grammar. 
"]
// END RANK raw_7

section_4 -> { header_9 prose_10 prose_11 prose_12 section_13 section_14 section_15 section_16}
{rank=same; header_9 prose_10 prose_11 prose_12 section_13 section_14 section_15 section_16}

header_9 [label="2 : Parameters"]

prose_10 [label="prose"]

prose_11 [label="prose"]

prose_12 [label="prose"]

section_13 [label="section: 17-46"]

section_14 [label="section: 47-70"]

section_15 [label="section: 71-119"]

section_16 [label="section: 120-160"]


// END RANK section_4

header_9 -> leaf_17
leaf_17  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Parameters"]
// END RANK header_9

prose_10 -> { raw_18}
{rank=same; raw_18}

raw_18 [label="raw"]


// END RANK prose_10

raw_18 -> leaf_19
leaf_19  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This function takes two parameters, namely:
"]
// END RANK raw_18

prose_11 -> { raw_20 prespace_21 literal_22 raw_23}
{rank=same; raw_20 prespace_21 literal_22 raw_23}

raw_20 [label="raw"]

prespace_21 [label="prespace"]

literal_22 [label="literal"]

raw_23 [label="raw"]


// END RANK prose_11

raw_20 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  - grammar_template :  A function with one parameter, which must be"]
// END RANK raw_20

prespace_21 -> leaf_25
leaf_25  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_21

literal_22 -> leaf_26
leaf_26  [color=Gray,shape=rectangle,fontname=Inconsolata,label="_ENV"]
// END RANK literal_22

raw_23 -> leaf_27
leaf_27  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
  - metas :  A map with keys of string and values of Node subclass constructors.
"]
// END RANK raw_23

prose_12 -> { raw_28}
{rank=same; raw_28}

raw_28 [label="raw"]


// END RANK prose_12

raw_28 -> leaf_29
leaf_29  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Both of these are reasonably complex.


"]
// END RANK raw_28

section_13 -> { header_30 prose_31 prose_32 prose_33 prose_34 prose_35 prose_36 prose_37}
{rank=same; header_30 prose_31 prose_32 prose_33 prose_34 prose_35 prose_36 prose_37}

header_30 [label="3 : grammar_template"]

prose_31 [label="prose"]

prose_32 [label="prose"]

prose_33 [label="prose"]

prose_34 [label="prose"]

prose_35 [label="prose"]

prose_36 [label="prose"]

prose_37 [label="prose"]


// END RANK section_13

header_30 -> leaf_38
leaf_38  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** grammar_template"]
// END RANK header_30

prose_31 -> { raw_39 prespace_40 literal_41 raw_42}
{rank=same; raw_39 prespace_40 literal_41 raw_42}

raw_39 [label="raw"]

prespace_40 [label="prespace"]

literal_41 [label="literal"]

raw_42 [label="raw"]


// END RANK prose_31

raw_39 -> leaf_43
leaf_43  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  The internal function @define creates a custom environment variable, neatly
sidestepping lua's pedantic insistance on prepending"]
// END RANK raw_39

prespace_40 -> leaf_44
leaf_44  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_40

literal_41 -> leaf_45
leaf_45  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local"]
// END RANK literal_41

raw_42 -> leaf_46
leaf_46  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" to all values of 
significance. 
"]
// END RANK raw_42

prose_32 -> { raw_47}
{rank=same; raw_47}

raw_47 [label="raw"]


// END RANK prose_32

raw_47 -> leaf_48
leaf_48  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
More relevantly, it constructs a full grammar, which will return a table of
type Node. 
"]
// END RANK raw_47

prose_33 -> { raw_49 prespace_50 literal_51 raw_52}
{rank=same; raw_49 prespace_50 literal_51 raw_52}

raw_49 [label="raw"]

prespace_50 [label="prespace"]

literal_51 [label="literal"]

raw_52 [label="raw"]


// END RANK prose_33

raw_49 -> leaf_53
leaf_53  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If you stick to"]
// END RANK raw_49

prespace_50 -> leaf_54
leaf_54  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_50

literal_51 -> leaf_55
leaf_55  [color=Gray,shape=rectangle,fontname=Inconsolata,label="lpeg"]
// END RANK literal_51

raw_52 -> leaf_56
leaf_56  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" patterns, as you should, all array values will be of
Node, as is intended.  Captures will interpolate various other sorts of Lua
values, which will induce halting in some places and silently corrupt
execution in others. 
"]
// END RANK raw_52

prose_34 -> { raw_57 link_58 raw_59}
{rank=same; raw_57 link_58 raw_59}

raw_57 [label="raw"]

link_58 [label="link"]

raw_59 [label="raw"]


// END RANK prose_34

raw_57 -> leaf_60
leaf_60  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Though as yet poorly thought through, the "]
// END RANK raw_57

link_58 -> { anchortext_61 url_62}
{rank=same; anchortext_61 url_62}

anchortext_61 [label="anchortext"]

url_62 [label="url"]


// END RANK link_58

anchortext_61 -> leaf_63
leaf_63  [color=Gray,shape=rectangle,fontname=Inconsolata,label="elpatt module"]
// END RANK anchortext_61

url_62 -> leaf_64
leaf_64  [color=Gray,shape=rectangle,fontname=Inconsolata,label="./elpatt"]
// END RANK url_62

raw_59 -> leaf_65
leaf_65  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is
intended to provide only those patterns which are allowed in Grammars, while
expanding the scope of some favorites to properly respect utf-8 and otherwise
behave. 
"]
// END RANK raw_59

prose_35 -> { raw_66 link_67 raw_68}
{rank=same; raw_66 link_67 raw_68}

raw_66 [label="raw"]

link_67 [label="link"]

raw_68 [label="raw"]


// END RANK prose_35

raw_66 -> leaf_69
leaf_69  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
There are examples of the format in the "]
// END RANK raw_66

link_67 -> { anchortext_70 url_71}
{rank=same; anchortext_70 url_71}

anchortext_70 [label="anchortext"]

url_71 [label="url"]


// END RANK link_67

anchortext_70 -> leaf_72
leaf_72  [color=Gray,shape=rectangle,fontname=Inconsolata,label="spec module"]
// END RANK anchortext_70

url_71 -> leaf_73
leaf_73  [color=Gray,shape=rectangle,fontname=Inconsolata,label="./spec"]
// END RANK url_71

raw_68 -> leaf_74
leaf_74  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
"]
// END RANK raw_68

prose_36 -> { raw_75}
{rank=same; raw_75}

raw_75 [label="raw"]


// END RANK prose_36

raw_75 -> leaf_76
leaf_76  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Special fields include:
"]
// END RANK raw_75

prose_37 -> { raw_77}
{rank=same; raw_77}

raw_77 [label="raw"]


// END RANK prose_37

raw_77 -> leaf_78
leaf_78  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  -  START :  a string which must be the same as the starting rule.
  -  SUPPRESS :  either a string or an array of strings. These rules will be
                 removed from the Node. 
  -  P :  The lpeg P function.  Recognizes a certain pattern.
  -  V :  The lpeg V function.  Used for non-terminal rvalues in a grammar. 

"]
// END RANK raw_77

section_14 -> { header_79 prose_80 prose_81 prose_82 prose_83 prose_84}
{rank=same; header_79 prose_80 prose_81 prose_82 prose_83 prose_84}

header_79 [label="3 : metas"]

prose_80 [label="prose"]

prose_81 [label="prose"]

prose_82 [label="prose"]

prose_83 [label="prose"]

prose_84 [label="prose"]


// END RANK section_14

header_79 -> leaf_85
leaf_85  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** metas"]
// END RANK header_79

prose_80 -> { raw_86}
{rank=same; raw_86}

raw_86 [label="raw"]


// END RANK prose_80

raw_86 -> leaf_87
leaf_87  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  By default a node will inherit from the Node class.  If you want custom behavior,
you must pass in a table of metatable constructors.
"]
// END RANK raw_86

prose_81 -> { raw_88 prespace_89 literal_90 raw_91 prespace_92 literal_93 raw_94 prespace_95 literal_96 raw_97 prespace_98 literal_99 raw_100 prespace_101 literal_102 raw_103 prespace_104 literal_105 raw_106}
{rank=same; raw_88 prespace_89 literal_90 raw_91 prespace_92 literal_93 raw_94 prespace_95 literal_96 raw_97 prespace_98 literal_99 raw_100 prespace_101 literal_102 raw_103 prespace_104 literal_105 raw_106}

raw_88 [label="raw"]

prespace_89 [label="prespace"]

literal_90 [label="literal"]

raw_91 [label="raw"]

prespace_92 [label="prespace"]

literal_93 [label="literal"]

raw_94 [label="raw"]

prespace_95 [label="prespace"]

literal_96 [label="literal"]

raw_97 [label="raw"]

prespace_98 [label="prespace"]

literal_99 [label="literal"]

raw_100 [label="raw"]

prespace_101 [label="prespace"]

literal_102 [label="literal"]

raw_103 [label="raw"]

prespace_104 [label="prespace"]

literal_105 [label="literal"]

raw_106 [label="raw"]


// END RANK prose_81

raw_88 -> leaf_107
leaf_107  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
That's a fairly specific beast.  Any rule defined above will have an"]
// END RANK raw_88

prespace_89 -> leaf_108
leaf_108  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_89

literal_90 -> leaf_109
leaf_109  [color=Gray,shape=rectangle,fontname=Inconsolata,label="id"]
// END RANK literal_90

raw_91 -> leaf_110
leaf_110  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
corresonding to the name of the rule.  Unless"]
// END RANK raw_91

prespace_92 -> leaf_111
leaf_111  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_92

literal_93 -> leaf_112
leaf_112  [color=Gray,shape=rectangle,fontname=Inconsolata,label="SUPPRESS"]
// END RANK literal_93

raw_94 -> leaf_113
leaf_113  [color=Gray,shape=rectangle,fontname=Inconsolata,label="ed, this will become
a Node.  If the"]
// END RANK raw_94

prespace_95 -> leaf_114
leaf_114  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_95

literal_96 -> leaf_115
leaf_115  [color=Gray,shape=rectangle,fontname=Inconsolata,label="metas"]
// END RANK literal_96

raw_97 -> leaf_116
leaf_116  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" parameter has a key corresponding to"]
// END RANK raw_97

prespace_98 -> leaf_117
leaf_117  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_98

literal_99 -> leaf_118
leaf_118  [color=Gray,shape=rectangle,fontname=Inconsolata,label="id"]
// END RANK literal_99

raw_100 -> leaf_119
leaf_119  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", then it
must return a function taking two parameters:
   
   - node :  The node under construction, which under normal circumstances will
             already have the"]
// END RANK raw_100

prespace_101 -> leaf_120
leaf_120  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_101

literal_102 -> leaf_121
leaf_121  [color=Gray,shape=rectangle,fontname=Inconsolata,label="first"]
// END RANK literal_102

raw_103 -> leaf_122
leaf_122  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" and"]
// END RANK raw_103

prespace_104 -> leaf_123
leaf_123  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_104

literal_105 -> leaf_124
leaf_124  [color=Gray,shape=rectangle,fontname=Inconsolata,label="last"]
// END RANK literal_105

raw_106 -> leaf_125
leaf_125  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" fields.
   - str  :  The entire str the grammar is parsing.
"]
// END RANK raw_106

prose_82 -> { raw_126}
{rank=same; raw_126}

raw_126 [label="raw"]


// END RANK prose_82

raw_126 -> leaf_127
leaf_127  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Which must return that same node, decorated in whatever fashion is appropriate.
"]
// END RANK raw_126

prose_83 -> { raw_128 prespace_129 literal_130 raw_131 prespace_132 literal_133 raw_134}
{rank=same; raw_128 prespace_129 literal_130 raw_131 prespace_132 literal_133 raw_134}

raw_128 [label="raw"]

prespace_129 [label="prespace"]

literal_130 [label="literal"]

raw_131 [label="raw"]

prespace_132 [label="prespace"]

literal_133 [label="literal"]

raw_134 [label="raw"]


// END RANK prose_83

raw_128 -> leaf_135
leaf_135  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The node will not have a metatable at this point, and the function must attach a
metatable with"]
// END RANK raw_128

prespace_129 -> leaf_136
leaf_136  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_129

literal_130 -> leaf_137
leaf_137  [color=Gray,shape=rectangle,fontname=Inconsolata,label="__index"]
// END RANK literal_130

raw_131 -> leaf_138
leaf_138  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" equal to some table which itself has the"]
// END RANK raw_131

prespace_132 -> leaf_139
leaf_139  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_132

literal_133 -> leaf_140
leaf_140  [color=Gray,shape=rectangle,fontname=Inconsolata,label="__index"]
// END RANK literal_133

raw_134 -> leaf_141
leaf_141  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Node as some recursive backstop.
"]
// END RANK raw_134

prose_84 -> { raw_142 prespace_143 italic_144 raw_145}
{rank=same; raw_142 prespace_143 italic_144 raw_145}

raw_142 [label="raw"]

prespace_143 [label="prespace"]

italic_144 [label="italic"]

raw_145 [label="raw"]


// END RANK prose_84

raw_142 -> leaf_146
leaf_146  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
You might say the return value must"]
// END RANK raw_142

prespace_143 -> leaf_147
leaf_147  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_143

italic_144 -> leaf_148
leaf_148  [color=Gray,shape=rectangle,fontname=Inconsolata,label="inherit"]
// END RANK italic_144

raw_145 -> leaf_149
leaf_149  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" from Node, if we were using
a language that did that sort of thing. 

"]
// END RANK raw_145

section_15 -> { header_150 prose_151 prose_152 prose_153 codeblock_154 prose_155 prose_156 codeblock_157}
{rank=same; header_150 prose_151 prose_152 prose_153 codeblock_154 prose_155 prose_156 codeblock_157}

header_150 [label="3 : includes"]

prose_151 [label="prose"]

prose_152 [label="prose"]

prose_153 [label="prose"]

codeblock_154 [label="code block 83-96"]

prose_155 [label="prose"]

prose_156 [label="prose"]

codeblock_157 [label="code block 102-117"]


// END RANK section_15

header_150 -> leaf_158
leaf_158  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** includes"]
// END RANK header_150

prose_151 -> { raw_159}
{rank=same; raw_159}

raw_159 [label="raw"]


// END RANK prose_151

raw_159 -> leaf_160
leaf_160  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


- [ ] #todo  Note the require strings below, which prevent this from
             being a usable library. 
"]
// END RANK raw_159

prose_152 -> { raw_161 prespace_162 literal_163 raw_164 prespace_165 literal_166 raw_167}
{rank=same; raw_161 prespace_162 literal_163 raw_164 prespace_165 literal_166 raw_167}

raw_161 [label="raw"]

prespace_162 [label="prespace"]

literal_163 [label="literal"]

raw_164 [label="raw"]

prespace_165 [label="prespace"]

literal_166 [label="literal"]

raw_167 [label="raw"]


// END RANK prose_152

raw_161 -> leaf_168
leaf_168  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
             The problem is almost a philosophical one, and it's what I'm
             setting out to solve with"]
// END RANK raw_161

prespace_162 -> leaf_169
leaf_169  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_162

literal_163 -> leaf_170
leaf_170  [color=Gray,shape=rectangle,fontname=Inconsolata,label="bridge"]
// END RANK literal_163

raw_164 -> leaf_171
leaf_171  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" and"]
// END RANK raw_164

prespace_165 -> leaf_172
leaf_172  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_165

literal_166 -> leaf_173
leaf_173  [color=Gray,shape=rectangle,fontname=Inconsolata,label="manifest"]
// END RANK literal_166

raw_167 -> leaf_174
leaf_174  [color=Gray,shape=rectangle,fontname=Inconsolata,label=". 
"]
// END RANK raw_167

prose_153 -> { raw_175 prespace_176 literal_177 raw_178}
{rank=same; raw_175 prespace_176 literal_177 raw_178}

raw_175 [label="raw"]

prespace_176 [label="prespace"]

literal_177 [label="literal"]

raw_178 [label="raw"]


// END RANK prose_153

raw_175 -> leaf_179
leaf_179  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
             In the meantime,"]
// END RANK raw_175

prespace_176 -> leaf_180
leaf_180  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_176

literal_177 -> leaf_181
leaf_181  [color=Gray,shape=rectangle,fontname=Inconsolata,label="lpegnode"]
// END RANK literal_177

raw_178 -> leaf_182
leaf_182  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" has one consumer. Let's keep it
             happy. 
"]
// END RANK raw_178

codeblock_154 -> leaf_183
leaf_183  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local L = require \"lpeg\"

local s = require \"status\" ()
s.verbose = false
s.angry   = false

local a = require \"ansi\"

local Node = require \"node/node\"
local elpatt = require \"node/elpatt\"

local DROP = elpatt.DROP"]
// END RANK codeblock_154

prose_155 -> { raw_184}
{rank=same; raw_184}

raw_184 [label="raw"]


// END RANK prose_155

raw_184 -> leaf_185
leaf_185  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I like the dedication shown in this style of import.
"]
// END RANK raw_184

prose_156 -> { raw_186}
{rank=same; raw_186}

raw_186 [label="raw"]


// END RANK prose_156

raw_186 -> leaf_187
leaf_187  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
It's the kind of thing I'd like to automate. 
"]
// END RANK raw_186

codeblock_157 -> leaf_188
leaf_188  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local assert = assert
local string, io = assert( string ), assert( io )
local V = string.sub( assert( _VERSION ), -4 )
local _G = assert( _G )
local error = assert( error )
local pairs = assert( pairs )
local next = assert( next )
local type = assert( type )
local tostring = assert( tostring )
local setmetatable = assert( setmetatable )
if V == \" 5.1\" then
   local setfenv = assert( setfenv )
   local getfenv = assert( getfenv )
end"]
// END RANK codeblock_157

section_16 -> { header_189 prose_190 codeblock_191 section_192 section_193}
{rank=same; header_189 prose_190 codeblock_191 section_192 section_193}

header_189 [label="3 : make_ast_node"]

prose_190 [label="prose"]

codeblock_191 [label="code block 125-127"]

section_192 [label="section: 130-160"]

section_193 [label="section: 161-344"]


// END RANK section_16

header_189 -> leaf_194
leaf_194  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** make_ast_node"]
// END RANK header_189

prose_190 -> { raw_195}
{rank=same; raw_195}

raw_195 [label="raw"]


// END RANK prose_190

raw_195 -> leaf_196
leaf_196  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  This takes a lot of parameters and does a lot of things. 

"]
// END RANK raw_195

codeblock_191 -> leaf_197
leaf_197  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function make_ast_node(id, first, t, last, str, metas, offset)"]
// END RANK codeblock_191

section_192 -> { header_198 prose_199 prose_200 codeblock_201}
{rank=same; header_198 prose_199 prose_200 codeblock_201}

header_198 [label="4 : setup values and metatables"]

prose_199 [label="prose"]

prose_200 [label="prose"]

codeblock_201 [label="code block 140-158"]


// END RANK section_192

header_198 -> leaf_202
leaf_202  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** setup values and metatables"]
// END RANK header_198

prose_199 -> { raw_203 link_204 raw_205}
{rank=same; raw_203 link_204 raw_205}

raw_203 [label="raw"]

link_204 [label="link"]

raw_205 [label="raw"]


// END RANK prose_199

raw_203 -> leaf_206
leaf_206  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  As "]
// END RANK raw_203

link_204 -> { anchortext_207 url_208}
{rank=same; anchortext_207 url_208}

anchortext_207 [label="anchortext"]

url_208 [label="url"]


// END RANK link_204

anchortext_207 -> leaf_209
leaf_209  [color=Gray,shape=rectangle,fontname=Inconsolata,label="covered elsewhere"]
// END RANK anchortext_207

url_208 -> leaf_210
leaf_210  [color=Gray,shape=rectangle,fontname=Inconsolata,label="httk://"]
// END RANK url_208

raw_205 -> leaf_211
leaf_211  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", we accept three varieties of
metatable verb.  An ordinary table is assigned; a table with __call is 
called, as is an ordinary function.
"]
// END RANK raw_205

prose_200 -> { raw_212 prespace_213 literal_214 raw_215 prespace_216 literal_217 raw_218 prespace_219 literal_220 raw_221}
{rank=same; raw_212 prespace_213 literal_214 raw_215 prespace_216 literal_217 raw_218 prespace_219 literal_220 raw_221}

raw_212 [label="raw"]

prespace_213 [label="prespace"]

literal_214 [label="literal"]

raw_215 [label="raw"]

prespace_216 [label="prespace"]

literal_217 [label="literal"]

raw_218 [label="raw"]

prespace_219 [label="prespace"]

literal_220 [label="literal"]

raw_221 [label="raw"]


// END RANK prose_200

raw_212 -> leaf_222
leaf_222  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The latter two are expected to return the original table, now a descendent
of"]
// END RANK raw_212

prespace_213 -> leaf_223
leaf_223  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_213

literal_214 -> leaf_224
leaf_224  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Node"]
// END RANK literal_214

raw_215 -> leaf_225
leaf_225  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".  This need not have an"]
// END RANK raw_215

prespace_216 -> leaf_226
leaf_226  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_216

literal_217 -> leaf_227
leaf_227  [color=Gray,shape=rectangle,fontname=Inconsolata,label="id"]
// END RANK literal_217

raw_218 -> leaf_228
leaf_228  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" field which is the same as the"]
// END RANK raw_218

prespace_219 -> leaf_229
leaf_229  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_219

literal_220 -> leaf_230
leaf_230  [color=Gray,shape=rectangle,fontname=Inconsolata,label="id"]
// END RANK literal_220

raw_221 -> leaf_231
leaf_231  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
parameter.
"]
// END RANK raw_221

codeblock_201 -> leaf_232
leaf_232  [color=Gray,shape=rectangle,fontname=Inconsolata,label="   local offset = offset or 0
   t.first = first + offset
   t.last  = last + offset - 1
   t.str   = str
   if metas[id] then
      local meta = metas[id]
      if type(meta) == \"function\" or meta.__call then
        t = metas[id](t, str)
      else
        t = setmetatable(t, meta)
      end
      assert(t.id, \"no id on Node\")
   else
      t.id = id
       setmetatable(t, {__index = Node,
                     __tostring = Node.toString})
   end"]
// END RANK codeblock_201

section_193 -> { header_233 prose_234 prose_235 prose_236 prose_237 prose_238 prose_239 prose_240 prose_241 prose_242 prose_243 prose_244 prose_245 codeblock_246 codeblock_247}
{rank=same; header_233 prose_234 prose_235 prose_236 prose_237 prose_238 prose_239 prose_240 prose_241 prose_242 prose_243 prose_244 prose_245 codeblock_246 codeblock_247}

header_233 [label="4 : DROP"]

prose_234 [label="prose"]

prose_235 [label="prose"]

prose_236 [label="prose"]

prose_237 [label="prose"]

prose_238 [label="prose"]

prose_239 [label="prose"]

prose_240 [label="prose"]

prose_241 [label="prose"]

prose_242 [label="prose"]

prose_243 [label="prose"]

prose_244 [label="prose"]

prose_245 [label="prose"]

codeblock_246 [label="code block 205-321"]

codeblock_247 [label="code block 323-342"]


// END RANK section_193

header_233 -> leaf_248
leaf_248  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" DROP

  T"]
// END RANK header_233

prose_234 -> { raw_249 prespace_250 literal_251 raw_252}
{rank=same; raw_249 prespace_250 literal_251 raw_252}

raw_249 [label="raw"]

prespace_250 [label="prespace"]

literal_251 [label="literal"]

raw_252 [label="raw"]


// END RANK prose_234

raw_249 -> leaf_253
leaf_253  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  The rule"]
// END RANK raw_249

prespace_250 -> leaf_254
leaf_254  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_250

literal_251 -> leaf_255
leaf_255  [color=Gray,shape=rectangle,fontname=Inconsolata,label="elpatt.D"]
// END RANK literal_251

raw_252 -> leaf_256
leaf_256  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" causes the match to be dropped. In order for
this to give use the results we want, we must adjust the peer and
parent nodes while removing the captured element from the table. 
"]
// END RANK raw_252

prose_235 -> { raw_257 prespace_258 literal_259 raw_260}
{rank=same; raw_257 prespace_258 literal_259 raw_260}

raw_257 [label="raw"]

prespace_258 [label="prespace"]

literal_259 [label="literal"]

raw_260 [label="raw"]


// END RANK prose_235

raw_257 -> leaf_261
leaf_261  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The use case is for eloquently expressed 'wrapper' patterns, which occur
frequently in real languages. In a"]
// END RANK raw_257

prespace_258 -> leaf_262
leaf_262  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_258

literal_259 -> leaf_263
leaf_263  [color=Gray,shape=rectangle,fontname=Inconsolata,label="(typical lisp expression)"]
// END RANK literal_259

raw_260 -> leaf_264
leaf_264  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" we don't need
the parentheses and would like our span not to include them.
"]
// END RANK raw_260

prose_236 -> { raw_265 prespace_266 literal_267 raw_268 prespace_269 literal_270 raw_271 prespace_272 literal_273 raw_274}
{rank=same; raw_265 prespace_266 literal_267 raw_268 prespace_269 literal_270 raw_271 prespace_272 literal_273 raw_274}

raw_265 [label="raw"]

prespace_266 [label="prespace"]

literal_267 [label="literal"]

raw_268 [label="raw"]

prespace_269 [label="prespace"]

literal_270 [label="literal"]

raw_271 [label="raw"]

prespace_272 [label="prespace"]

literal_273 [label="literal"]

raw_274 [label="raw"]


// END RANK prose_236

raw_265 -> leaf_275
leaf_275  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
We could use a pattern like"]
// END RANK raw_265

prespace_266 -> leaf_276
leaf_276  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_266

literal_267 -> leaf_277
leaf_277  [color=Gray,shape=rectangle,fontname=Inconsolata,label="V\"formwrap\""]
// END RANK literal_267

raw_268 -> leaf_278
leaf_278  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" and then SUPPRESS"]
// END RANK raw_268

prespace_269 -> leaf_279
leaf_279  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_269

literal_270 -> leaf_280
leaf_280  [color=Gray,shape=rectangle,fontname=Inconsolata,label="formwrap"]
// END RANK literal_270

raw_271 -> leaf_281
leaf_281  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", but
this is less eloquent than"]
// END RANK raw_271

prespace_272 -> leaf_282
leaf_282  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_272

literal_273 -> leaf_283
leaf_283  [color=Gray,shape=rectangle,fontname=Inconsolata,label="D(P\"(\") * V\"form\" *  D(P\")\")"]
// END RANK literal_273

raw_274 -> leaf_284
leaf_284  [color=Gray,shape=rectangle,fontname=Inconsolata,label=". 
"]
// END RANK raw_274

prose_237 -> { raw_285 prespace_286 literal_287 raw_288}
{rank=same; raw_285 prespace_286 literal_287 raw_288}

raw_285 [label="raw"]

prespace_286 [label="prespace"]

literal_287 [label="literal"]

raw_288 [label="raw"]


// END RANK prose_237

raw_285 -> leaf_289
leaf_289  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Which is admittedly hard to look at.  We prefer the form"]
// END RANK raw_285

prespace_286 -> leaf_290
leaf_290  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
// END RANK prespace_286

literal_287 -> leaf_291
leaf_291  [color=Gray,shape=rectangle,fontname=Inconsolata,label="D(pal) * V\"form\" * D(par)"]
// END RANK literal_287

raw_288 -> leaf_292
leaf_292  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" for this reason among others.
"]
// END RANK raw_288

prose_238 -> { raw_293 prespace_294 literal_295 raw_296}
{rank=same; raw_293 prespace_294 literal_295 raw_296}

raw_293 [label="raw"]

prespace_294 [label="prespace"]

literal_295 [label="literal"]

raw_296 [label="raw"]


// END RANK prose_238

raw_293 -> leaf_297
leaf_297  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The algorithm moves from the right to the left, because"]
// END RANK raw_293

prespace_294 -> leaf_298
leaf_298  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_294

literal_295 -> leaf_299
leaf_299  [color=Gray,shape=rectangle,fontname=Inconsolata,label="table.remove(t)"]
// END RANK literal_295

raw_296 -> leaf_300
leaf_300  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
is O(1) so we can strip any amount of rightward droppage first.  It is
correspondingly more expensive to strip middle drops, and most expensive
to strip leftmost drops.
"]
// END RANK raw_296

prose_239 -> { raw_301 prespace_302 literal_303 raw_304}
{rank=same; raw_301 prespace_302 literal_303 raw_304}

raw_301 [label="raw"]

prespace_302 [label="prespace"]

literal_303 [label="literal"]

raw_304 [label="raw"]


// END RANK prose_239

raw_301 -> leaf_305
leaf_305  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
More importantly, if we counted up, we'd be tracking"]
// END RANK raw_301

prespace_302 -> leaf_306
leaf_306  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_302

literal_303 -> leaf_307
leaf_307  [color=Gray,shape=rectangle,fontname=Inconsolata,label="#t"]
// END RANK literal_303

raw_304 -> leaf_308
leaf_308  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", a moving target.
Counting to 1 neatly prevents this.
"]
// END RANK raw_304

prose_240 -> { raw_309}
{rank=same; raw_309}

raw_309 [label="raw"]


// END RANK prose_240

raw_309 -> leaf_310
leaf_310  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
   -  [ ] #Todo :Faster:
"]
// END RANK raw_309

prose_241 -> { raw_311}
{rank=same; raw_311}

raw_311 [label="raw"]


// END RANK prose_241

raw_311 -> leaf_312
leaf_312  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
     -  This algorithm, as we discussed, goes quadratic toward the left side.
        The correct way to go is if we see any drop, flip a dirty bit, and 
        compact upward.
"]
// END RANK raw_311

prose_242 -> { raw_313 prespace_314 literal_315 raw_316}
{rank=same; raw_313 prespace_314 literal_315 raw_316}

raw_313 [label="raw"]

prespace_314 [label="prespace"]

literal_315 [label="literal"]

raw_316 [label="raw"]


// END RANK prose_242

raw_313 -> leaf_317
leaf_317  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
     -  More to the point, the mere inclusion of this much"]
// END RANK raw_313

prespace_314 -> leaf_318
leaf_318  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_314

literal_315 -> leaf_319
leaf_319  [color=Gray,shape=rectangle,fontname=Inconsolata,label="s:"]
// END RANK literal_315

raw_316 -> leaf_320
leaf_320  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" slows the 
        algorithm to an utter crawl. The concatenations happen anyway, to
        pass the string into the status module.
"]
// END RANK raw_316

prose_243 -> { raw_321}
{rank=same; raw_321}

raw_321 [label="raw"]


// END RANK prose_243

raw_321 -> leaf_322
leaf_322  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
        This is probably 10x the cost in real work.
"]
// END RANK raw_321

prose_244 -> { raw_323}
{rank=same; raw_323}

raw_323 [label="raw"]


// END RANK prose_244

raw_323 -> leaf_324
leaf_324  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
        Why am I doing it in such a dumb way? This is a literate programming
        environment, and I'm building a language with templates and macros
        and other useful access to state at compile time.
"]
// END RANK raw_323

prose_245 -> { raw_325}
{rank=same; raw_325}

raw_325 [label="raw"]


// END RANK prose_245

raw_325 -> leaf_326
leaf_326  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
        That's two ways to remove the verbosity and other printfs when they
        aren't wanted.  Better to simulate the correct behavior until I can
        provide it. 
"]
// END RANK raw_325

codeblock_246 -> leaf_327
leaf_327  [color=Gray,shape=rectangle,fontname=Inconsolata,label="   for i = #t, 1, -1 do
      t[i].parent = t
      local cap = t[i] 
      if type(cap) ~= \"table\" then
         s:complain(\"CAPTURE ISSUE\", 
                    \"type of capture subgroup is \" .. type(v) .. \"\\n\")
      end
      if cap.DROP == DROP then
         s:verb(\"drops in \" .. a.bright(t.id))
         if i == #t then
            s:verb(a.red(\"rightmost\") .. \" remaining node\")
            s:verb(\"  t.$: \" .. tostring(t.last) .. \" Δ: \"
                   .. tostring(cap.last - cap.first))
            t.last = t.last - (cap.last - cap.first)
            table.remove(t)
            s:verb(\"  new t.$: \" .. tostring(t.last))
         else
            -- Here we may be either in the middle or at the leftmost
            -- margin.  Leftmost means either we're at index 1, or that
            -- all children to the left, down to 1, are all DROPs. 
            local leftmost = (i == 1)
            if leftmost then
               s:verb(a.cyan(\"  leftmost\") .. \" remaining node\")
               s:verb(\"    t.^: \" .. tostring(t.first)
                      .. \" D.$: \" .. tostring(cap.last))
               t.first = cap.last
               s:verb(\"    new t.^: \" .. tostring(t.first))
               table.remove(t, 1)
            else
               leftmost = true -- provisionally since cap.DROP
               for j = i, 1, -1 do
                 leftmost = leftmost and t[j].DROP
                 if not leftmost then break end
               end
               if leftmost then
                  s:verb(a.cyan(\"  leftmost inner\") .. \" remaining node\")
                  s:verb(\"    t.^: \" .. tostring(t.first)
                         .. \" D.$: \" .. tostring(cap.last))
                  t.first = cap.last
                  s:verb(\"    new t.^: \" .. tostring(t.first))
                  for j = i, 1, -1 do
                     -- this is quadradic but correct 
                     -- and easy to understand.
                     table.remove(t, j)
                     break
                  end
               else
                  s:verb(a.green(\"  middle\") .. \" node dropped\")
                  table.remove(t, i)
               end
            end
         end
      end 
   end
   assert(t.isNode, \"failed isNode: \" .. id)
   assert(t.str)
   return t
end


-- some useful/common lpeg patterns
local Cp = L.Cp
local Cc = L.Cc
local Ct = L.Ct
local arg1_str = L.Carg(1)
local arg2_metas = L.Carg(2)
local arg3_offset = L.Carg(3)


-- setup an environment where you can easily define lpeg grammars
-- with lots of syntax sugar
local function define(func, g, e)
  g = g or {}
  if e == nil then
    e = V == \" 5.1\" and getfenv(func) or _G
  end
  local suppressed = {}
  local env = {}
  local env_index = {
    START = function(name) g[1] = name end,
    SUPPRESS = function(...)
      suppressed = {}
      for i = 1, select('#', ...) do
        suppressed[select(i, ... )] = true
      end
    end,
    V = L.V,
    P = L.P,
  }

  setmetatable(env_index, { __index = e })
  setmetatable(env, {
    __index = env_index,
    __newindex = function( _, name, val )
      if suppressed[ name ] then
        g[ name ] = val
      else
        g[ name ] = (Cc(name) 
              * Cp() 
              * Ct(val)
              * Cp()
              * arg1_str
              * arg2_metas)
              * arg3_offset / make_ast_node
      end
    end
  })
  -- call passed function with custom environment (5.1- and 5.2-style)
  if V == \" 5.1\" then
    setfenv( func, env )
  end
  func( env )
  assert( g[ 1 ] and g[ g[ 1 ] ], \"no start rule defined\" )
  return g
end"]
// END RANK codeblock_246

codeblock_247 -> leaf_328
leaf_328  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function refineMetas(metas)
  s:verb(\"refining metatables\")
  for id, meta in pairs(metas) do
    s:verb(\"  id: \" .. id .. \" type: \" .. type(meta))
    if type(meta) == \"table\" then
      if not meta[\"__tostring\"] then
        meta[\"__tostring\"] = Node.toString
      end
      if not meta.id then
        s:verb(\"    inserting metatable id: \" .. id)
        meta.id = id
      else
        s:verb(\"    id of \" .. id .. \" is \" .. meta.id)
      end
    end
  end
  return metas
end"]
// END RANK codeblock_247

section_5 -> { header_329 prose_330 codeblock_331 codeblock_332}
{rank=same; header_329 prose_330 codeblock_331 codeblock_332}

header_329 [label="2 : new"]

prose_330 [label="prose"]

codeblock_331 [label="code block 350-386"]

codeblock_332 [label="code block 388-390"]


// END RANK section_5

header_329 -> leaf_333
leaf_333  [color=Gray,shape=rectangle,fontname=Inconsolata,label="r_templ"]
// END RANK header_329

prose_330 -> { raw_334 prespace_335 literal_336 raw_337}
{rank=same; raw_334 prespace_335 literal_336 raw_337}

raw_334 [label="raw"]

prespace_335 [label="prespace"]

literal_336 [label="literal"]

raw_337 [label="raw"]


// END RANK prose_330

raw_334 -> leaf_338
leaf_338  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Given a grammar_template function and a set of metatables,
yield a parsing function and the grammar as an"]
// END RANK raw_334

prespace_335 -> leaf_339
leaf_339  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_335

literal_336 -> leaf_340
leaf_340  [color=Gray,shape=rectangle,fontname=Inconsolata,label="lpeg"]
// END RANK literal_336

raw_337 -> leaf_341
leaf_341  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" pattern.
"]
// END RANK raw_337

codeblock_331 -> leaf_342
leaf_342  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function new(grammar_template, metas)
  if type(grammar_template) == \"function\" then
    local metas = metas or {}
    metas = refineMetas(metas)
    local grammar = define(grammar_template, nil, metas)

    local function parse(str, offset)
      local offset = offset or 0
      local match = L.match(grammar, str, 1, str, metas, offset)
      local maybeErr = match:lastLeaf()
      if maybeErr.id then
        if maybeErr.id == \"ERROR\" then
          local line, col = match:linePos(maybeErr.first)
          local msg = maybeErr.msg or \"\"
          s:complain(\"Parsing Error\", \" line: \" .. tostring(line) .. \", \"
                     .. \"col: \" .. tostring(col) .. \". \" .. msg)
          return match, match:lastLeaf()
        else
          return match
        end
      else
          local maybeNode = maybeErr.isNode and \" is \" or \" isn't \"
          s:complain(\"No id on match\" .. \"match of type, \" .. type(match)
                    .. maybeNode .. \" a Node: \" .. tostring(maybeErr))
      end

      -- This would be a bad match. 
      return match
    end

    return parse, grammar
  else
    s:halt(\"no way to build grammar out of \" .. type(template))
  end
end"]
// END RANK codeblock_331

codeblock_332 -> leaf_343
leaf_343  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return new"]
// END RANK codeblock_332


}
