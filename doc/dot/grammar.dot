digraph lpegNode {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 398"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-352"]


// END RANK doc_0

section_1 -> { header_2 prose_3 codeblock_4 section_5 section_6}
{rank=same; header_2 prose_3 codeblock_4 section_5 section_6}

header_2 [label="1 : Grammar Module"]

prose_3 [label="prose"]

codeblock_4 [label="code block 6-10"]

section_5 [label="section: 12-118"]

section_6 [label="section: 353-398"]


// END RANK section_1

header_2 -> leaf_7
leaf_7  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Grammar Module"]
// END RANK header_2

prose_3 -> { raw_8}
{rank=same; raw_8}

raw_8 [label="raw"]


// END RANK prose_3

raw_8 -> leaf_9
leaf_9  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  The grammar module returns one function, which generates
a grammar.
"]
// END RANK raw_8

codeblock_4 -> leaf_10
leaf_10  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local s = require \"status\" ()
s.verbose = false
s.angry   = false"]
// END RANK codeblock_4

section_5 -> { header_11 prose_12 prose_13 prose_14 section_15 section_16 section_17 section_18}
{rank=same; header_11 prose_12 prose_13 prose_14 section_15 section_16 section_17 section_18}

header_11 [label="2 : Parameters"]

prose_12 [label="prose"]

prose_13 [label="prose"]

prose_14 [label="prose"]

section_15 [label="section: 22-47"]

section_16 [label="section: 48-72"]

section_17 [label="section: 73-118"]

section_18 [label="section: 119-159"]


// END RANK section_5

header_11 -> leaf_19
leaf_19  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Parameters"]
// END RANK header_11

prose_12 -> { raw_20}
{rank=same; raw_20}

raw_20 [label="raw"]


// END RANK prose_12

raw_20 -> leaf_21
leaf_21  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This function takes two parameters, namely:
"]
// END RANK raw_20

prose_13 -> { raw_22 prespace_23 literal_24 raw_25}
{rank=same; raw_22 prespace_23 literal_24 raw_25}

raw_22 [label="raw"]

prespace_23 [label="prespace"]

literal_24 [label="literal"]

raw_25 [label="raw"]


// END RANK prose_13

raw_22 -> leaf_26
leaf_26  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  - grammar_template :  A function with one parameter, which must be"]
// END RANK raw_22

prespace_23 -> leaf_27
leaf_27  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_23

literal_24 -> leaf_28
leaf_28  [color=Gray,shape=rectangle,fontname=Inconsolata,label="_ENV"]
// END RANK literal_24

raw_25 -> leaf_29
leaf_29  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
  - metas :  A map with keys of string and values of Node subclass constructors.
"]
// END RANK raw_25

prose_14 -> { raw_30}
{rank=same; raw_30}

raw_30 [label="raw"]


// END RANK prose_14

raw_30 -> leaf_31
leaf_31  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Both of these are reasonably complex.

"]
// END RANK raw_30

section_15 -> { header_32 prose_33 prose_34 prose_35 prose_36 prose_37 prose_38 prose_39}
{rank=same; header_32 prose_33 prose_34 prose_35 prose_36 prose_37 prose_38 prose_39}

header_32 [label="3 : grammar_template"]

prose_33 [label="prose"]

prose_34 [label="prose"]

prose_35 [label="prose"]

prose_36 [label="prose"]

prose_37 [label="prose"]

prose_38 [label="prose"]

prose_39 [label="prose"]


// END RANK section_15

header_32 -> leaf_40
leaf_40  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** grammar_template"]
// END RANK header_32

prose_33 -> { raw_41 prespace_42 literal_43 raw_44}
{rank=same; raw_41 prespace_42 literal_43 raw_44}

raw_41 [label="raw"]

prespace_42 [label="prespace"]

literal_43 [label="literal"]

raw_44 [label="raw"]


// END RANK prose_33

raw_41 -> leaf_45
leaf_45  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  The internal function @define creates a custom environment variable, neatly
sidestepping lua's pedantic insistance on prepending"]
// END RANK raw_41

prespace_42 -> leaf_46
leaf_46  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_42

literal_43 -> leaf_47
leaf_47  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local"]
// END RANK literal_43

raw_44 -> leaf_48
leaf_48  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" to all values of
significance.
"]
// END RANK raw_44

prose_34 -> { raw_49}
{rank=same; raw_49}

raw_49 [label="raw"]


// END RANK prose_34

raw_49 -> leaf_50
leaf_50  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
More relevantly, it constructs a full grammar, which will return a table of
type Node.
"]
// END RANK raw_49

prose_35 -> { raw_51 prespace_52 literal_53 raw_54}
{rank=same; raw_51 prespace_52 literal_53 raw_54}

raw_51 [label="raw"]

prespace_52 [label="prespace"]

literal_53 [label="literal"]

raw_54 [label="raw"]


// END RANK prose_35

raw_51 -> leaf_55
leaf_55  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If you stick to"]
// END RANK raw_51

prespace_52 -> leaf_56
leaf_56  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_52

literal_53 -> leaf_57
leaf_57  [color=Gray,shape=rectangle,fontname=Inconsolata,label="lpeg"]
// END RANK literal_53

raw_54 -> leaf_58
leaf_58  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" patterns, as you should, all array values will be of
Node.  Captures will interpolate various other sorts of Lua values, which will
induce halting in some places and silently corrupt execution in others.
"]
// END RANK raw_54

prose_36 -> { raw_59 link_60 raw_61}
{rank=same; raw_59 link_60 raw_61}

raw_59 [label="raw"]

link_60 [label="link"]

raw_61 [label="raw"]


// END RANK prose_36

raw_59 -> leaf_62
leaf_62  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The "]
// END RANK raw_59

link_60 -> { anchortext_63 url_64}
{rank=same; anchortext_63 url_64}

anchortext_63 [label="anchortext"]

url_64 [label="url"]


// END RANK link_60

anchortext_63 -> leaf_65
leaf_65  [color=Gray,shape=rectangle,fontname=Inconsolata,label="elpatt module"]
// END RANK anchortext_63

url_64 -> leaf_66
leaf_66  [color=Gray,shape=rectangle,fontname=Inconsolata,label="./elpatt"]
// END RANK url_64

raw_61 -> leaf_67
leaf_67  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is intended to provide those patterns which
are allowed in Grammars, while expanding the scope of some favorites to
properly respect utf-8 and otherwise behave.
"]
// END RANK raw_61

prose_37 -> { raw_68 link_69 raw_70}
{rank=same; raw_68 link_69 raw_70}

raw_68 [label="raw"]

link_69 [label="link"]

raw_70 [label="raw"]


// END RANK prose_37

raw_68 -> leaf_71
leaf_71  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
There are examples of the format in the "]
// END RANK raw_68

link_69 -> { anchortext_72 url_73}
{rank=same; anchortext_72 url_73}

anchortext_72 [label="anchortext"]

url_73 [label="url"]


// END RANK link_69

anchortext_72 -> leaf_74
leaf_74  [color=Gray,shape=rectangle,fontname=Inconsolata,label="spec module"]
// END RANK anchortext_72

url_73 -> leaf_75
leaf_75  [color=Gray,shape=rectangle,fontname=Inconsolata,label="./spec"]
// END RANK url_73

raw_70 -> leaf_76
leaf_76  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
"]
// END RANK raw_70

prose_38 -> { raw_77}
{rank=same; raw_77}

raw_77 [label="raw"]


// END RANK prose_38

raw_77 -> leaf_78
leaf_78  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Also included are two functions:
"]
// END RANK raw_77

prose_39 -> { raw_79}
{rank=same; raw_79}

raw_79 [label="raw"]


// END RANK prose_39

raw_79 -> leaf_80
leaf_80  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  -  START :  a string which must be the same as the starting rule.
  -  SUPPRESS :  either a string or an array of strings. These rules will be
                 removed from the Node.

"]
// END RANK raw_79

section_16 -> { header_81 prose_82 prose_83 prose_84 prose_85 prose_86 prose_87}
{rank=same; header_81 prose_82 prose_83 prose_84 prose_85 prose_86 prose_87}

header_81 [label="3 : metas"]

prose_82 [label="prose"]

prose_83 [label="prose"]

prose_84 [label="prose"]

prose_85 [label="prose"]

prose_86 [label="prose"]

prose_87 [label="prose"]


// END RANK section_16

header_81 -> leaf_88
leaf_88  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** metas"]
// END RANK header_81

prose_82 -> { raw_89}
{rank=same; raw_89}

raw_89 [label="raw"]


// END RANK prose_82

raw_89 -> leaf_90
leaf_90  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  By default a node will inherit from the Node class.  If you want custom
behavior, you must pass in a table of metatable constructors.
"]
// END RANK raw_89

prose_83 -> { raw_91 prespace_92 literal_93 raw_94 prespace_95 literal_96 raw_97 prespace_98 literal_99 raw_100 prespace_101 literal_102 raw_103}
{rank=same; raw_91 prespace_92 literal_93 raw_94 prespace_95 literal_96 raw_97 prespace_98 literal_99 raw_100 prespace_101 literal_102 raw_103}

raw_91 [label="raw"]

prespace_92 [label="prespace"]

literal_93 [label="literal"]

raw_94 [label="raw"]

prespace_95 [label="prespace"]

literal_96 [label="literal"]

raw_97 [label="raw"]

prespace_98 [label="prespace"]

literal_99 [label="literal"]

raw_100 [label="raw"]

prespace_101 [label="prespace"]

literal_102 [label="literal"]

raw_103 [label="raw"]


// END RANK prose_83

raw_91 -> leaf_104
leaf_104  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
That's a fairly specific beast.  Any rule defined above will have an"]
// END RANK raw_91

prespace_92 -> leaf_105
leaf_105  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_92

literal_93 -> leaf_106
leaf_106  [color=Gray,shape=rectangle,fontname=Inconsolata,label="id"]
// END RANK literal_93

raw_94 -> leaf_107
leaf_107  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
corresonding to the name of the rule.  Unless"]
// END RANK raw_94

prespace_95 -> leaf_108
leaf_108  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_95

literal_96 -> leaf_109
leaf_109  [color=Gray,shape=rectangle,fontname=Inconsolata,label="SUPPRESS"]
// END RANK literal_96

raw_97 -> leaf_110
leaf_110  [color=Gray,shape=rectangle,fontname=Inconsolata,label="ed, this will become
a Node.  If the"]
// END RANK raw_97

prespace_98 -> leaf_111
leaf_111  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_98

literal_99 -> leaf_112
leaf_112  [color=Gray,shape=rectangle,fontname=Inconsolata,label="metas"]
// END RANK literal_99

raw_100 -> leaf_113
leaf_113  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" parameter has a key corresponding to"]
// END RANK raw_100

prespace_101 -> leaf_114
leaf_114  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_101

literal_102 -> leaf_115
leaf_115  [color=Gray,shape=rectangle,fontname=Inconsolata,label="id"]
// END RANK literal_102

raw_103 -> leaf_116
leaf_116  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", then it
must return a function taking two parameters:
"]
// END RANK raw_103

prose_84 -> { raw_117 prespace_118 literal_119 raw_120 prespace_121 literal_122 raw_123}
{rank=same; raw_117 prespace_118 literal_119 raw_120 prespace_121 literal_122 raw_123}

raw_117 [label="raw"]

prespace_118 [label="prespace"]

literal_119 [label="literal"]

raw_120 [label="raw"]

prespace_121 [label="prespace"]

literal_122 [label="literal"]

raw_123 [label="raw"]


// END RANK prose_84

raw_117 -> leaf_124
leaf_124  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
   - node :  The node under construction, which under normal circumstances will
             already have the"]
// END RANK raw_117

prespace_118 -> leaf_125
leaf_125  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_118

literal_119 -> leaf_126
leaf_126  [color=Gray,shape=rectangle,fontname=Inconsolata,label="first"]
// END RANK literal_119

raw_120 -> leaf_127
leaf_127  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" and"]
// END RANK raw_120

prespace_121 -> leaf_128
leaf_128  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_121

literal_122 -> leaf_129
leaf_129  [color=Gray,shape=rectangle,fontname=Inconsolata,label="last"]
// END RANK literal_122

raw_123 -> leaf_130
leaf_130  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" fields.
   - str  :  The entire str the grammar is parsing.
"]
// END RANK raw_123

prose_85 -> { raw_131}
{rank=same; raw_131}

raw_131 [label="raw"]


// END RANK prose_85

raw_131 -> leaf_132
leaf_132  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Which must return that same node, decorated in whatever fashion is appropriate.
"]
// END RANK raw_131

prose_86 -> { raw_133 prespace_134 literal_135 raw_136 prespace_137 literal_138 raw_139}
{rank=same; raw_133 prespace_134 literal_135 raw_136 prespace_137 literal_138 raw_139}

raw_133 [label="raw"]

prespace_134 [label="prespace"]

literal_135 [label="literal"]

raw_136 [label="raw"]

prespace_137 [label="prespace"]

literal_138 [label="literal"]

raw_139 [label="raw"]


// END RANK prose_86

raw_133 -> leaf_140
leaf_140  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The node will not have a metatable at this point, and the function must attach a
metatable with"]
// END RANK raw_133

prespace_134 -> leaf_141
leaf_141  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_134

literal_135 -> leaf_142
leaf_142  [color=Gray,shape=rectangle,fontname=Inconsolata,label="__index"]
// END RANK literal_135

raw_136 -> leaf_143
leaf_143  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" equal to some table which itself has the"]
// END RANK raw_136

prespace_137 -> leaf_144
leaf_144  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_137

literal_138 -> leaf_145
leaf_145  [color=Gray,shape=rectangle,fontname=Inconsolata,label="__index"]
// END RANK literal_138

raw_139 -> leaf_146
leaf_146  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Node as some recursive backstop.
"]
// END RANK raw_139

prose_87 -> { raw_147 prespace_148 italic_149 raw_150}
{rank=same; raw_147 prespace_148 italic_149 raw_150}

raw_147 [label="raw"]

prespace_148 [label="prespace"]

italic_149 [label="italic"]

raw_150 [label="raw"]


// END RANK prose_87

raw_147 -> leaf_151
leaf_151  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
You might say the return value must"]
// END RANK raw_147

prespace_148 -> leaf_152
leaf_152  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_148

italic_149 -> leaf_153
leaf_153  [color=Gray,shape=rectangle,fontname=Inconsolata,label="inherit"]
// END RANK italic_149

raw_150 -> leaf_154
leaf_154  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" from Node, if we were using
a language that did that sort of thing.


"]
// END RANK raw_150

section_17 -> { header_155 prose_156 prose_157 prose_158 prose_159 codeblock_160 prose_161 prose_162 codeblock_163}
{rank=same; header_155 prose_156 prose_157 prose_158 prose_159 codeblock_160 prose_161 prose_162 codeblock_163}

header_155 [label="3 : includes"]

prose_156 [label="prose"]

prose_157 [label="prose"]

prose_158 [label="prose"]

prose_159 [label="prose"]

codeblock_160 [label="code block 87-95"]

prose_161 [label="prose"]

prose_162 [label="prose"]

codeblock_163 [label="code block 101-116"]


// END RANK section_17

header_155 -> leaf_164
leaf_164  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** includes"]
// END RANK header_155

prose_156 -> { raw_165 prespace_166 literal_167 raw_168 prespace_169 literal_170 raw_171}
{rank=same; raw_165 prespace_166 literal_167 raw_168 prespace_169 literal_170 raw_171}

raw_165 [label="raw"]

prespace_166 [label="prespace"]

literal_167 [label="literal"]

raw_168 [label="raw"]

prespace_169 [label="prespace"]

literal_170 [label="literal"]

raw_171 [label="raw"]


// END RANK prose_156

raw_165 -> leaf_172
leaf_172  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


- [ ] #todo  Note the require strings below, which prevent this from
             being a usable library, because"]
// END RANK raw_165

prespace_166 -> leaf_173
leaf_173  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_166

literal_167 -> leaf_174
leaf_174  [color=Gray,shape=rectangle,fontname=Inconsolata,label="node"]
// END RANK literal_167

raw_168 -> leaf_175
leaf_175  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" not"]
// END RANK raw_168

prespace_169 -> leaf_176
leaf_176  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_169

literal_170 -> leaf_177
leaf_177  [color=Gray,shape=rectangle,fontname=Inconsolata,label="lpegnode"]
// END RANK literal_170

raw_171 -> leaf_178
leaf_178  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
"]
// END RANK raw_171

prose_157 -> { raw_179 prespace_180 literal_181 raw_182 prespace_183 literal_184 raw_185}
{rank=same; raw_179 prespace_180 literal_181 raw_182 prespace_183 literal_184 raw_185}

raw_179 [label="raw"]

prespace_180 [label="prespace"]

literal_181 [label="literal"]

raw_182 [label="raw"]

prespace_183 [label="prespace"]

literal_184 [label="literal"]

raw_185 [label="raw"]


// END RANK prose_157

raw_179 -> leaf_186
leaf_186  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
             The problem is almost a philosophical one, and it's what I'm
             setting out to solve with"]
// END RANK raw_179

prespace_180 -> leaf_187
leaf_187  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_180

literal_181 -> leaf_188
leaf_188  [color=Gray,shape=rectangle,fontname=Inconsolata,label="bridge"]
// END RANK literal_181

raw_182 -> leaf_189
leaf_189  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" and"]
// END RANK raw_182

prespace_183 -> leaf_190
leaf_190  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_183

literal_184 -> leaf_191
leaf_191  [color=Gray,shape=rectangle,fontname=Inconsolata,label="manifest"]
// END RANK literal_184

raw_185 -> leaf_192
leaf_192  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
"]
// END RANK raw_185

prose_158 -> { raw_193 prespace_194 literal_195 raw_196}
{rank=same; raw_193 prespace_194 literal_195 raw_196}

raw_193 [label="raw"]

prespace_194 [label="prespace"]

literal_195 [label="literal"]

raw_196 [label="raw"]


// END RANK prose_158

raw_193 -> leaf_197
leaf_197  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
             In the meantime,"]
// END RANK raw_193

prespace_194 -> leaf_198
leaf_198  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_194

literal_195 -> leaf_199
leaf_199  [color=Gray,shape=rectangle,fontname=Inconsolata,label="lpegnode"]
// END RANK literal_195

raw_196 -> leaf_200
leaf_200  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" has one consumer. Let's keep it
             happy.
"]
// END RANK raw_196

prose_159 -> { raw_201 prespace_202 literal_203 raw_204}
{rank=same; raw_201 prespace_202 literal_203 raw_204}

raw_201 [label="raw"]

prespace_202 [label="prespace"]

literal_203 [label="literal"]

raw_204 [label="raw"]


// END RANK prose_159

raw_201 -> leaf_205
leaf_205  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
             I'm renaming it"]
// END RANK raw_201

prespace_202 -> leaf_206
leaf_206  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_202

literal_203 -> leaf_207
leaf_207  [color=Gray,shape=rectangle,fontname=Inconsolata,label="espalier"]
// END RANK literal_203

raw_204 -> leaf_208
leaf_208  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" anyway.
"]
// END RANK raw_204

codeblock_160 -> leaf_209
leaf_209  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local L = require \"lpeg\"
local a = require \"anterm\"

local Node = require \"espalier/node\"
local elpatt = require \"espalier/elpatt\"

local DROP = elpatt.DROP"]
// END RANK codeblock_160

prose_161 -> { raw_210}
{rank=same; raw_210}

raw_210 [label="raw"]


// END RANK prose_161

raw_210 -> leaf_211
leaf_211  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I like the dedication shown in this style of import.
"]
// END RANK raw_210

prose_162 -> { raw_212}
{rank=same; raw_212}

raw_212 [label="raw"]


// END RANK prose_162

raw_212 -> leaf_213
leaf_213  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
It's the kind of thing I'd like to automate.
"]
// END RANK raw_212

codeblock_163 -> leaf_214
leaf_214  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local assert = assert
local string, io = assert( string ), assert( io )
local VER = string.sub( assert( _VERSION ), -4 )
local _G = assert( _G )
local error = assert( error )
local pairs = assert( pairs )
local next = assert( next )
local type = assert( type )
local tostring = assert( tostring )
local setmetatable = assert( setmetatable )
if VER == \" 5.1\" then
   local setfenv = assert( setfenv )
   local getfenv = assert( getfenv )
end"]
// END RANK codeblock_163

section_18 -> { header_215 prose_216 codeblock_217 section_218 section_219}
{rank=same; header_215 prose_216 codeblock_217 section_218 section_219}

header_215 [label="3 : make_ast_node"]

prose_216 [label="prose"]

codeblock_217 [label="code block 124-126"]

section_218 [label="section: 129-159"]

section_219 [label="section: 160-352"]


// END RANK section_18

header_215 -> leaf_220
leaf_220  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** make_ast_node"]
// END RANK header_215

prose_216 -> { raw_221}
{rank=same; raw_221}

raw_221 [label="raw"]


// END RANK prose_216

raw_221 -> leaf_222
leaf_222  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  This takes a lot of parameters and does a lot of things.

"]
// END RANK raw_221

codeblock_217 -> leaf_223
leaf_223  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function make_ast_node(id, first, t, last, str, metas, offset)"]
// END RANK codeblock_217

section_218 -> { header_224 prose_225 prose_226 codeblock_227}
{rank=same; header_224 prose_225 prose_226 codeblock_227}

header_224 [label="4 : setup values and metatables"]

prose_225 [label="prose"]

prose_226 [label="prose"]

codeblock_227 [label="code block 139-157"]


// END RANK section_218

header_224 -> leaf_228
leaf_228  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** setup values and metatables"]
// END RANK header_224

prose_225 -> { raw_229 link_230 raw_231}
{rank=same; raw_229 link_230 raw_231}

raw_229 [label="raw"]

link_230 [label="link"]

raw_231 [label="raw"]


// END RANK prose_225

raw_229 -> leaf_232
leaf_232  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  As "]
// END RANK raw_229

link_230 -> { anchortext_233 url_234}
{rank=same; anchortext_233 url_234}

anchortext_233 [label="anchortext"]

url_234 [label="url"]


// END RANK link_230

anchortext_233 -> leaf_235
leaf_235  [color=Gray,shape=rectangle,fontname=Inconsolata,label="covered elsewhere"]
// END RANK anchortext_233

url_234 -> leaf_236
leaf_236  [color=Gray,shape=rectangle,fontname=Inconsolata,label="httk://"]
// END RANK url_234

raw_231 -> leaf_237
leaf_237  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", we accept three varieties of
metatable verb.  An ordinary table is assigned; a table with __call is
called, as is an ordinary function.
"]
// END RANK raw_231

prose_226 -> { raw_238 prespace_239 literal_240 raw_241 prespace_242 literal_243 raw_244 prespace_245 literal_246 raw_247}
{rank=same; raw_238 prespace_239 literal_240 raw_241 prespace_242 literal_243 raw_244 prespace_245 literal_246 raw_247}

raw_238 [label="raw"]

prespace_239 [label="prespace"]

literal_240 [label="literal"]

raw_241 [label="raw"]

prespace_242 [label="prespace"]

literal_243 [label="literal"]

raw_244 [label="raw"]

prespace_245 [label="prespace"]

literal_246 [label="literal"]

raw_247 [label="raw"]


// END RANK prose_226

raw_238 -> leaf_248
leaf_248  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The latter two are expected to return the original table, now a descendent
of"]
// END RANK raw_238

prespace_239 -> leaf_249
leaf_249  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_239

literal_240 -> leaf_250
leaf_250  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Node"]
// END RANK literal_240

raw_241 -> leaf_251
leaf_251  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".  This need not have an"]
// END RANK raw_241

prespace_242 -> leaf_252
leaf_252  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_242

literal_243 -> leaf_253
leaf_253  [color=Gray,shape=rectangle,fontname=Inconsolata,label="id"]
// END RANK literal_243

raw_244 -> leaf_254
leaf_254  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" field which is the same as the"]
// END RANK raw_244

prespace_245 -> leaf_255
leaf_255  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_245

literal_246 -> leaf_256
leaf_256  [color=Gray,shape=rectangle,fontname=Inconsolata,label="id"]
// END RANK literal_246

raw_247 -> leaf_257
leaf_257  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
parameter.
"]
// END RANK raw_247

codeblock_227 -> leaf_258
leaf_258  [color=Gray,shape=rectangle,fontname=Inconsolata,label="   local offset = offset or 0
   t.first = first + offset
   t.last  = last + offset - 1
   t.str   = str
   if metas[id] then
      local meta = metas[id]
      if type(meta) == \"function\" or meta.__call then
        t = metas[id](t, str)
      else
        t = setmetatable(t, meta)
      end
      assert(t.id, \"no id on Node\")
   else
      t.id = id
       setmetatable(t, {__index = Node,
                     __tostring = Node.toString})
   end"]
// END RANK codeblock_227

section_219 -> { header_259 prose_260 prose_261 prose_262 prose_263 prose_264 prose_265 prose_266 prose_267 prose_268 prose_269 prose_270 prose_271 prose_272 prose_273 codeblock_274 prose_275 prose_276 codeblock_277 codeblock_278}
{rank=same; header_259 prose_260 prose_261 prose_262 prose_263 prose_264 prose_265 prose_266 prose_267 prose_268 prose_269 prose_270 prose_271 prose_272 prose_273 codeblock_274 prose_275 prose_276 codeblock_277 codeblock_278}

header_259 [label="4 : DROP"]

prose_260 [label="prose"]

prose_261 [label="prose"]

prose_262 [label="prose"]

prose_263 [label="prose"]

prose_264 [label="prose"]

prose_265 [label="prose"]

prose_266 [label="prose"]

prose_267 [label="prose"]

prose_268 [label="prose"]

prose_269 [label="prose"]

prose_270 [label="prose"]

prose_271 [label="prose"]

prose_272 [label="prose"]

prose_273 [label="prose"]

codeblock_274 [label="code block 208-212"]

prose_275 [label="prose"]

prose_276 [label="prose"]

codeblock_277 [label="code block 218-334"]

codeblock_278 [label="code block 336-350"]


// END RANK section_219

header_259 -> leaf_279
leaf_279  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** DROP"]
// END RANK header_259

prose_260 -> { raw_280 prespace_281 literal_282 raw_283}
{rank=same; raw_280 prespace_281 literal_282 raw_283}

raw_280 [label="raw"]

prespace_281 [label="prespace"]

literal_282 [label="literal"]

raw_283 [label="raw"]


// END RANK prose_260

raw_280 -> leaf_284
leaf_284  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  The rule"]
// END RANK raw_280

prespace_281 -> leaf_285
leaf_285  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_281

literal_282 -> leaf_286
leaf_286  [color=Gray,shape=rectangle,fontname=Inconsolata,label="elpatt.D"]
// END RANK literal_282

raw_283 -> leaf_287
leaf_287  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" causes the match to be dropped. In order for
this to give use the results we want, we must adjust the peer and
parent nodes while removing the captured element from the table.
"]
// END RANK raw_283

prose_261 -> { raw_288 prespace_289 literal_290 raw_291}
{rank=same; raw_288 prespace_289 literal_290 raw_291}

raw_288 [label="raw"]

prespace_289 [label="prespace"]

literal_290 [label="literal"]

raw_291 [label="raw"]


// END RANK prose_261

raw_288 -> leaf_292
leaf_292  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The use case is for eloquently expressed 'wrapper' patterns, which occur
frequently in real languages. In a"]
// END RANK raw_288

prespace_289 -> leaf_293
leaf_293  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_289

literal_290 -> leaf_294
leaf_294  [color=Gray,shape=rectangle,fontname=Inconsolata,label="(typical lisp expression)"]
// END RANK literal_290

raw_291 -> leaf_295
leaf_295  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" we don't need
the parentheses and would like our span not to include them.
"]
// END RANK raw_291

prose_262 -> { raw_296 prespace_297 literal_298 raw_299 prespace_300 literal_301 raw_302 prespace_303 literal_304 raw_305}
{rank=same; raw_296 prespace_297 literal_298 raw_299 prespace_300 literal_301 raw_302 prespace_303 literal_304 raw_305}

raw_296 [label="raw"]

prespace_297 [label="prespace"]

literal_298 [label="literal"]

raw_299 [label="raw"]

prespace_300 [label="prespace"]

literal_301 [label="literal"]

raw_302 [label="raw"]

prespace_303 [label="prespace"]

literal_304 [label="literal"]

raw_305 [label="raw"]


// END RANK prose_262

raw_296 -> leaf_306
leaf_306  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
We could use a pattern like"]
// END RANK raw_296

prespace_297 -> leaf_307
leaf_307  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_297

literal_298 -> leaf_308
leaf_308  [color=Gray,shape=rectangle,fontname=Inconsolata,label="V\"formwrap\""]
// END RANK literal_298

raw_299 -> leaf_309
leaf_309  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" and then SUPPRESS"]
// END RANK raw_299

prespace_300 -> leaf_310
leaf_310  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_300

literal_301 -> leaf_311
leaf_311  [color=Gray,shape=rectangle,fontname=Inconsolata,label="formwrap"]
// END RANK literal_301

raw_302 -> leaf_312
leaf_312  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", but
this is less eloquent than"]
// END RANK raw_302

prespace_303 -> leaf_313
leaf_313  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_303

literal_304 -> leaf_314
leaf_314  [color=Gray,shape=rectangle,fontname=Inconsolata,label="D(P\"(\") * V\"form\" *  D(P\")\")"]
// END RANK literal_304

raw_305 -> leaf_315
leaf_315  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
"]
// END RANK raw_305

prose_263 -> { raw_316 prespace_317 literal_318 raw_319}
{rank=same; raw_316 prespace_317 literal_318 raw_319}

raw_316 [label="raw"]

prespace_317 [label="prespace"]

literal_318 [label="literal"]

raw_319 [label="raw"]


// END RANK prose_263

raw_316 -> leaf_320
leaf_320  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Which is admittedly hard to look at.  We prefer the form"]
// END RANK raw_316

prespace_317 -> leaf_321
leaf_321  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
// END RANK prespace_317

literal_318 -> leaf_322
leaf_322  [color=Gray,shape=rectangle,fontname=Inconsolata,label="D(pal) * V\"form\" * D(par)"]
// END RANK literal_318

raw_319 -> leaf_323
leaf_323  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" for this reason among others.
"]
// END RANK raw_319

prose_264 -> { raw_324 prespace_325 literal_326 raw_327}
{rank=same; raw_324 prespace_325 literal_326 raw_327}

raw_324 [label="raw"]

prespace_325 [label="prespace"]

literal_326 [label="literal"]

raw_327 [label="raw"]


// END RANK prose_264

raw_324 -> leaf_328
leaf_328  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The algorithm moves from the right to the left, because"]
// END RANK raw_324

prespace_325 -> leaf_329
leaf_329  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_325

literal_326 -> leaf_330
leaf_330  [color=Gray,shape=rectangle,fontname=Inconsolata,label="table.remove(t)"]
// END RANK literal_326

raw_327 -> leaf_331
leaf_331  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
is O(1) so we can strip any amount of rightward droppage first.  It is
correspondingly more expensive to strip middle drops, and most expensive
to strip leftmost drops.
"]
// END RANK raw_327

prose_265 -> { raw_332 prespace_333 literal_334 raw_335}
{rank=same; raw_332 prespace_333 literal_334 raw_335}

raw_332 [label="raw"]

prespace_333 [label="prespace"]

literal_334 [label="literal"]

raw_335 [label="raw"]


// END RANK prose_265

raw_332 -> leaf_336
leaf_336  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
More importantly, if we counted up, we'd be tracking"]
// END RANK raw_332

prespace_333 -> leaf_337
leaf_337  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_333

literal_334 -> leaf_338
leaf_338  [color=Gray,shape=rectangle,fontname=Inconsolata,label="#t"]
// END RANK literal_334

raw_335 -> leaf_339
leaf_339  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", a moving target.
Counting to 1 neatly prevents this.
"]
// END RANK raw_335

prose_266 -> { raw_340}
{rank=same; raw_340}

raw_340 [label="raw"]


// END RANK prose_266

raw_340 -> leaf_341
leaf_341  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
   -  [ ] #Todo :Faster:
"]
// END RANK raw_340

prose_267 -> { raw_342}
{rank=same; raw_342}

raw_342 [label="raw"]


// END RANK prose_267

raw_342 -> leaf_343
leaf_343  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
     -  This algorithm, as we discussed, goes quadratic toward the left side.
        The correct way to go is if we see any drop, flip a dirty bit, and
        compact upward.
"]
// END RANK raw_342

prose_268 -> { raw_344 prespace_345 literal_346 raw_347}
{rank=same; raw_344 prespace_345 literal_346 raw_347}

raw_344 [label="raw"]

prespace_345 [label="prespace"]

literal_346 [label="literal"]

raw_347 [label="raw"]


// END RANK prose_268

raw_344 -> leaf_348
leaf_348  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
     -  More to the point, the mere inclusion of this much"]
// END RANK raw_344

prespace_345 -> leaf_349
leaf_349  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_345

literal_346 -> leaf_350
leaf_350  [color=Gray,shape=rectangle,fontname=Inconsolata,label="s:"]
// END RANK literal_346

raw_347 -> leaf_351
leaf_351  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" slows the
        algorithm to an utter crawl. The concatenations happen anyway, to
        pass the string into the status module.
"]
// END RANK raw_347

prose_269 -> { raw_352}
{rank=same; raw_352}

raw_352 [label="raw"]


// END RANK prose_269

raw_352 -> leaf_353
leaf_353  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
        This is probably 10x the cost in real work.
"]
// END RANK raw_352

prose_270 -> { raw_354}
{rank=same; raw_354}

raw_354 [label="raw"]


// END RANK prose_270

raw_354 -> leaf_355
leaf_355  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
        Why am I doing it in such a dumb way? This is a literate programming
        environment, and I'm building a language with templates and macros
        and other useful access to state at compile time.
"]
// END RANK raw_354

prose_271 -> { raw_356}
{rank=same; raw_356}

raw_356 [label="raw"]


// END RANK prose_271

raw_356 -> leaf_357
leaf_357  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
        That's two ways to remove the verbosity and other printfs when they
        aren't wanted.  Better to simulate the correct behavior until I can
        provide it.
"]
// END RANK raw_356

prose_272 -> { raw_358}
{rank=same; raw_358}

raw_358 [label="raw"]


// END RANK prose_272

raw_358 -> leaf_359
leaf_359  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
anyway back to our program
"]
// END RANK raw_358

prose_273 -> { raw_360}
{rank=same; raw_360}

raw_360 [label="raw"]


// END RANK prose_273

raw_360 -> leaf_361
leaf_361  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The parent of the first node is always itself:
"]
// END RANK raw_360

codeblock_274 -> leaf_362
leaf_362  [color=Gray,shape=rectangle,fontname=Inconsolata,label="   if not t.parent then
      t.parent = t
   end"]
// END RANK codeblock_274

prose_275 -> { raw_363 prespace_364 literal_365 raw_366}
{rank=same; raw_363 prespace_364 literal_365 raw_366}

raw_363 [label="raw"]

prespace_364 [label="prespace"]

literal_365 [label="literal"]

raw_366 [label="raw"]


// END RANK prose_275

raw_363 -> leaf_367
leaf_367  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This means the special case isn't a"]
// END RANK raw_363

prespace_364 -> leaf_368
leaf_368  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_364

literal_365 -> leaf_369
leaf_369  [color=Gray,shape=rectangle,fontname=Inconsolata,label="nil"]
// END RANK literal_365

raw_366 -> leaf_370
leaf_370  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", which I think is better.
"]
// END RANK raw_366

prose_276 -> { raw_371}
{rank=same; raw_371}

raw_371 [label="raw"]


// END RANK prose_276

raw_371 -> leaf_372
leaf_372  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Now we iterate the children
"]
// END RANK raw_371

codeblock_277 -> leaf_373
leaf_373  [color=Gray,shape=rectangle,fontname=Inconsolata,label="   for i = #t, 1, -1 do
      t[i].parent = t
      local cap = t[i]
      if type(cap) ~= \"table\" then
         s:complain(\"CAPTURE ISSUE\",
                    \"type of capture subgroup is \" .. type(v) .. \"\\n\")
      end
      if cap.DROP == DROP then
         s:verb(\"drops in \" .. a.bright(t.id))
         if i == #t then
            s:verb(a.red(\"rightmost\") .. \" remaining node\")
            s:verb(\"  t.$: \" .. tostring(t.last) .. \" Δ: \"
                   .. tostring(cap.last - cap.first))
            t.last = t.last - (cap.last - cap.first)
            table.remove(t)
            s:verb(\"  new t.$: \" .. tostring(t.last))
         else
            -- Here we may be either in the middle or at the leftmost
            -- margin.  Leftmost means either we're at index 1, or that
            -- all children to the left, down to 1, are all DROPs.
            local leftmost = (i == 1)
            if leftmost then
               s:verb(a.cyan(\"  leftmost\") .. \" remaining node\")
               s:verb(\"    t.^: \" .. tostring(t.first)
                      .. \" D.$: \" .. tostring(cap.last))
               t.first = cap.last
               s:verb(\"    new t.^: \" .. tostring(t.first))
               table.remove(t, 1)
            else
               leftmost = true -- provisionally since cap.DROP
               for j = i, 1, -1 do
                 leftmost = leftmost and t[j].DROP
                 if not leftmost then break end
               end
               if leftmost then
                  s:verb(a.cyan(\"  leftmost inner\") .. \" remaining node\")
                  s:verb(\"    t.^: \" .. tostring(t.first)
                         .. \" D.$: \" .. tostring(cap.last))
                  t.first = cap.last
                  s:verb(\"    new t.^: \" .. tostring(t.first))
                  for j = i, 1, -1 do
                     -- this is quadradic but correct
                     -- and easy to understand.
                     table.remove(t, j)
                     break
                  end
               else
                  s:verb(a.green(\"  middle\") .. \" node dropped\")
                  table.remove(t, i)
               end
            end
         end
      end
   end
   assert(t.isNode, \"failed isNode: \" .. id)
   assert(t.str)
   return t
end


-- localize the patterns we use
local Cp = L.Cp
local Cc = L.Cc
local Ct = L.Ct
local arg1_str = L.Carg(1)
local arg2_metas = L.Carg(2)
local arg3_offset = L.Carg(3)


-- setup an environment where you can easily define lpeg grammars
-- with lots of syntax sugar
local function define(func, g, e)
  g = g or {}
  if e == nil then
    e = VER == \" 5.1\" and getfenv(func) or _G
  end
  local suppressed = {}
  local env = {}
  local env_index = {
    START = function(name) g[1] = name end,
    SUPPRESS = function(...)
      suppressed = {}
      for i = 1, select('#', ...) do
        suppressed[select(i, ... )] = true
      end
    end,
    V = L.V,
    P = L.P,
  }

  setmetatable(env_index, { __index = e })
  setmetatable(env, {
    __index = env_index,
    __newindex = function( _, name, val )
      if suppressed[ name ] then
        g[ name ] = val
      else
        g[ name ] = (Cc(name)
              * Cp()
              * Ct(val)
              * Cp()
              * arg1_str
              * arg2_metas)
              * arg3_offset / make_ast_node
      end
    end
  })
  -- call passed function with custom environment (5.1- and 5.2-style)
  if VER == \" 5.1\" then
    setfenv( func, env )
  end
  func( env )
  assert( g[ 1 ] and g[ g[ 1 ] ], \"no start rule defined\" )
  return g
end"]
// END RANK codeblock_277

codeblock_278 -> leaf_374
leaf_374  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function refineMetas(metas)
  for id, meta in pairs(metas) do
    if type(meta) == \"table\" then
      if not meta[\"__tostring\"] then
        meta[\"__tostring\"] = Node.toString
      end
      if not meta.id then
        meta.id = id
      end
    end
  end
  return metas
end"]
// END RANK codeblock_278

section_6 -> { header_375 prose_376 codeblock_377 codeblock_378}
{rank=same; header_375 prose_376 codeblock_377 codeblock_378}

header_375 [label="2 : new"]

prose_376 [label="prose"]

codeblock_377 [label="code block 358-394"]

codeblock_378 [label="code block 396-398"]


// END RANK section_6

header_375 -> leaf_379
leaf_379  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** new"]
// END RANK header_375

prose_376 -> { raw_380 prespace_381 literal_382 raw_383}
{rank=same; raw_380 prespace_381 literal_382 raw_383}

raw_380 [label="raw"]

prespace_381 [label="prespace"]

literal_382 [label="literal"]

raw_383 [label="raw"]


// END RANK prose_376

raw_380 -> leaf_384
leaf_384  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Given a grammar_template function and a set of metatables,
yield a parsing function and the grammar as an"]
// END RANK raw_380

prespace_381 -> leaf_385
leaf_385  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_381

literal_382 -> leaf_386
leaf_386  [color=Gray,shape=rectangle,fontname=Inconsolata,label="lpeg"]
// END RANK literal_382

raw_383 -> leaf_387
leaf_387  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" pattern.
"]
// END RANK raw_383

codeblock_377 -> leaf_388
leaf_388  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function new(grammar_template, metas)
  if type(grammar_template) == \"function\" then
    local metas = metas or {}
    metas = refineMetas(metas)
    local grammar = define(grammar_template, nil, metas)

    local function parse(str, offset)
      local offset = offset or 0
      local match = L.match(grammar, str, 1, str, metas, offset)
      local maybeErr = match:lastLeaf()
      if maybeErr.id then
        if maybeErr.id == \"ERROR\" then
          local line, col = match:linePos(maybeErr.first)
          local msg = maybeErr.msg or \"\"
          s:complain(\"Parsing Error\", \" line: \" .. tostring(line) .. \", \"
                     .. \"col: \" .. tostring(col) .. \". \" .. msg)
          return match, match:lastLeaf()
        else
          return match
        end
      else
          local maybeNode = maybeErr.isNode and \" is \" or \" isn't \"
          s:complain(\"No id on match\" .. \"match of type, \" .. type(match)
                    .. maybeNode .. \" a Node: \" .. tostring(maybeErr))
      end

      -- This would be a bad match.
      return match
    end

    return parse, grammar
  else
    s:halt(\"no way to build grammar out of \" .. type(template))
  end
end"]
// END RANK codeblock_377

codeblock_378 -> leaf_389
leaf_389  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return new"]
// END RANK codeblock_378


}
