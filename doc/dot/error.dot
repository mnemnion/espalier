digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 82"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-59"]


section_1 -> { header_2 prose_3 prose_4 section_5 section_6}
{rank=same; header_2 prose_3 prose_4 section_5 section_6}

header_2 [label="1 : Error"]

prose_3 [label="prose"]

prose_4 [label="prose"]

section_5 [label="section: 11-25"]

section_6 [label="section: 60-82"]


header_2 -> leaf_7
leaf_7  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Error"]
prose_3 -> { raw_8}
{rank=same; raw_8}

raw_8 [label="raw"]


raw_8 -> leaf_9
leaf_9  [color=Gray,shape=rectangle,fontname=Inconsolata,label="



Rather than throwing errors, we prefer to add them to the parse tree in some
cases.
"]
prose_4 -> { raw_10 prespace_11 literal_12 raw_13}
{rank=same; raw_10 prespace_11 literal_12 raw_13}

raw_10 [label="raw"]

prespace_11 [label="prespace"]

literal_12 [label="literal"]

raw_13 [label="raw"]


raw_10 -> leaf_14
leaf_14  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Optionally, we can include a pattern which, if the parse were to be correct,
would succeed. So a"]
prespace_11 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_12 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label="( ])"]
raw_13 -> leaf_17
leaf_17  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" type error could be \"fail to close (\" and =P\")\".
"]
section_5 -> { header_18 prose_19 codeblock_20 codeblock_21 section_22}
{rank=same; header_18 prose_19 codeblock_20 codeblock_21 section_22}

header_18 [label="3 : includes #nw"]

prose_19 [label="prose"]

codeblock_20 [label="code block 13-17"]

codeblock_21 [label="code block 19-23"]

section_22 [label="section: 26-59"]


header_18 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** includes #nw"]
prose_19 -> { raw_24}
{rank=same; raw_24}

raw_24 [label="raw"]


raw_24 -> leaf_25
leaf_25  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
codeblock_20 -> leaf_26
leaf_26  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local L   = require \"lpeg\"
local s   = require \"status\" ()
local Carg, Cc, Cp, P = L.Carg, L.Cc, L.Cp, L.P"]
codeblock_21 -> leaf_27
leaf_27  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local Err = require \"node\" : inherit()
Err.id = \"ERROR\"
"]
section_22 -> { header_28 prose_29 codeblock_30 prose_31 codeblock_32}
{rank=same; header_28 prose_29 codeblock_30 prose_31 codeblock_32}

header_28 [label="4 : Err.toLua #remove"]

prose_29 [label="prose"]

codeblock_30 [label="code block 30-34"]

prose_31 [label="prose"]

codeblock_32 [label="code block 41-57"]


header_28 -> leaf_33
leaf_33  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** Err.toLua #remove"]
prose_29 -> { raw_34}
{rank=same; raw_34}

raw_34 [label="raw"]


raw_34 -> leaf_35
leaf_35  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This is while I work on having grammars catch terminal Errors.
"]
codeblock_30 -> leaf_36
leaf_36  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Err.toLua(err)
  s:halt(\"ERROR at position \" .. tostring(err.first))
end"]
prose_31 -> { raw_37 prespace_38 literal_39 raw_40 prespace_41 literal_42 raw_43}
{rank=same; raw_37 prespace_38 literal_39 raw_40 prespace_41 literal_42 raw_43}

raw_37 [label="raw"]

prespace_38 [label="prespace"]

literal_39 [label="literal"]

raw_40 [label="raw"]

prespace_41 [label="prespace"]

literal_42 [label="literal"]

raw_43 [label="raw"]


raw_37 -> leaf_44
leaf_44  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
We want parse_error to be able to return the actual point of failure,
which I think involves a match-time capture. In the meantime,"]
prespace_38 -> leaf_45
leaf_45  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
literal_39 -> leaf_46
leaf_46  [color=Gray,shape=rectangle,fontname=Inconsolata,label="err.last"]
raw_40 -> leaf_47
leaf_47  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is set to be"]
prespace_41 -> leaf_48
leaf_48  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_42 -> leaf_49
leaf_49  [color=Gray,shape=rectangle,fontname=Inconsolata,label="#str"]
raw_43 -> leaf_50
leaf_50  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
"]
codeblock_32 -> leaf_51
leaf_51  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function parse_error(pos, name, msg, patt, str)
   local message = msg or name or \"Not Otherwise Specified\"
   s:verb(\"Parse Error: \", message)
   local errorNode =  setmetatable({}, Err)
   errorNode.first =  pos
   errorNode.last  =  #str -- See above
   errorNode.msg   =  msg
   errorNode.name  =  name
   errorNode.str   =  str
   errorNode.rest  =  string.sub(str, pos)
   errorNode.patt  =  patt

   return errorNode
end
"]
section_6 -> { header_52 prose_53 prose_54 codeblock_55}
{rank=same; header_52 prose_53 prose_54 codeblock_55}

header_52 [label="3 : Err.Err, Err.E : Capture an Error"]

prose_53 [label="prose"]

prose_54 [label="prose"]

codeblock_55 [label="code block 70-82"]


header_52 -> leaf_56
leaf_56  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Err.Err, Err.E : Capture an Error"]
prose_53 -> { raw_57 prespace_58 literal_59 raw_60 prespace_61 literal_62 raw_63}
{rank=same; raw_57 prespace_58 literal_59 raw_60 prespace_61 literal_62 raw_63}

raw_57 [label="raw"]

prespace_58 [label="prespace"]

literal_59 [label="literal"]

raw_60 [label="raw"]

prespace_61 [label="prespace"]

literal_62 [label="literal"]

raw_63 [label="raw"]


raw_57 -> leaf_64
leaf_64  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

For now these are synonyms."]
prespace_58 -> leaf_65
leaf_65  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_59 -> leaf_66
leaf_66  [color=Gray,shape=rectangle,fontname=Inconsolata,label="E"]
raw_60 -> leaf_67
leaf_67  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" will eventually use a back capture"]
prespace_61 -> leaf_68
leaf_68  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_62 -> leaf_69
leaf_69  [color=Gray,shape=rectangle,fontname=Inconsolata,label="B"]
raw_63 -> leaf_70
leaf_70  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" at 
the beginning of a rule, and a match-time at the end, to provide a 
sensible, bookended approach to error diagnosis and possible recovery. 
"]
prose_54 -> { prespace_71 literal_72 raw_73}
{rank=same; prespace_71 literal_72 raw_73}

prespace_71 [label="prespace"]

literal_72 [label="literal"]

raw_73 [label="raw"]


prespace_71 -> leaf_74
leaf_74  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
literal_72 -> leaf_75
leaf_75  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Err"]
raw_73 -> leaf_76
leaf_76  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is the catchbucket, that simply succeeds and poisons the AST if 
non-terminal. It will at least prominently yell \"ERROR\" at you given 
the least opportunity. 
"]
codeblock_55 -> leaf_77
leaf_77  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Err.Err(name, msg, patt)
  return Cp() * Cc(name) * Cc(msg) * Cc(patt) * Carg(1) / parse_error
end

Err.E = Err.Err

function Err.EOF(name, msg)
  return -P(1) + Err.Err(name, msg), Cp()
end

return Err"]

}
