digraph lpegNode {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 250"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-156"]


// END RANK doc_0

section_1 -> { header_2 prose_3 prose_4 prose_5 prose_6 prose_7 prose_8 section_9 section_10 section_11 section_12 section_13}
{rank=same; header_2 prose_3 prose_4 prose_5 prose_6 prose_7 prose_8 section_9 section_10 section_11 section_12 section_13}

header_2 [label="1 : Phrase"]

prose_3 [label="prose"]

prose_4 [label="prose"]

prose_5 [label="prose"]

prose_6 [label="prose"]

prose_7 [label="prose"]

prose_8 [label="prose"]

section_9 [label="section: 27-33"]

section_10 [label="section: 34-41"]

section_11 [label="section: 42-53"]

section_12 [label="section: 91-156"]

section_13 [label="section: 157-201"]


// END RANK section_1

header_2 -> leaf_14
leaf_14  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Phrase"]
// END RANK header_2

prose_3 -> { raw_15}
{rank=same; raw_15}

raw_15 [label="raw"]


// END RANK prose_3

raw_15 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


This is a string builder class.
"]
// END RANK raw_15

prose_4 -> { raw_17 link_18 raw_19}
{rank=same; raw_17 link_18 raw_19}

raw_17 [label="raw"]

link_18 [label="link"]

raw_19 [label="raw"]


// END RANK prose_4

raw_17 -> leaf_20
leaf_20  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
It is "]
// END RANK raw_17

link_18 -> { anchortext_21 url_22}
{rank=same; anchortext_21 url_22}

anchortext_21 [label="anchortext"]

url_22 [label="url"]


// END RANK link_18

anchortext_21 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label="heritable"]
// END RANK anchortext_21

url_22 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label="httk://"]
// END RANK url_22

raw_19 -> leaf_25
leaf_25  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", may be concatenated with either a string or itself,
and will eventually implement the full string library as method calls.
"]
// END RANK raw_19

prose_5 -> { raw_26}
{rank=same; raw_26}

raw_26 [label="raw"]


// END RANK prose_5

raw_26 -> leaf_27
leaf_27  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I use a definite string building paradigm for which the Phrase class is a drop-in
replacement.
"]
// END RANK raw_26

prose_6 -> { raw_28}
{rank=same; raw_28}

raw_28 [label="raw"]


// END RANK prose_6

raw_28 -> leaf_29
leaf_29  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The base Phrase class is mutable.  Concatenating strings will add to the array
portion of the Phrase, while catting another Phrase will combine the two
into a new Phrase.  This means in normal use, once a Phrase is added to another
Phrase, it will stay put.

"]
// END RANK raw_28

prose_7 -> { raw_30 prespace_31 italic_32 raw_33 prespace_34 literal_35 raw_36 prespace_37 literal_38 raw_39}
{rank=same; raw_30 prespace_31 italic_32 raw_33 prespace_34 literal_35 raw_36 prespace_37 literal_38 raw_39}

raw_30 [label="raw"]

prespace_31 [label="prespace"]

italic_32 [label="italic"]

raw_33 [label="raw"]

prespace_34 [label="prespace"]

literal_35 [label="literal"]

raw_36 [label="raw"]

prespace_37 [label="prespace"]

literal_38 [label="literal"]

raw_39 [label="raw"]


// END RANK prose_7

raw_30 -> leaf_40
leaf_40  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The right"]
// END RANK raw_30

prespace_31 -> leaf_41
leaf_41  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_31

italic_32 -> leaf_42
leaf_42  [color=Gray,shape=rectangle,fontname=Inconsolata,label="sort"]
// END RANK italic_32

raw_33 -> leaf_43
leaf_43  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" of mutability is copy-on-write.  We're not providing a mutation
interface yet, all we need is for it to behave like a string under"]
// END RANK raw_33

prespace_34 -> leaf_44
leaf_44  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_34

literal_35 -> leaf_45
leaf_45  [color=Gray,shape=rectangle,fontname=Inconsolata,label="__tostring"]
// END RANK literal_35

raw_36 -> leaf_46
leaf_46  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
and"]
// END RANK raw_36

prespace_37 -> leaf_47
leaf_47  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_37

literal_38 -> leaf_48
leaf_48  [color=Gray,shape=rectangle,fontname=Inconsolata,label="__concat"]
// END RANK literal_38

raw_39 -> leaf_49
leaf_49  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".

"]
// END RANK raw_39

prose_8 -> { raw_50}
{rank=same; raw_50}

raw_50 [label="raw"]


// END RANK prose_8

raw_50 -> leaf_51
leaf_51  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I intend to extend the class once we get to an editing environment, by making it
persistent rather than immutable.  A distinction I will elucidate when I reach it.

"]
// END RANK raw_50

section_9 -> { header_52 prose_53 prose_54}
{rank=same; header_52 prose_53 prose_54}

header_52 [label="3 : Phrase is string-like"]

prose_53 [label="prose"]

prose_54 [label="prose"]


// END RANK section_9

header_52 -> leaf_55
leaf_55  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Phrase is string-like"]
// END RANK header_52

prose_53 -> { raw_56}
{rank=same; raw_56}

raw_56 [label="raw"]


// END RANK prose_53

raw_56 -> leaf_57
leaf_57  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

It may be concatenated with strings at any point, and the result will be a Phrase.
"]
// END RANK raw_56

prose_54 -> { raw_58 prespace_59 literal_60 raw_61}
{rank=same; raw_58 prespace_59 literal_60 raw_61}

raw_58 [label="raw"]

prespace_59 [label="prespace"]

literal_60 [label="literal"]

raw_61 [label="raw"]


// END RANK prose_54

raw_58 -> leaf_62
leaf_62  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
It will render the same string you would expect any time"]
// END RANK raw_58

prespace_59 -> leaf_63
leaf_63  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_59

literal_60 -> leaf_64
leaf_64  [color=Gray,shape=rectangle,fontname=Inconsolata,label="tostring"]
// END RANK literal_60

raw_61 -> leaf_65
leaf_65  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is triggered.

"]
// END RANK raw_61

section_10 -> { header_66 prose_67 prose_68}
{rank=same; header_66 prose_67 prose_68}

header_66 [label="3 : Phrase is not entirely string-like"]

prose_67 [label="prose"]

prose_68 [label="prose"]


// END RANK section_10

header_66 -> leaf_69
leaf_69  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Phrase is not entirely string-like"]
// END RANK header_66

prose_67 -> { raw_70 prespace_71 literal_72 raw_73 prespace_74 literal_75 raw_76 prespace_77 literal_78 raw_79}
{rank=same; raw_70 prespace_71 literal_72 raw_73 prespace_74 literal_75 raw_76 prespace_77 literal_78 raw_79}

raw_70 [label="raw"]

prespace_71 [label="prespace"]

literal_72 [label="literal"]

raw_73 [label="raw"]

prespace_74 [label="prespace"]

literal_75 [label="literal"]

raw_76 [label="raw"]

prespace_77 [label="prespace"]

literal_78 [label="literal"]

raw_79 [label="raw"]


// END RANK prose_67

raw_70 -> leaf_80
leaf_80  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

We have a field"]
// END RANK raw_70

prespace_71 -> leaf_81
leaf_81  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_71

literal_72 -> leaf_82
leaf_82  [color=Gray,shape=rectangle,fontname=Inconsolata,label="phrase.len"]
// END RANK literal_72

raw_73 -> leaf_83
leaf_83  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" that tells you what"]
// END RANK raw_73

prespace_74 -> leaf_84
leaf_84  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_74

literal_75 -> leaf_85
leaf_85  [color=Gray,shape=rectangle,fontname=Inconsolata,label="#tostring(phrase)"]
// END RANK literal_75

raw_76 -> leaf_86
leaf_86  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" would be."]
// END RANK raw_76

prespace_77 -> leaf_87
leaf_87  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
// END RANK prespace_77

literal_78 -> leaf_88
leaf_88  [color=Gray,shape=rectangle,fontname=Inconsolata,label="#phrase"]
// END RANK literal_78

raw_79 -> leaf_89
leaf_89  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is the number of fragments in the array portion of the phrase.
"]
// END RANK raw_79

prose_68 -> { raw_90 prespace_91 literal_92 raw_93}
{rank=same; raw_90 prespace_91 literal_92 raw_93}

raw_90 [label="raw"]

prespace_91 [label="prespace"]

literal_92 [label="literal"]

raw_93 [label="raw"]


// END RANK prose_68

raw_90 -> leaf_94
leaf_94  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
We use"]
// END RANK raw_90

prespace_91 -> leaf_95
leaf_95  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_91

literal_92 -> leaf_96
leaf_96  [color=Gray,shape=rectangle,fontname=Inconsolata,label="#Phrase"]
// END RANK literal_92

raw_93 -> leaf_97
leaf_97  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" all the time for iteration, so we don't want to block it.

"]
// END RANK raw_93

section_11 -> { header_98 prose_99 prose_100 prose_101 section_102}
{rank=same; header_98 prose_99 prose_100 prose_101 section_102}

header_98 [label="2 : Phrase is contagious"]

prose_99 [label="prose"]

prose_100 [label="prose"]

prose_101 [label="prose"]

section_102 [label="section: 54-90"]


// END RANK section_11

header_98 -> leaf_103
leaf_103  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Phrase is contagious"]
// END RANK header_98

prose_99 -> { raw_104}
{rank=same; raw_104}

raw_104 [label="raw"]


// END RANK prose_99

raw_104 -> leaf_105
leaf_105  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Phrases, by design, subsume strings any time they are concatenated. This
will tend to cause failure when handed to things like the string library.
"]
// END RANK raw_104

prose_100 -> { raw_106 prespace_107 literal_108 raw_109}
{rank=same; raw_106 prespace_107 literal_108 raw_109}

raw_106 [label="raw"]

prespace_107 [label="prespace"]

literal_108 [label="literal"]

raw_109 [label="raw"]


// END RANK prose_100

raw_106 -> leaf_110
leaf_110  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Better to write a Phrase-native substitute unless it's an endpoint like"]
// END RANK raw_106

prespace_107 -> leaf_111
leaf_111  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
// END RANK prespace_107

literal_108 -> leaf_112
leaf_112  [color=Gray,shape=rectangle,fontname=Inconsolata,label="write"]
// END RANK literal_108

raw_109 -> leaf_113
leaf_113  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".  The combination of interned immutable strings and pervasing tabling
over concatenation is powerful and fast in Lua.
"]
// END RANK raw_109

prose_101 -> { raw_114 prespace_115 literal_116 raw_117}
{rank=same; raw_114 prespace_115 literal_116 raw_117}

raw_114 [label="raw"]

prespace_115 [label="prespace"]

literal_116 [label="literal"]

raw_117 [label="raw"]


// END RANK prose_101

raw_114 -> leaf_118
leaf_118  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
It's ok to just call"]
// END RANK raw_114

prespace_115 -> leaf_119
leaf_119  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_115

literal_116 -> leaf_120
leaf_120  [color=Gray,shape=rectangle,fontname=Inconsolata,label="tostring"]
// END RANK literal_116

raw_117 -> leaf_121
leaf_121  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" and be done.

"]
// END RANK raw_117

section_102 -> { header_122 prose_123 prose_124 prose_125 prose_126 prose_127 prose_128 prose_129 codeblock_130}
{rank=same; header_122 prose_123 prose_124 prose_125 prose_126 prose_127 prose_128 prose_129 codeblock_130}

header_122 [label="3 : Roadmap"]

prose_123 [label="prose"]

prose_124 [label="prose"]

prose_125 [label="prose"]

prose_126 [label="prose"]

prose_127 [label="prose"]

prose_128 [label="prose"]

prose_129 [label="prose"]

codeblock_130 [label="code block 82-88"]


// END RANK section_102

header_122 -> leaf_131
leaf_131  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Roadmap"]
// END RANK header_122

prose_123 -> { raw_132 prespace_133 literal_134 raw_135 prespace_136 literal_137 raw_138}
{rank=same; raw_132 prespace_133 literal_134 raw_135 prespace_136 literal_137 raw_138}

raw_132 [label="raw"]

prespace_133 [label="prespace"]

literal_134 [label="literal"]

raw_135 [label="raw"]

prespace_136 [label="prespace"]

literal_137 [label="literal"]

raw_138 [label="raw"]


// END RANK prose_123

raw_132 -> leaf_139
leaf_139  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

I would like to add"]
// END RANK raw_132

prespace_133 -> leaf_140
leaf_140  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_133

literal_134 -> leaf_141
leaf_141  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Phrase:ffind(str)"]
// END RANK literal_134

raw_135 -> leaf_142
leaf_142  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", for fast find.  This only works if
the"]
// END RANK raw_135

prespace_136 -> leaf_143
leaf_143  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_136

literal_137 -> leaf_144
leaf_144  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str"]
// END RANK literal_137

raw_138 -> leaf_145
leaf_145  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is a literal fragment somewhere in the phrase.
"]
// END RANK raw_138

prose_124 -> { raw_146}
{rank=same; raw_146}

raw_146 [label="raw"]


// END RANK prose_124

raw_146 -> leaf_147
leaf_147  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
More enhancements of that nature should be in an extended class. Think gsub
with the full power of lpeg instead of the quirky pattern syntax I can never
remember.
"]
// END RANK raw_146

prose_125 -> { raw_148}
{rank=same; raw_148}

raw_148 [label="raw"]


// END RANK prose_125

raw_148 -> leaf_149
leaf_149  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Also, one premise of Phrase is that it's encoding-unaware. I'd like to add
to it by calculating the codepoints and adding a \"ulen\" field, but don't
want to pay the cost for the base class, since Node in particular counts on
grammars to be correct about the bytes they want to consume.
"]
// END RANK raw_148

prose_126 -> { raw_150}
{rank=same; raw_150}

raw_150 [label="raw"]


// END RANK prose_126

raw_150 -> leaf_151
leaf_151  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The language interface of lpeg emphasises text, as it should, but Lua strings
are eight-bit clean and commonly enough used to intern userdata and query it.
"]
// END RANK raw_150

prose_127 -> { raw_152 prespace_153 literal_154 raw_155}
{rank=same; raw_152 prespace_153 literal_154 raw_155}

raw_152 [label="raw"]

prespace_153 [label="prespace"]

literal_154 [label="literal"]

raw_155 [label="raw"]


// END RANK prose_127

raw_152 -> leaf_156
leaf_156  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Phrase can actually be used as-is to build up rope-like binary data, if that
ever comes in handy.  I'd want a different"]
// END RANK raw_152

prespace_153 -> leaf_157
leaf_157  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_153

literal_154 -> leaf_158
leaf_158  [color=Gray,shape=rectangle,fontname=Inconsolata,label="idEst"]
// END RANK literal_154

raw_155 -> leaf_159
leaf_159  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" to not puke all over
my terminal by accident.
"]
// END RANK raw_155

prose_128 -> { raw_160}
{rank=same; raw_160}

raw_160 [label="raw"]


// END RANK prose_128

raw_160 -> leaf_161
leaf_161  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Speaking of rope-like, Phrase will have better performance in environments
where it is more 'bushy'.  No effort to balance the tree is implemented
currently.
"]
// END RANK raw_160

prose_129 -> { raw_162}
{rank=same; raw_162}

raw_162 [label="raw"]


// END RANK prose_129

raw_162 -> leaf_163
leaf_163  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
It would be tractable to add this, however I suspect it will perform well under
real workloads, so I may not bother.
"]
// END RANK raw_162

codeblock_130 -> leaf_164
leaf_164  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local init, new
local s = require \"core/status\" ()
s.angry = false
local Phrase = setmetatable({}, {__index = Phrase})
Phrase.it = require \"core/check\""]
// END RANK codeblock_130

section_12 -> { header_165 prose_166 prose_167 prose_168 prose_169 codeblock_170}
{rank=same; header_165 prose_166 prose_167 prose_168 prose_169 codeblock_170}

header_165 [label="2 : __concat"]

prose_166 [label="prose"]

prose_167 [label="prose"]

prose_168 [label="prose"]

prose_169 [label="prose"]

codeblock_170 [label="code block 108-154"]


// END RANK section_12

header_165 -> leaf_171
leaf_171  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** __concat"]
// END RANK header_165

prose_166 -> { raw_172}
{rank=same; raw_172}

raw_172 [label="raw"]


// END RANK prose_166

raw_172 -> leaf_173
leaf_173  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Concatenation is the frequent operation in working with Nodes.  By default,
all a Node is in a position to do is yield a string.  Phrase allows us to
enhance that with various table-assisted superpowers.
"]
// END RANK raw_172

prose_167 -> { raw_174}
{rank=same; raw_174}

raw_174 [label="raw"]


// END RANK prose_167

raw_174 -> leaf_175
leaf_175  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Also, Lua strings are very cheap once created. Concatenating them together in
a recursively larger pattern is really expensive by comparison, and that's
the entire paradigm of all these tools right now.
"]
// END RANK raw_174

prose_168 -> { raw_176}
{rank=same; raw_176}

raw_176 [label="raw"]


// END RANK prose_168

raw_176 -> leaf_177
leaf_177  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This and retaining the Docs in-memory will get the spring back in our step.
"]
// END RANK raw_176

prose_169 -> { raw_178}
{rank=same; raw_178}

raw_178 [label="raw"]


// END RANK prose_169

raw_178 -> leaf_179
leaf_179  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- parameters
  -  head_phrase:  This may be either a primitive string or a Phrase.
  -  tail_phrase:  This may be either primitive or a Phrase.  If head_phrase
                   is a string, tail_phrase is not, or we'd be in the VM.
"]
// END RANK raw_178

codeblock_170 -> leaf_180
leaf_180  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function spill(phrase)
   local new_phrase = init()
   for k, v in pairs(phrase) do
      new_phrase[k] = v
   end
   new_phrase.intern = nil

   return new_phrase
end


local function __concat(head_phrase, tail_phrase)
   if type(head_phrase) == 'string' then
      -- bump the tail phrase accordingly
      if tail_phrase.intern then
         tail_phrase = spill(tail_phrase)
      end

      table.insert(tail_phrase, 1, head_phrase)
      tail_phrase.len = tail_phrase.len + #head_phrase
      return tail_phrase
   end
   local typica = type(tail_phrase)
   if typica == \"string\" then
      if head_phrase.intern then
         head_phrase = spill(head_phrase)
      end
      head_phrase[#head_phrase + 1] = tail_phrase
      head_phrase.len = head_phrase.len + #tail_phrase
      return head_phrase
   elseif typica == \"table\" and tail_phrase.idEst == new then
      -- This is where we can balance the Phrase if we want
      -- For now I'd rather preserve the build structure, I think
      -- that's more generally useful.
      local new_phrase = init()
      head_phrase.intern = true -- head_phrase is now in the middle of a string
      tail_phrase.intern = true -- tail_phrase shouldn't be bump-catted
      new_phrase[1] = head_phrase
      new_phrase[2] = tail_phrase
      new_phrase.len = head_phrase.len + tail_phrase.len
      return new_phrase
   end

   return nil, \"tail phrase was unsuitable for concatenation\"
end"]
// END RANK codeblock_170

section_13 -> { header_181 prose_182 codeblock_183 codeblock_184 codeblock_185 section_186}
{rank=same; header_181 prose_182 codeblock_183 codeblock_184 codeblock_185 section_186}

header_181 [label="2 : __tostring"]

prose_182 [label="prose"]

codeblock_183 [label="code block 161-170"]

codeblock_184 [label="code block 172-176"]

codeblock_185 [label="code block 178-199"]

section_186 [label="section: 202-250"]


// END RANK section_13

header_181 -> leaf_187
leaf_187  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** __tostring"]
// END RANK header_181

prose_182 -> { raw_188}
{rank=same; raw_188}

raw_188 [label="raw"]


// END RANK prose_182

raw_188 -> leaf_189
leaf_189  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Treating Phrase as a string at any point should render it into one.
"]
// END RANK raw_188

codeblock_183 -> leaf_190
leaf_190  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function __tostring(phrase)
  local str = \"\"
  for i,v in ipairs(phrase) do
    str = str .. tostring(v)
  end

  return str
end"]
// END RANK codeblock_183

codeblock_184 -> leaf_191
leaf_191  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local PhraseMeta = {__index = Phrase,
                  __concat = __concat,
                  __tostring = __tostring}"]
// END RANK codeblock_184

codeblock_185 -> leaf_192
leaf_192  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
init = function()
   return setmetatable ({}, PhraseMeta)
end

new = function(phrase_seed)
   phrase_seed = phrase_seed or \"\"
   local phrase = init()
   local typica = type(phrase_seed)
   if typica == \"string\" then
      phrase[1] = phrase_seed
      phrase.len = #phrase_seed
   else
      s:complain(\"Error in Phrase\", \"cannot accept phrase seed of type\" .. typica,
                 phrase_seed)
   end
   return phrase
end

Phrase.idEst = new"]
// END RANK codeblock_185

section_186 -> { header_193 prose_194 codeblock_195 codeblock_196}
{rank=same; header_193 prose_194 codeblock_195 codeblock_196}

header_193 [label="3 : spec"]

prose_194 [label="prose"]

codeblock_195 [label="code block 206-223"]

codeblock_196 [label="code block 226-228"]


// END RANK section_186

header_193 -> leaf_197
leaf_197  [color=Gray,shape=rectangle,fontname=Inconsolata,label="ec

Stick"]
// END RANK header_193

prose_194 -> { raw_198}
{rank=same; raw_198}

raw_198 [label="raw"]


// END RANK prose_194

raw_198 -> leaf_199
leaf_199  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Stick this somewhere better
"]
// END RANK raw_198

codeblock_195 -> leaf_200
leaf_200  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function spec()
   a = new \"Sphinx of \" .. \"black quartz \"
   a: it \"phrase-a\"
      : passedTo(tostring)
      : gives \"Sphinx of black quartz \"
      : fin()

   b = a .. \"judge my \" .. \"vow.\"
   b: it \"phrase-b\"
      : passedTo(tostring)
      : gives \"Sphinx of black quartz judge my vow.\"
      : fin()

end

spec()"]
// END RANK codeblock_195

codeblock_196 -> leaf_201
leaf_201  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return new"]
// END RANK codeblock_196


}
