digraph lpegNode {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 115"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-71"]


// END RANK doc_0

section_1 -> { header_2 prose_3 prose_4 prose_5 codeblock_6 section_7}
{rank=same; header_2 prose_3 prose_4 prose_5 codeblock_6 section_7}

header_2 [label="1 : A Grammar For Lua"]

prose_3 [label="prose"]

prose_4 [label="prose"]

prose_5 [label="prose"]

codeblock_6 [label="code block 12-69"]

section_7 [label="section: 72-87"]


// END RANK section_1

header_2 -> leaf_8
leaf_8  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* A Grammar For Lua"]
// END RANK header_2

prose_3 -> { raw_9}
{rank=same; raw_9}

raw_9 [label="raw"]


// END RANK prose_3

raw_9 -> leaf_10
leaf_10  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

While the most important grammar for pegylator is pegylator itself, it's
time to make a Lua language parser.
"]
// END RANK raw_9

prose_4 -> { raw_11}
{rank=same; raw_11}

raw_11 [label="raw"]


// END RANK prose_4

raw_11 -> leaf_12
leaf_12  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The hard work is done on this, it's a matter of translation into the
Pegylator paradigm.
"]
// END RANK raw_11

prose_5 -> { raw_13}
{rank=same; raw_13}

raw_13 [label="raw"]


// END RANK prose_5

raw_13 -> leaf_14
leaf_14  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
While this a hell of a lot of work, the complete BNF of Lua is available,
and reproduced here.
"]
// END RANK raw_13

codeblock_6 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label="chunk ::= {stat [`;´]} [laststat [`;´]]

   block ::= chunk

   stat ::=  varlist `=´ explist |
       functioncall |
       do block end |
       while exp do block end |
       repeat block until exp |
       if exp then block {elseif exp then block} [else block] end |
       for Name `=´ exp `,´ exp [`,´ exp] do block end |
       for namelist in explist do block end |
       function funcname funcbody |
       local function Name funcbody |
       local namelist [`=´ explist]

   laststat ::= return [explist] | break

   funcname ::= Name {`.´ Name} [`:´ Name]

   varlist ::= var {`,´ var}

   var ::=  Name | prefixexp `[´ exp `]´ | prefixexp `.´ Name

   namelist ::= Name {`,´ Name}

   explist ::= {exp `,´} exp

   exp ::=  nil | false | true | Number | String | `...´ | function |
       prefixexp | tableconstructor | exp binop exp | unop exp

   prefixexp ::= var | functioncall | `(´ exp `)´

   functioncall ::=  prefixexp args | prefixexp `:´ Name args

   args ::=  `(´ [explist] `)´ | tableconstructor | String

   function ::= function funcbody

   funcbody ::= `(´ [parlist] `)´ block end

   parlist ::= namelist [`,´ `...´] | `...´

   tableconstructor ::= `{´ [fieldlist] `}´

   fieldlist ::= field {fieldsep field} [fieldsep]

   field ::= `[´ exp `]´ `=´ exp | Name `=´ exp | exp

   fieldsep ::= `,´ | `;´

   binop ::= `+´ | `-´ | `*´ | `/´ | `^´ | `%´ | `..´ |
       `<´ | `<=´ | `>´ | `>=´ | `==´ | `~=´ |
       and | or

   unop ::= `-´ | not | `#´"]
// END RANK codeblock_6

section_7 -> { header_16 prose_17 section_18 section_19}
{rank=same; header_16 prose_17 section_18 section_19}

header_16 [label="2 : Implementation"]

prose_17 [label="prose"]

section_18 [label="section: 77-87"]

section_19 [label="section: 88-115"]


// END RANK section_7

header_16 -> leaf_20
leaf_20  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Implementation"]
// END RANK header_16

prose_17 -> { raw_21}
{rank=same; raw_21}

raw_21 [label="raw"]


// END RANK prose_17

raw_21 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Let's try it.

"]
// END RANK raw_21

section_18 -> { header_23 prose_24 codeblock_25}
{rank=same; header_23 prose_24 codeblock_25}

header_23 [label="3 : Imports"]

prose_24 [label="prose"]

codeblock_25 [label="code block 79-85"]


// END RANK section_18

header_23 -> leaf_26
leaf_26  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Imports"]
// END RANK header_23

prose_24 -> { raw_27}
{rank=same; raw_27}

raw_27 [label="raw"]


// END RANK prose_24

raw_27 -> leaf_28
leaf_28  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_27

codeblock_25 -> leaf_29
leaf_29  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local Node    =  require \"espalier/node\"
local Grammar =  require \"espalier/grammar\"
local L       =  require \"espalier/elpatt\"

local P, R, E, V, S    =  L.P, L.R, L.E, L.V, L.S"]
// END RANK codeblock_25

section_19 -> { header_30 prose_31 codeblock_32}
{rank=same; header_30 prose_31 codeblock_32}

header_30 [label="3 : lua_fn"]

prose_31 [label="prose"]

codeblock_32 [label="code block 92-97"]


// END RANK section_19

header_30 -> leaf_33
leaf_33  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** lua_fn"]
// END RANK header_30

prose_31 -> { raw_34}
{rank=same; raw_34}

raw_34 [label="raw"]


// END RANK prose_31

raw_34 -> leaf_35
leaf_35  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This is provided to the Grammar engine to create a Lua parser.
yes"]
// END RANK raw_34

codeblock_32 -> leaf_36
leaf_36  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function lua_fn(ENV)
   START \"lua\"
   lua = V\"chunk\"^1
end"]
// END RANK codeblock_32


}
