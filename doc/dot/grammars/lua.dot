digraph lpegNode {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 69"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-69"]


// END RANK doc_0

section_1 -> { header_2 prose_3 prose_4 prose_5 codeblock_6}
{rank=same; header_2 prose_3 prose_4 prose_5 codeblock_6}

header_2 [label="1 : A Grammer For Lua"]

prose_3 [label="prose"]

prose_4 [label="prose"]

prose_5 [label="prose"]

codeblock_6 [label="code block 12-69"]


// END RANK section_1

header_2 -> leaf_7
leaf_7  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* A Grammer For Lua"]
// END RANK header_2

prose_3 -> { raw_8}
{rank=same; raw_8}

raw_8 [label="raw"]


// END RANK prose_3

raw_8 -> leaf_9
leaf_9  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

While the most important grammar for pegylator is pegylator itself, it's
time to make a Lua language parser.
"]
// END RANK raw_8

prose_4 -> { raw_10}
{rank=same; raw_10}

raw_10 [label="raw"]


// END RANK prose_4

raw_10 -> leaf_11
leaf_11  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The hard work is done on this, it's a matter of translation into the
Pegylator paradigm.
"]
// END RANK raw_10

prose_5 -> { raw_12}
{rank=same; raw_12}

raw_12 [label="raw"]


// END RANK prose_5

raw_12 -> leaf_13
leaf_13  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
While this a hell of a lot of work, the complete BNF of Lua is available,
and reproduced here.
"]
// END RANK raw_12

codeblock_6 -> leaf_14
leaf_14  [color=Gray,shape=rectangle,fontname=Inconsolata,label="chunk ::= {stat [`;´]} [laststat [`;´]]

   block ::= chunk

   stat ::=  varlist `=´ explist |
       functioncall |
       do block end |
       while exp do block end |
       repeat block until exp |
       if exp then block {elseif exp then block} [else block] end |
       for Name `=´ exp `,´ exp [`,´ exp] do block end |
       for namelist in explist do block end |
       function funcname funcbody |
       local function Name funcbody |
       local namelist [`=´ explist]

   laststat ::= return [explist] | break

   funcname ::= Name {`.´ Name} [`:´ Name]

   varlist ::= var {`,´ var}

   var ::=  Name | prefixexp `[´ exp `]´ | prefixexp `.´ Name

   namelist ::= Name {`,´ Name}

   explist ::= {exp `,´} exp

   exp ::=  nil | false | true | Number | String | `...´ | function |
       prefixexp | tableconstructor | exp binop exp | unop exp

   prefixexp ::= var | functioncall | `(´ exp `)´

   functioncall ::=  prefixexp args | prefixexp `:´ Name args

   args ::=  `(´ [explist] `)´ | tableconstructor | String

   function ::= function funcbody

   funcbody ::= `(´ [parlist] `)´ block end

   parlist ::= namelist [`,´ `...´] | `...´

   tableconstructor ::= `{´ [fieldlist] `}´

   fieldlist ::= field {fieldsep field} [fieldsep]

   field ::= `[´ exp `]´ `=´ exp | Name `=´ exp | exp

   fieldsep ::= `,´ | `;´

   binop ::= `+´ | `-´ | `*´ | `/´ | `^´ | `%´ | `..´ |
       `<´ | `<=´ | `>´ | `>=´ | `==´ | `~=´ |
       and | or

   unop ::= `-´ | not | `#´"]
// END RANK codeblock_6


}
