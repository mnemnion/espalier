* PEG metatables


A collection of Node-descended metatables to provide sundry methodologies.


#!lua
local Node = require "espalier/node"
local core = require "singletons/core"
local Phrase = require "singletons/phrase"

local inherit = assert(core.inherit)
local insert, remove, concat = assert(table.insert),
                               assert(table.remove),
                               assert(table.concat)
local s = require "singletons/status" ()
#/lua


*** Peg base class

#!lua
local Peg, peg = Node : inherit()
Peg.id = "peg"
#/lua


*** Peg:toSexpr()

#!lua
local nl_map = { rule = true }
local function _toSexpr(peg, depth)
   depth = depth or 0
   local sexpr_line = { (" "):rep(depth), "(" } -- Phrase?
   local name = peg.name or peg.id
   insert(sexpr_line, name)
   insert(sexpr_line, " ")
   for _, sub_peg in ipairs(peg) do
      local _toS = sub_peg.toSexpr or _toSexpr
      insert(sexpr_line, _toS(sub_peg, depth + 1))
      insert(sexpr_line, " ")
   end
   remove(sexpr_line)
   insert(sexpr_line, ")")
   if nl_map[name] then
      insert(sexpr_line, "\n")
   end

   return concat(sexpr_line)
end

Peg.toSexpr = _toSexpr
#/lua


*** Peg:toSexprRepr()

A bit ugly perhaps, but this will let us view the sexprs as more than a
mere string.

I will most likely elaborate this past the useful point, in the pursuit of
happiness.

#Todo break out the string-building and concatenation exercises, so we can
interpolate colors into the repr string representation..

#!lua
local function __repr(repr, phrase, c)
   return _toSexpr(repr[1])
end

local ReprMeta = { __repr = __repr,
                   __tostring = __repr }
ReprMeta.__index = ReprMeta

local function newRepr(peg)
   local repr = setmetatable({}, ReprMeta)
   repr[1] = peg
   return repr
end
#/lua

#!lua
function Peg.toSexprRepr(peg)
   return newRepr(peg)
end
#/lua


** Peg.toLpeg(peg)

This needs to be implemented by each subclass, individually, so we produce a
base method that halts if we fall back to it.

#!lua
function Peg.toLpeg(peg)
   s:halt ("must implement toLepeg for class " .. peg.id)
end
#/lua

** PegMetas

#!lua
local PegMetas = Peg : inherit()
PegMetas.id = "pegMetas"
#/lua


*** PegPhrase class

We'll want to decorate our phrases with various REPRy enhancements, so let's
pull a fresh metatable:

#!lua
local PegPhrase = Phrase() : inherit ()
#/lua

*** Rules

#!lua
local Rules = PegMetas : inherit "rules"

local insert = assert(table.insert)

local function _suppressHiddens(peg_rules)
   local hiddens = {}
   for hidden_patt in peg_rules : select "hidden_pattern" do
      insert(hiddens, hidden_patt:span():sub(2,-2))
   end
   if #hiddens == 0 then
      -- no hidden patterns
      return nil
   end
   local phrase = PegPhrase "   " .. "SUPPRESS" .. " " .. "("
   for _, patt in ipairs(hiddens) do
      phrase = phrase .. "\"" .. patt .. "\"" .. "," .. " "
   end
   return phrase .. ")" .. "\n"
end

function Rules.toLpeg(peg_rules, depth)
   depth = depth or 0 -- for consistency
   -- _preProcessAST(peg_rules)
   local phrase = PegPhrase()
   -- the first rule should have an atom:
   -- peg_rules[1]   -- this is the first rule
   -- peg_rules[1]:select "rhs" : select "atom" . val
   -- maybe?
   local grammar_name = peg_rules : select "rule" ()
                         : select "pattern" ()
                         : span()
   phrase = phrase .. "local functionn _" .. grammar_name .. "_fn(_ENV)\n"
   phrase = phrase .. "   " .. "START " .. "\"" .. grammar_name .. "\"\n"
   -- Build the SUPPRESS function here, this requires finding the
   -- hidden rules and suppressing them
   local suppress = _suppressHiddens(peg_rules)
   if suppress then
      phrase = phrase .. suppress
   end
   --
   -- stick everything else in here...
   ---[[
   for rule in peg_rules : select "rule" do
      phrase = phrase .. rule:toLpeg(depth + 1)
   end
   --]]
   phrase = phrase .. "\nend\n"
   return phrase
end
#/lua

#!lua
local Rule = PegMetas : inherit "rule"

function Rule.toLpeg(rule, depth)
   depth = depth or 0
   local phrase = PegPhrase(("   "):rep(depth))
   local lhs = rule:select "pattern" () : span()
   phrase = phrase .. lhs .. " = "
   local rhs = rule:select "rhs" () : toLpeg (depth)
   return phrase .. rhs .. "\n"
end
#/lua

#!lua
local Rhs = PegMetas : inherit "rhs"

function Rhs.toLpeg(rhs, depth)
   local phrase = PegPhrase()
   for _, twig in ipairs(rhs) do
      phrase = phrase .. " " .. twig:toLpeg(depth + 1)
   end
   return phrase
end
#/lua

#!lua
local Choice = PegMetas : inherit "choice"

function Choice.toLpeg(choice, depth)
   local phrase = PegPhrase "+"
   for _, sub_choice in ipairs(choice) do
      phrase = phrase .. " " .. sub_choice:toLpeg(depth + 1)
   end
   return phrase
end
#/lua

#!lua
local Maybe = PegMetas : inherit "maybe"

function Maybe.toLpeg(maybe, depth)
   local phrase = PegPhrase()
   for _, sub_maybe in ipairs(maybe) do
      phrase = phrase .. " " .. sub_maybe:toLpeg(depth + 1)
   end
   return phrase .. "^-1"
end
#/lua

#!lua
local Cat = PegMetas : inherit "cat"

function Cat.toLpeg(cat, depth)
   local phrase = PegPhrase " * "
   for _, sub_cat in ipairs(cat) do
      phrase = phrase .. " " .. sub_cat:toLpeg(depth)
   end
   return phrase
end
#/lua

#!lua
local Group = PegMetas : inherit "group"

function Group.toLpeg(group, depth)
   local phrase = PegPhrase "("
   for _, sub_group in ipairs(group) do
      phrase = phrase .. " " .. sub_group:toLpeg(depth)
   end
   return phrase .. ")"
end
#/lua

#!lua
local Atom = PegMetas : inherit "atom"

function Atom.toLpeg(atom, depth)
   local phrase = PegPhrase "V"
   phrase = phrase .. "\"" .. atom:span() .. "\""
   return phrase
end
#/lua

#!lua
local Literal = PegMetas : inherit "literal"

function Literal.toLpeg(literal, depth)
   return PegPhrase "P" .. literal:span()
end
#/lua

#!lua
local Optional = PegMetas : inherit "optional"

function Optional.toLpeg(optional, depth)
   local phrase = PegPhrase()
   for _, sub_option in ipairs(optional) do
      phrase = phrase .. " " .. sub_option:toLpeg(depth)
   end
   return phrase .. "^0"
end
#/lua


#!lua
local Comment = PegMetas : inherit()
Comment.id = "comment"

function Comment.toSexpr(comment, depth)
   return ""
end

function Comment.toLpeg(comment, depth)
   local phrase = PegPhrase "--"
   return phrase .. comment:span():sub(2) .. "\n"
end
#/lua

#!lua
return { rules = Rules,
         rule  = Rule,
         rhs   = Rhs,
         comment = Comment,
         choice = Choice,
         cat     = Cat,
         group   = Group,
         atom    = Atom,
         maybe   = Maybe,
         literal = Literal,
         optional = Optional }
#/lua