* Extended Lpeg module


  This is where we add extended captures a la the old =epeg= 
module.

The difference here is that we include lpeg as a metatable __index
and can therefore use elpeg as L everywhere we currently use lpeg.

#!lua
local L = require "lpeg"
local elpatt = {}

local Cc = L.Cc

#/lua

** Ppt : Codepoint pattern

Captures one Unicode point

I actually have no idea how to do this yet...

Looks like byte 97 is just =\97= in Lua. That's easy enough.


*** num_bytes(str)

Captures the number of bytes in the next codepoint of a string.

The string must be well-formed utf-8, more precisely, a malformed
string will return =nil=.  A zero byte is correctly allowed by the
standard and will match here. 

#!lua
local function num_bytes(str)
--returns the number of bytes in the next character in str
   local c = str:byte(1)
   if type(c) == 'number' then
      if c >= 0x00 and c <= 0x7F then
         return 1
      elseif c >= 0xC2 and c <= 0xDF then
         return 2
      elseif c >= 0xE0 and c <= 0xEF then
         return 3
      elseif c >= 0xF0 and c <= 0xF4 then
         return 4
      end
   end
end
#/lua


** D : Drop a capture

  We discourage the use of captures in the Node class.  The architecture
requires that all array values of a Node table be themselves Nodes. This is
frequently checked for, in that we use =isNode= to filter in iterators etc,
but this is defensive. 

The use of SUPPRESS lets us drop rules that we don't want to see in the
final AST.  A normal approach to parsing has explicit captures, but this is
inelegant compared to treating any Node without children as a leaf.

What about regions of text that don't interest us?  Canonically this
includes whitespace.  For those occasions, we have =elpatt.D=. 

=D= needs to take a pattern, and if it succeeds in matching it, return a
special table, while discarding the captures if any. In =define=, we will
check for this table, and drop it whenever encountered.


  - patt :  The pattern to match and drop

  - #return : Special table DROP

#!lua

local DROP = {}

elpatt.DROP = DROP

function elpatt.D(patt)
   return (patt / 0) * Cc(DROP)
end

#/lua


#!lua
return elpatt
#/lua