* Node


  The Node class implements an abstract syntax tree, in collaboration with
the [[Grammar class][/grammar] and lpeg more generally.  


*** includes

#!lua
local s = require "status" ()
local a = require "ansi"
local dot = require "node/dot"
#/lua


** Node metatable

  The Node metatable is the root table for any Node, all of which should
subclass through [[Node:inherit()][httk://]].

#!lua
local Node = {}
Node.__index = Node
Node.isNode = true
#/lua


** Fields

   - id :  A string naming the Node. 
           This is identical to the name of the pattern that recognizes
           or captures it.

           This is never set on Node itself, and Grammar will fail to
           produce a Node which lacks this flag. 

   - isNode :  A boolean, always =true=.


** Methods


**** toLua

This is not a general method in any sense, it's here as a backstop
while I build out Clu. 

  - [ ] #todo remove

#!lua
function Node.toLua(node)
  s:halt("No toLua method for " .. node.id)
end
#/lua


*** Visualizer

This gives us a nice, tree-shaped printout of an entire Node.

We're less disciplined than we should be about up-assigning this to
inherited Node classes. 

#!lua
function Node.toString(node, depth)
   local depth = depth or 0
   local phrase = ""
   phrase = ("  "):rep(depth) .. a.bright(node.id) .. "    "
      .. a.cyan(node.first) .. "-" .. a.cyan(node.last)
   if node[1] then
      local extra = "    "
      if Node.len(node) > 56 then
         --  Truncate in the middle
         local span = Node.span(node)
         local pre, post = string.sub(span, 1, 26), string.sub(span, -26, -1)
         extra = extra .. a.dim(pre) .. a.bright("………") .. a.dim(post)
         extra = extra:gsub("\n", "◼︎")
      else
         extra = extra .. a.dim(Node.span(node):gsub("\n", "◼︎"))
      end
      phrase = phrase .. extra .. "\n"
      for _,v in ipairs(node) do
         if (v.isNode) then
            phrase = phrase .. Node.toString(v, depth + 1)
         end
      end
   else
      local val = node.str:sub(node.first, node.last)
                          :gsub(" ", a.clear() .. a.dim("_") .. a.green())
      val = a.green(val)
      phrase = phrase .. "    " .. val  .. "\n"
   end
   return phrase
end
#/lua

*** Metrics


**** span

#!lua
function Node.span(node)
   return string.sub(node.str, node.first, node.last)
end
#/lua


**** len

ahh, the pleasure of indexing by one. 

#!lua
function Node.len(node)
    return 1 + node.last - node.first
end
#/lua


**** Node:gap(node)

=Node.gap(left, right)= compares the =last= field of the =left= parameter
with the =first= field of the =right= parameter, *if* this is greater than
0. 

If it is negative, =Node.gap= attempts to measure the =first= field of the
=right= parameter against the =last= field of the =left= parameter.

If this is a natural number we return the *negation* of this value.  If both
should prove to be positive, we halt. 

No effort is made to check that the =str= field matches between nodes unless
we have an error, in which case it could prove helpful for diagnosis.  

Indeed such a check would be a disaster in streams or other sort of
piecewise parse.  Which will require implementation in and of itself, but
in the meantime...

#!lua
function Node.gap(left, right)
  assert(left.last, "no left.last")
  assert(right.first, "no right.first")
  assert(right.last, "no right.last")
  assert(left.first, "no left.first")
  if left.first >= right.last then
    local left, right = right, left
  elseif left.last > right.first then
    s:halt("overlapping regions or str issue")
  end
  local gap = left
  if gap >= 0 then
    return gap
  else
    s:halt("some kind of situation where gap is " .. tostring(gap))
  end

  return nil 
end
#/lua


#!lua
function Node.dotLabel(node)
  return node.id
end

function Node.toMarkdown(node)
  if not node[1] then
    return string.sub(node.str, node.first, node.last)
  else
    s:halt("no toMarkdown for " .. node.id)
  end
end

function Node.dot(node)
  return dot.dot(node)
end

function Node.toValue(node)
  if node.__VALUE then
    return node.__VALUE
  end
  if node.str then
    return node.str:sub(node.first,node.last)
  else
    s:halt("no str on node " .. node.id)
  end
end

#/lua

**** Node.walkPost

Depth-first iterator, postfix 

#!lua
function Node.walkPost(node)
    local function traverse(ast)
        if not ast.isNode then return nil end

        for _, v in ipairs(ast) do
            if type(v) == 'table' and v.isNode then
              traverse(v)
            end
        end
        coroutine.yield(ast)
    end

    return coroutine.wrap(function() traverse(node) end)
end
#/lua

**** Node.walk

Presearch iterator.  This is the default. 

#!lua
function Node.walk(node)
  local function traverse(ast)
    if not ast.isNode then return nil end

    coroutine.yield(ast)
    for _, v in ipairs(ast) do
      if type(v) == 'table' and v.isNode then
        traverse(v)
      end
    end
  end

  return coroutine.wrap(function() traverse(node) end)
end

#/lua


**** Node.select(node, pred)

  Takes the Node and walks it, yielding the Nodes which match the predicate.
=pred= is either a string, which matches to =id=, or a function, which takes
a Node and returns true or false on some premise. 

#!lua
function Node.select(node, pred)
   local function qualifies(node, pred)
      if type(pred) == 'string' then
         if type(node) == 'table' 
          and node.id and node.id == pred then
            return true
         else
            return false
         end
      elseif type(pred) == 'function' then
         return pred(node)
      else
         s:halt("cannot select on predicate of type " .. type(pred))
      end
   end

   local function traverse(ast)
      -- breadth first
      if qualifies(ast, pred) then
         coroutine.yield(ast)
      end
      if ast.isNode then
         for _, v in ipairs(ast) do
            traverse(v)
         end
      end
   end

   return coroutine.wrap(function() traverse(node) end)
end
#/lua


**** Node.tokens(node)

  Iterator returning all captured values as strings.

#!lua
function Node.tokens(node)
  local function traverse(ast)
    for node in Node.walk(ast) do
      if not node[1] then
        coroutine.yield(node:toValue())
      end
    end
  end

  return coroutine.wrap(function() traverse(node) end)
end  
#/lua 


**** Node.lines(node)

A memoized iterator returning =str= one line at a time. 

Newlines are not included.

In addition, the first =node:lines() traversal builds up
a sourcemap subsequently used by =node:atLine(pos)= to
return the line and column of a given position.

#!lua
function Node.lines(node)
  local function yieldLines(node, linum)
     for _, str in ipairs(node.__lines) do
        coroutine.yield(str)
      end
  end

  if node.__lines then
     return coroutine.wrap(function ()
                              yieldLines(node) 
                           end)
  else 
     node.__lines = {}
  end

  local function buildLines(str)
      if str == nil then
        return nil
      end
      local rest = ""
      local first, last = string.find(str, "\n")
      if first == nil then 
        return nil
      else
        local line = string.sub(str, 1, first - 1) -- no newline
        rest       = string.sub(str, last + 1)    -- skip newline
        node.__lines[#node.__lines + 1] = line
        coroutine.yield(line, rest)
      end
      buildLines(rest)
  end

  return coroutine.wrap(function () 
                           buildLines(node.str) 
                        end)
end
#/lua

**** Node.linePos(node, position)

Returns the line and column given a position. 

#!lua
function Node.linePos(node, position)
   if not node.__lines then
      for _ in node:lines() do
        -- nothing, this generates the line map
      end
   end
   local offset = 1
   local linum = nil
   for i, v in ipairs(node.__lines) do
       linum = i
       offset = offset + #v
       if offset > position then
          return linum, offset - position - #v
       end
   end
   return nil -- this position is off the end of the string
end
#/lua


**** Node.lastLeaf(node)

Returns the last leaf of the node.

Useful to check for terminal errors, for stop-on-error parsing. 

#!lua
function Node.lastLeaf(node)
  if #node == 0 then 
    return node
  else
    return Node.lastLeaf(node[#node])
  end
end
#/lua


*** Collectors

These return an array of all results. 

- [ ] #todo  Add a Forest class to provide the iterator interface for
             the return arrays of this class.

#!lua
function Node.gather(node, pred)
  local gathered = {}
  for ast in node:select(pred) do
    gathered[#gathered + 1] = ast
  end
  
  return gathered
end
#/lua

*** Subclassing and construction


**** N.inherit(node)

#!lua
function Node.inherit(node)
  local Meta = setmetatable({}, node)
  Meta.__index = Meta
  local meta = setmetatable({}, Meta)
  meta.__index = meta
  return Meta, meta
end

function Node.export(_, mod, constructor)
  mod.__call = constructor
  return setmetatable({}, mod)
end

#/lua


** Node Instances

  To be a Node, indexed elements of the Array portion must also be 
Nodes. 

If there are no children of the Node, it is considered to be a leaf node.

Most of the Node library will fail to halt, and probably blow stack, if
cyclic Node graphs are made.  The Grammar class will not do this to you. 


*** Fields

  There are invariant fields a Node is also expected to have, they are:
 
  - first :  Index into =str= which begins the span.
  - last  :  Index into =str= which ends the span.
  - str   :  The string of which the Node spans part or the whole.


*** Other fields

  In principle, anything at all. 

#!lua
return Node
#/lua


